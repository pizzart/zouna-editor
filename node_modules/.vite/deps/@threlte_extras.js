import {
  DisposableObject_default,
  HierarchicalObject_default,
  T,
  createRawEventDispatcher,
  currentWritable,
  forwardEventHandlers,
  injectPlugin,
  memoize,
  useCache,
  useFrame,
  useLoader,
  useParent,
  useThrelte,
  useThrelteUserContext,
  watch
} from "./chunk-KEIIC6MJ.js";
import {
  GLTFLoader
} from "./chunk-PN3FPHKO.js";
import {
  OrbitControls
} from "./chunk-FJZ4FK5T.js";
import {
  AnimationMixer,
  Audio,
  AudioListener,
  AudioLoader,
  BackSide,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  Camera,
  Color,
  CompressedArrayTexture,
  CompressedTexture,
  CubeReflectionMapping,
  CubeTexture,
  CubeTextureLoader,
  CylinderGeometry,
  Data3DTexture,
  DataTexture,
  DataTextureLoader,
  DataUtils,
  DefaultLoadingManager,
  DoubleSide,
  DynamicDrawUsage,
  EquirectangularReflectionMapping,
  Euler,
  FileLoader,
  Float32BufferAttribute,
  FloatType,
  FrontSide,
  Group,
  HalfFloatType,
  IcosahedronGeometry,
  InstancedBufferAttribute,
  InstancedBufferGeometry,
  Line,
  LineBasicMaterial,
  LinearEncoding,
  LinearFilter,
  LinearMipmapLinearFilter,
  LinearSRGBColorSpace,
  Loader,
  Material,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshStandardMaterial,
  NoColorSpace,
  Object3D,
  OctahedronGeometry,
  OrthographicCamera,
  PerspectiveCamera,
  PlaneBufferGeometry,
  PlaneGeometry,
  PositionalAudio,
  Quaternion,
  RGBADepthPacking,
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format,
  RGFormat,
  Raycaster,
  RedFormat,
  SRGBColorSpace,
  ShaderChunk,
  ShaderMaterial,
  Sphere,
  SphereGeometry,
  Texture,
  TextureLoader,
  TorusGeometry,
  UniformsUtils,
  UnsignedByteType,
  Vector2,
  Vector3,
  Vector4,
  WebGLRenderTarget,
  sRGBEncoding
} from "./chunk-ADRZNPHV.js";
import "./chunk-6A2TAOKG.js";
import {
  derived,
  writable
} from "./chunk-6NUSVQJM.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_flush_callback,
  add_location,
  add_render_callback,
  append_hydration_dev,
  assign,
  attr_dev,
  bind,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  component_subscribe,
  compute_rest_props,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  create_in_transition,
  create_out_transition,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_dynamic_element_data,
  space,
  subscribe,
  tick,
  transition_in,
  transition_out,
  update_slot_base,
  validate_dynamic_element,
  validate_each_argument,
  validate_slots,
  validate_store,
  validate_void_dynamic_element
} from "./chunk-CKECMU6L.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-Y4AOG3KG.js";

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        // Latin Extended-A block.
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func2, thisArg, args) {
        switch (args.length) {
          case 0:
            return func2.call(thisArg);
          case 1:
            return func2.call(thisArg, args[0]);
          case 2:
            return func2.call(thisArg, args[0], args[1]);
          case 3:
            return func2.call(thisArg, args[0], args[1], args[2]);
        }
        return func2.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n2, iteratee) {
        var index = -1, result = Array(n2);
        while (++index < n2) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func2) {
        return function(value) {
          return func2(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func2, transform) {
        return function(arg) {
          return func2(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func2 = getNative(Object2, "defineProperty");
            func2({}, "", {});
            return func2;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n2) {
          return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func2, wait, args) {
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func2.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func2 = object == null ? object : object[toKey(last(path))];
          return func2 == null ? undefined2 : apply(func2, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n2) {
          var length = array.length;
          if (!length) {
            return;
          }
          n2 += n2 < 0 ? length : 0;
          return isIndex(n2, length) ? array[n2] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n2) {
          var result2 = "";
          if (!string || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n2 % 2) {
              result2 += string;
            }
            n2 = nativeFloor(n2 / 2);
            if (n2) {
              string += string;
            }
          } while (n2);
          return result2;
        }
        function baseRest(func2, start) {
          return setToString(overRest(func2, start, identity), func2 + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n2) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n2, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func2, data) {
          metaMap.set(func2, data);
          return func2;
        };
        var baseSetToString = !defineProperty ? identity : function(func2, string) {
          return defineProperty(func2, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func2 = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func2(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func2, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func2);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func2;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func2, bitmask, arity) {
          var Ctor = createCtor(func2);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func2,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func2;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func2 = funcs[index];
              if (typeof func2 != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func2) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func2 = funcs[index];
              var funcName = getFuncName(func2), data = funcName == "wrapper" ? getData(func2) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func2.length == 1 && isLaziable(func2) ? wrapper[funcName]() : wrapper.thru(func2);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func2, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func2);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func2,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func2] : func2;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func2, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func2);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func2;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func2, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func2,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func2)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func2, bitmask);
        }
        function createRound(methodName) {
          var func2 = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func2(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func2(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func2, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func2);
          var newData = [
            func2,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func2 = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func2.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func2, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func2, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func2, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func2, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func2) {
          return setToString(overRest(func2, undefined2, flatten), func2 + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop2 : function(func2) {
          return metaMap.get(func2);
        };
        function getFuncName(func2) {
          var result2 = func2.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func2) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func2) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func2;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func2) {
          var funcName = getFuncName(func2), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func2 === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func2 === data[0];
        }
        function isMasked(func2) {
          return !!maskSrcKey && maskSrcKey in func2;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func2) {
          var result2 = memoize2(func2, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func2, start, transform2) {
          start = nativeMax(start === undefined2 ? func2.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func2, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func2, wait) {
          return root.setTimeout(func2, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func2) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func2.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func2) {
          if (func2 != null) {
            try {
              return funcToString.call(func2);
            } catch (e) {
            }
            try {
              return func2 + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          return baseSlice(array, n2 < 0 ? 0 : n2, length);
        }
        function dropRight(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          n2 = length - n2;
          return baseSlice(array, 0, n2 < 0 ? 0 : n2);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n2) {
          return array && array.length ? baseNth(array, toInteger(n2)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n2, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          return baseSlice(array, 0, n2 < 0 ? 0 : n2);
        }
        function takeRight(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
          n2 = length - n2;
          return baseSlice(array, n2 < 0 ? 0 : n2, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func2 = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func2(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func2 = isArray(collection) ? arrayFilter : baseFilter;
          return func2(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func2 = isArray(collection) ? arrayEach : baseEach;
          return func2(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func2 = isArray(collection) ? arrayEachRight : baseEachRight;
          return func2(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func2 = isArray(collection) ? arrayMap : baseMap;
          return func2(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func2 = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func2(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func2 = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func2(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func2 = isArray(collection) ? arrayFilter : baseFilter;
          return func2(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func2 = isArray(collection) ? arraySample : baseSample;
          return func2(collection);
        }
        function sampleSize(collection, n2, guard) {
          if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined2) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          var func2 = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func2(collection, n2);
        }
        function shuffle(collection) {
          var func2 = isArray(collection) ? arrayShuffle : baseShuffle;
          return func2(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func2 = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func2(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now2 = ctxNow || function() {
          return root.Date.now();
        };
        function after(n2, func2) {
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 < 1) {
              return func2.apply(this, arguments);
            }
          };
        }
        function ary(func2, n2, guard) {
          n2 = guard ? undefined2 : n2;
          n2 = func2 && n2 == null ? func2.length : n2;
          return createWrap(func2, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n2);
        }
        function before(n2, func2) {
          var result2;
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 > 0) {
              result2 = func2.apply(this, arguments);
            }
            if (n2 <= 1) {
              func2 = undefined2;
            }
            return result2;
          };
        }
        var bind2 = baseRest(function(func2, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind2));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func2, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func2, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func2, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func2, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func2, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func2, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func2.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now2();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now2());
          }
          function debounced() {
            var time = now2(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func2, args) {
          return baseDelay(func2, 1, args);
        });
        var delay = baseRest(function(func2, wait, args) {
          return baseDelay(func2, toNumber(wait) || 0, args);
        });
        function flip(func2) {
          return createWrap(func2, WRAP_FLIP_FLAG);
        }
        function memoize2(func2, resolver) {
          if (typeof func2 != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func2.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize2.Cache || MapCache)();
          return memoized;
        }
        memoize2.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func2) {
          return before(2, func2);
        }
        var overArgs = castRest(function(func2, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func2, this, args);
          });
        });
        var partial = baseRest(function(func2, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func2, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func2, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func2, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func2, indexes) {
          return createWrap(func2, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func2, start) {
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func2, start);
        }
        function spread(func2, start) {
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func2, this, otherArgs);
          });
        }
        function throttle(func2, wait, options) {
          var leading = true, trailing = true;
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func2, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func2) {
          return ary(func2, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt2 = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func2 = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func2(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign4 = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit2 = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick2 = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n2, guard) {
          if (guard ? isIterateeCall(string, n2, guard) : n2 === undefined2) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          return baseRepeat(toString(string), n2);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func2, args) {
          try {
            return apply(func2, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind2(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func2) {
          return baseIteratee(typeof func2 == "function" ? func2 : baseClone(func2, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func2 = source[methodName];
            object[methodName] = func2;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func2, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func2.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop2() {
        }
        function nthArg(n2) {
          n2 = toInteger(n2);
          return baseRest(function(args) {
            return baseNth(args, n2);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n2, iteratee2) {
          n2 = toInteger(n2);
          if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n2, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n2 -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n2) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign4;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind2;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize2;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit2;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick2;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt2;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop2;
        lodash.now = now2;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func2, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func2;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n2) {
            n2 = n2 === undefined2 ? 1 : nativeMax(toInteger(n2), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n2, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n2) {
            return this.reverse()[methodName](n2).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func2, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func2.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func2.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func2 = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func2.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func2.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func2, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports);
  }
});

// node_modules/@threlte/extras/dist/hooks/useCursor.js
var useCursor = (onPointerOver = "pointer", onPointerOut = "auto", target = void 0) => {
  let hovering = false;
  const hoveringStore = writable(false);
  const onPointerEnter = () => {
    hoveringStore.set(true);
  };
  const onPointerLeave = () => {
    hoveringStore.set(false);
  };
  if (typeof window === "undefined") {
    return {
      hovering: hoveringStore,
      onPointerEnter,
      onPointerLeave
    };
  }
  const el = target ?? document.body;
  let onPointerOverValue = typeof onPointerOver === "string" ? onPointerOver : get_store_value(onPointerOver);
  if (typeof onPointerOver !== "string") {
    const unsubscribeOnPointerOver = onPointerOver.subscribe((cursorStyle) => {
      onPointerOverValue = cursorStyle;
      if (hovering) {
        el.style.cursor = cursorStyle;
      }
    });
    onDestroy(unsubscribeOnPointerOver);
  }
  let onPointerOutValue = typeof onPointerOut === "string" ? onPointerOut : get_store_value(onPointerOut);
  if (typeof onPointerOut !== "string") {
    const unsubscribeOnPointerOut = onPointerOut.subscribe((cursorStyle) => {
      onPointerOutValue = cursorStyle;
      if (!hovering) {
        el.style.cursor = cursorStyle;
      }
    });
    onDestroy(unsubscribeOnPointerOut);
  }
  const unsubscribeHovering = hoveringStore.subscribe((isHovering) => {
    hovering = isHovering;
    if (isHovering) {
      el.style.cursor = onPointerOverValue;
    } else {
      el.style.cursor = onPointerOutValue;
    }
  });
  onDestroy(unsubscribeHovering);
  onDestroy(() => {
    el.style.cursor = onPointerOutValue;
  });
  return {
    hovering: hoveringStore,
    onPointerEnter,
    onPointerLeave
  };
};

// node_modules/three/examples/jsm/libs/meshopt_decoder.module.js
var MeshoptDecoder = function() {
  "use strict";
  var wasm_base = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb";
  var wasm_simd = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb";
  var detector = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
  var wasmpack = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]);
  if (typeof WebAssembly !== "object") {
    return {
      supported: false
    };
  }
  var wasm = WebAssembly.validate(detector) ? wasm_simd : wasm_base;
  var instance24;
  var ready = WebAssembly.instantiate(unpack(wasm), {}).then(function(result) {
    instance24 = result.instance;
    instance24.exports.__wasm_call_ctors();
  });
  function unpack(data) {
    var result = new Uint8Array(data.length);
    for (var i = 0; i < data.length; ++i) {
      var ch = data.charCodeAt(i);
      result[i] = ch > 96 ? ch - 97 : ch > 64 ? ch - 39 : ch + 4;
    }
    var write = 0;
    for (var i = 0; i < data.length; ++i) {
      result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];
    }
    return result.buffer.slice(0, write);
  }
  function decode(fun, target, count, size, source, filter) {
    var sbrk = instance24.exports.sbrk;
    var count4 = count + 3 & ~3;
    var tp = sbrk(count4 * size);
    var sp = sbrk(source.length);
    var heap = new Uint8Array(instance24.exports.memory.buffer);
    heap.set(source, sp);
    var res = fun(tp, count, size, sp, source.length);
    if (res == 0 && filter) {
      filter(tp, count4, size);
    }
    target.set(heap.subarray(tp, tp + count * size));
    sbrk(tp - sbrk(0));
    if (res != 0) {
      throw new Error("Malformed buffer data: " + res);
    }
  }
  var filters = {
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  };
  var decoders = {
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  };
  var workers2 = [];
  var requestId = 0;
  function createWorker(url) {
    var worker = {
      object: new Worker(url),
      pending: 0,
      requests: {}
    };
    worker.object.onmessage = function(event) {
      var data = event.data;
      worker.pending -= data.count;
      worker.requests[data.id][data.action](data.value);
      delete worker.requests[data.id];
    };
    return worker;
  }
  function initWorkers(count) {
    var source = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(unpack(wasm)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + decode.toString() + workerProcess.toString();
    var blob = new Blob([source], { type: "text/javascript" });
    var url = URL.createObjectURL(blob);
    for (var i = 0; i < count; ++i) {
      workers2[i] = createWorker(url);
    }
    URL.revokeObjectURL(url);
  }
  function decodeWorker(count, size, source, mode, filter) {
    var worker = workers2[0];
    for (var i = 1; i < workers2.length; ++i) {
      if (workers2[i].pending < worker.pending) {
        worker = workers2[i];
      }
    }
    return new Promise(function(resolve, reject) {
      var data = new Uint8Array(source);
      var id = requestId++;
      worker.pending += count;
      worker.requests[id] = { resolve, reject };
      worker.object.postMessage({ id, count, size, source: data, mode, filter }, [data.buffer]);
    });
  }
  function workerProcess(event) {
    ready.then(function() {
      var data = event.data;
      try {
        var target = new Uint8Array(data.count * data.size);
        decode(instance24.exports[data.mode], target, data.count, data.size, data.source, instance24.exports[data.filter]);
        self.postMessage({ id: data.id, count: data.count, action: "resolve", value: target }, [target.buffer]);
      } catch (error) {
        self.postMessage({ id: data.id, count: data.count, action: "reject", value: error });
      }
    });
  }
  return {
    ready,
    supported: true,
    useWorkers: function(count) {
      initWorkers(count);
    },
    decodeVertexBuffer: function(target, count, size, source, filter) {
      decode(instance24.exports.meshopt_decodeVertexBuffer, target, count, size, source, instance24.exports[filters[filter]]);
    },
    decodeIndexBuffer: function(target, count, size, source) {
      decode(instance24.exports.meshopt_decodeIndexBuffer, target, count, size, source);
    },
    decodeIndexSequence: function(target, count, size, source) {
      decode(instance24.exports.meshopt_decodeIndexSequence, target, count, size, source);
    },
    decodeGltfBuffer: function(target, count, size, source, mode, filter) {
      decode(instance24.exports[decoders[mode]], target, count, size, source, instance24.exports[filters[filter]]);
    },
    decodeGltfBufferAsync: function(count, size, source, mode, filter) {
      if (workers2.length > 0) {
        return decodeWorker(count, size, source, decoders[mode], filters[filter]);
      }
      return ready.then(function() {
        var target = new Uint8Array(count * size);
        decode(instance24.exports[decoders[mode]], target, count, size, source, instance24.exports[filters[filter]]);
        return target;
      });
    }
  };
}();

// node_modules/three/examples/jsm/loaders/DRACOLoader.js
var _taskCache = /* @__PURE__ */ new WeakMap();
var DRACOLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.decoderPath = "";
    this.decoderConfig = {};
    this.decoderBinary = null;
    this.decoderPending = null;
    this.workerLimit = 4;
    this.workerPool = [];
    this.workerNextTaskID = 1;
    this.workerSourceURL = "";
    this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    };
    this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(path) {
    this.decoderPath = path;
    return this;
  }
  setDecoderConfig(config) {
    this.decoderConfig = config;
    return this;
  }
  setWorkerLimit(workerLimit) {
    this.workerLimit = workerLimit;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (buffer) => {
      this.parse(buffer, onLoad, onError);
    }, onProgress, onError);
  }
  parse(buffer, onLoad, onError) {
    this.decodeDracoFile(buffer, onLoad, null, null, SRGBColorSpace).catch(onError);
  }
  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace) {
    const taskConfig = {
      attributeIDs: attributeIDs || this.defaultAttributeIDs,
      attributeTypes: attributeTypes || this.defaultAttributeTypes,
      useUniqueIDs: !!attributeIDs,
      vertexColorSpace
    };
    return this.decodeGeometry(buffer, taskConfig).then(callback);
  }
  decodeGeometry(buffer, taskConfig) {
    const taskKey = JSON.stringify(taskConfig);
    if (_taskCache.has(buffer)) {
      const cachedTask = _taskCache.get(buffer);
      if (cachedTask.key === taskKey) {
        return cachedTask.promise;
      } else if (buffer.byteLength === 0) {
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
      }
    }
    let worker;
    const taskID = this.workerNextTaskID++;
    const taskCost = buffer.byteLength;
    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {
      worker = _worker;
      return new Promise((resolve, reject) => {
        worker._callbacks[taskID] = { resolve, reject };
        worker.postMessage({ type: "decode", id: taskID, taskConfig, buffer }, [buffer]);
      });
    }).then((message) => this._createGeometry(message.geometry));
    geometryPending.catch(() => true).then(() => {
      if (worker && taskID) {
        this._releaseTask(worker, taskID);
      }
    });
    _taskCache.set(buffer, {
      key: taskKey,
      promise: geometryPending
    });
    return geometryPending;
  }
  _createGeometry(geometryData) {
    const geometry = new BufferGeometry();
    if (geometryData.index) {
      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));
    }
    for (let i = 0; i < geometryData.attributes.length; i++) {
      const result = geometryData.attributes[i];
      const name = result.name;
      const array = result.array;
      const itemSize = result.itemSize;
      const attribute = new BufferAttribute(array, itemSize);
      if (name === "color") {
        this._assignVertexColorSpace(attribute, result.vertexColorSpace);
        attribute.normalized = array instanceof Float32Array === false;
      }
      geometry.setAttribute(name, attribute);
    }
    return geometry;
  }
  _assignVertexColorSpace(attribute, inputColorSpace) {
    if (inputColorSpace !== SRGBColorSpace)
      return;
    const _color = new Color();
    for (let i = 0, il = attribute.count; i < il; i++) {
      _color.fromBufferAttribute(attribute, i).convertSRGBToLinear();
      attribute.setXYZ(i, _color.r, _color.g, _color.b);
    }
  }
  _loadLibrary(url, responseType) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.decoderPath);
    loader.setResponseType(responseType);
    loader.setWithCredentials(this.withCredentials);
    return new Promise((resolve, reject) => {
      loader.load(url, resolve, void 0, reject);
    });
  }
  preload() {
    this._initDecoder();
    return this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const useJS = typeof WebAssembly !== "object" || this.decoderConfig.type === "js";
    const librariesPending = [];
    if (useJS) {
      librariesPending.push(this._loadLibrary("draco_decoder.js", "text"));
    } else {
      librariesPending.push(this._loadLibrary("draco_wasm_wrapper.js", "text"));
      librariesPending.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"));
    }
    this.decoderPending = Promise.all(librariesPending).then((libraries) => {
      const jsContent = libraries[0];
      if (!useJS) {
        this.decoderConfig.wasmBinary = libraries[1];
      }
      const fn = DRACOWorker.toString();
      const body = [
        "/* draco decoder */",
        jsContent,
        "",
        "/* worker */",
        fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
      ].join("\n");
      this.workerSourceURL = URL.createObjectURL(new Blob([body]));
    });
    return this.decoderPending;
  }
  _getWorker(taskID, taskCost) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const worker2 = new Worker(this.workerSourceURL);
        worker2._callbacks = {};
        worker2._taskCosts = {};
        worker2._taskLoad = 0;
        worker2.postMessage({ type: "init", decoderConfig: this.decoderConfig });
        worker2.onmessage = function(e) {
          const message = e.data;
          switch (message.type) {
            case "decode":
              worker2._callbacks[message.id].resolve(message);
              break;
            case "error":
              worker2._callbacks[message.id].reject(message);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"');
          }
        };
        this.workerPool.push(worker2);
      } else {
        this.workerPool.sort(function(a, b) {
          return a._taskLoad > b._taskLoad ? -1 : 1;
        });
      }
      const worker = this.workerPool[this.workerPool.length - 1];
      worker._taskCosts[taskID] = taskCost;
      worker._taskLoad += taskCost;
      return worker;
    });
  }
  _releaseTask(worker, taskID) {
    worker._taskLoad -= worker._taskCosts[taskID];
    delete worker._callbacks[taskID];
    delete worker._taskCosts[taskID];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((worker) => worker._taskLoad));
  }
  dispose() {
    for (let i = 0; i < this.workerPool.length; ++i) {
      this.workerPool[i].terminate();
    }
    this.workerPool.length = 0;
    if (this.workerSourceURL !== "") {
      URL.revokeObjectURL(this.workerSourceURL);
    }
    return this;
  }
};
function DRACOWorker() {
  let decoderConfig;
  let decoderPending;
  onmessage = function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        decoderConfig = message.decoderConfig;
        decoderPending = new Promise(function(resolve) {
          decoderConfig.onModuleLoaded = function(draco) {
            resolve({ draco });
          };
          DracoDecoderModule(decoderConfig);
        });
        break;
      case "decode":
        const buffer = message.buffer;
        const taskConfig = message.taskConfig;
        decoderPending.then((module) => {
          const draco = module.draco;
          const decoder = new draco.Decoder();
          try {
            const geometry = decodeGeometry(draco, decoder, new Int8Array(buffer), taskConfig);
            const buffers = geometry.attributes.map((attr) => attr.array.buffer);
            if (geometry.index)
              buffers.push(geometry.index.array.buffer);
            self.postMessage({ type: "decode", id: message.id, geometry }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({ type: "error", id: message.id, error: error.message });
          } finally {
            draco.destroy(decoder);
          }
        });
        break;
    }
  };
  function decodeGeometry(draco, decoder, array, taskConfig) {
    const attributeIDs = taskConfig.attributeIDs;
    const attributeTypes = taskConfig.attributeTypes;
    let dracoGeometry;
    let decodingStatus;
    const geometryType = decoder.GetEncodedGeometryType(array);
    if (geometryType === draco.TRIANGULAR_MESH) {
      dracoGeometry = new draco.Mesh();
      decodingStatus = decoder.DecodeArrayToMesh(array, array.byteLength, dracoGeometry);
    } else if (geometryType === draco.POINT_CLOUD) {
      dracoGeometry = new draco.PointCloud();
      decodingStatus = decoder.DecodeArrayToPointCloud(array, array.byteLength, dracoGeometry);
    } else {
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    }
    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
      throw new Error("THREE.DRACOLoader: Decoding failed: " + decodingStatus.error_msg());
    }
    const geometry = { index: null, attributes: [] };
    for (const attributeName in attributeIDs) {
      const attributeType = self[attributeTypes[attributeName]];
      let attribute;
      let attributeID;
      if (taskConfig.useUniqueIDs) {
        attributeID = attributeIDs[attributeName];
        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
      } else {
        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);
        if (attributeID === -1)
          continue;
        attribute = decoder.GetAttribute(dracoGeometry, attributeID);
      }
      const attributeResult = decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute);
      if (attributeName === "color") {
        attributeResult.vertexColorSpace = taskConfig.vertexColorSpace;
      }
      geometry.attributes.push(attributeResult);
    }
    if (geometryType === draco.TRIANGULAR_MESH) {
      geometry.index = decodeIndex(draco, decoder, dracoGeometry);
    }
    draco.destroy(dracoGeometry);
    return geometry;
  }
  function decodeIndex(draco, decoder, dracoGeometry) {
    const numFaces = dracoGeometry.num_faces();
    const numIndices = numFaces * 3;
    const byteLength = numIndices * 4;
    const ptr = draco._malloc(byteLength);
    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();
    draco._free(ptr);
    return { array: index, itemSize: 1 };
  }
  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
    const numComponents = attribute.num_components();
    const numPoints = dracoGeometry.num_points();
    const numValues = numPoints * numComponents;
    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
    const dataType = getDracoDataType(draco, attributeType);
    const ptr = draco._malloc(byteLength);
    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();
    draco._free(ptr);
    return {
      name: attributeName,
      array,
      itemSize: numComponents
    };
  }
  function getDracoDataType(draco, attributeType) {
    switch (attributeType) {
      case Float32Array:
        return draco.DT_FLOAT32;
      case Int8Array:
        return draco.DT_INT8;
      case Int16Array:
        return draco.DT_INT16;
      case Int32Array:
        return draco.DT_INT32;
      case Uint8Array:
        return draco.DT_UINT8;
      case Uint16Array:
        return draco.DT_UINT16;
      case Uint32Array:
        return draco.DT_UINT32;
    }
  }
}

// node_modules/three/examples/jsm/utils/WorkerPool.js
var WorkerPool = class {
  constructor(pool = 4) {
    this.pool = pool;
    this.queue = [];
    this.workers = [];
    this.workersResolve = [];
    this.workerStatus = 0;
  }
  _initWorker(workerId) {
    if (!this.workers[workerId]) {
      const worker = this.workerCreator();
      worker.addEventListener("message", this._onMessage.bind(this, workerId));
      this.workers[workerId] = worker;
    }
  }
  _getIdleWorker() {
    for (let i = 0; i < this.pool; i++)
      if (!(this.workerStatus & 1 << i))
        return i;
    return -1;
  }
  _onMessage(workerId, msg) {
    const resolve = this.workersResolve[workerId];
    resolve && resolve(msg);
    if (this.queue.length) {
      const { resolve: resolve2, msg: msg2, transfer } = this.queue.shift();
      this.workersResolve[workerId] = resolve2;
      this.workers[workerId].postMessage(msg2, transfer);
    } else {
      this.workerStatus ^= 1 << workerId;
    }
  }
  setWorkerCreator(workerCreator) {
    this.workerCreator = workerCreator;
  }
  setWorkerLimit(pool) {
    this.pool = pool;
  }
  postMessage(msg, transfer) {
    return new Promise((resolve) => {
      const workerId = this._getIdleWorker();
      if (workerId !== -1) {
        this._initWorker(workerId);
        this.workerStatus |= 1 << workerId;
        this.workersResolve[workerId] = resolve;
        this.workers[workerId].postMessage(msg, transfer);
      } else {
        this.queue.push({ resolve, msg, transfer });
      }
    });
  }
  dispose() {
    this.workers.forEach((worker) => worker.terminate());
    this.workersResolve.length = 0;
    this.workers.length = 0;
    this.queue.length = 0;
    this.workerStatus = 0;
  }
};

// node_modules/three/examples/jsm/libs/ktx-parse.module.js
var t = 0;
var n = 2;
var p = 1;
var x = 2;
var nt = 0;
var ct = 9;
var gt = 15;
var yt = 16;
var dt = 22;
var Ot = 37;
var Ft = 43;
var $t = 76;
var se = 83;
var pe = 97;
var xe = 100;
var de = 103;
var Ae = 109;
var Si = class {
  constructor() {
    this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null;
  }
};
var Ii = class {
  constructor(t2, e, n2, i) {
    this._dataView = new DataView(t2.buffer, t2.byteOffset + e, n2), this._littleEndian = i, this._offset = 0;
  }
  _nextUint8() {
    const t2 = this._dataView.getUint8(this._offset);
    return this._offset += 1, t2;
  }
  _nextUint16() {
    const t2 = this._dataView.getUint16(this._offset, this._littleEndian);
    return this._offset += 2, t2;
  }
  _nextUint32() {
    const t2 = this._dataView.getUint32(this._offset, this._littleEndian);
    return this._offset += 4, t2;
  }
  _nextUint64() {
    const t2 = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
    return this._offset += 8, t2;
  }
  _nextInt32() {
    const t2 = this._dataView.getInt32(this._offset, this._littleEndian);
    return this._offset += 4, t2;
  }
  _skip(t2) {
    return this._offset += t2, this;
  }
  _scan(t2, e = 0) {
    const n2 = this._offset;
    let i = 0;
    for (; this._dataView.getUint8(this._offset) !== e && i < t2; )
      i++, this._offset++;
    return i < t2 && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n2, i);
  }
};
var Oi = new Uint8Array([0]);
var Ti = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function Ei(t2) {
  return "undefined" != typeof TextDecoder ? new TextDecoder().decode(t2) : Buffer.from(t2).toString("utf8");
}
function Pi(t2) {
  const e = new Uint8Array(t2.buffer, t2.byteOffset, Ti.length);
  if (e[0] !== Ti[0] || e[1] !== Ti[1] || e[2] !== Ti[2] || e[3] !== Ti[3] || e[4] !== Ti[4] || e[5] !== Ti[5] || e[6] !== Ti[6] || e[7] !== Ti[7] || e[8] !== Ti[8] || e[9] !== Ti[9] || e[10] !== Ti[10] || e[11] !== Ti[11])
    throw new Error("Missing KTX 2.0 identifier.");
  const n2 = new Si(), i = 17 * Uint32Array.BYTES_PER_ELEMENT, s = new Ii(t2, Ti.length, i, true);
  n2.vkFormat = s._nextUint32(), n2.typeSize = s._nextUint32(), n2.pixelWidth = s._nextUint32(), n2.pixelHeight = s._nextUint32(), n2.pixelDepth = s._nextUint32(), n2.layerCount = s._nextUint32(), n2.faceCount = s._nextUint32();
  const a = s._nextUint32();
  n2.supercompressionScheme = s._nextUint32();
  const r = s._nextUint32(), o = s._nextUint32(), l = s._nextUint32(), f = s._nextUint32(), U = s._nextUint64(), c = s._nextUint64(), h = new Ii(t2, Ti.length + i, 3 * a * 8, true);
  for (let e2 = 0; e2 < a; e2++)
    n2.levels.push({ levelData: new Uint8Array(t2.buffer, t2.byteOffset + h._nextUint64(), h._nextUint64()), uncompressedByteLength: h._nextUint64() });
  const _ = new Ii(t2, r, o, true), p2 = { vendorId: _._skip(4)._nextUint16(), descriptorType: _._nextUint16(), versionNumber: _._nextUint16(), descriptorBlockSize: _._nextUint16(), colorModel: _._nextUint8(), colorPrimaries: _._nextUint8(), transferFunction: _._nextUint8(), flags: _._nextUint8(), texelBlockDimension: [_._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8()], bytesPlane: [_._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8()], samples: [] }, g2 = (p2.descriptorBlockSize / 4 - 6) / 4;
  for (let t3 = 0; t3 < g2; t3++) {
    const e2 = { bitOffset: _._nextUint16(), bitLength: _._nextUint8(), channelType: _._nextUint8(), samplePosition: [_._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8()], sampleLower: -Infinity, sampleUpper: Infinity };
    64 & e2.channelType ? (e2.sampleLower = _._nextInt32(), e2.sampleUpper = _._nextInt32()) : (e2.sampleLower = _._nextUint32(), e2.sampleUpper = _._nextUint32()), p2.samples[t3] = e2;
  }
  n2.dataFormatDescriptor.length = 0, n2.dataFormatDescriptor.push(p2);
  const y = new Ii(t2, l, f, true);
  for (; y._offset < f; ) {
    const t3 = y._nextUint32(), e2 = y._scan(t3), i2 = Ei(e2), s2 = y._scan(t3 - e2.byteLength);
    n2.keyValue[i2] = i2.match(/^ktx/i) ? Ei(s2) : s2, y._offset % 4 && y._skip(4 - y._offset % 4);
  }
  if (c <= 0)
    return n2;
  const x2 = new Ii(t2, U, c, true), u = x2._nextUint16(), b = x2._nextUint16(), d = x2._nextUint32(), m = x2._nextUint32(), w = x2._nextUint32(), D = x2._nextUint32(), B2 = [];
  for (let t3 = 0; t3 < a; t3++)
    B2.push({ imageFlags: x2._nextUint32(), rgbSliceByteOffset: x2._nextUint32(), rgbSliceByteLength: x2._nextUint32(), alphaSliceByteOffset: x2._nextUint32(), alphaSliceByteLength: x2._nextUint32() });
  const L = U + x2._offset, A2 = L + d, k = A2 + m, v = k + w, S = new Uint8Array(t2.buffer, t2.byteOffset + L, d), I2 = new Uint8Array(t2.buffer, t2.byteOffset + A2, m), O = new Uint8Array(t2.buffer, t2.byteOffset + k, w), T2 = new Uint8Array(t2.buffer, t2.byteOffset + v, D);
  return n2.globalData = { endpointCount: u, selectorCount: b, imageDescs: B2, endpointsData: S, selectorsData: I2, tablesData: O, extendedData: T2 }, n2;
}

// node_modules/three/examples/jsm/libs/zstddec.module.js
var A;
var I;
var B;
var g = { env: { emscripten_notify_memory_growth: function(A2) {
  B = new Uint8Array(I.exports.memory.buffer);
} } };
var Q = class {
  init() {
    return A || (A = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + C).then((A2) => A2.arrayBuffer()).then((A2) => WebAssembly.instantiate(A2, g)).then(this._init) : WebAssembly.instantiate(Buffer.from(C, "base64"), g).then(this._init), A);
  }
  _init(A2) {
    I = A2.instance, g.env.emscripten_notify_memory_growth(0);
  }
  decode(A2, g2 = 0) {
    if (!I)
      throw new Error("ZSTDDecoder: Await .init() before decoding.");
    const Q2 = A2.byteLength, C2 = I.exports.malloc(Q2);
    B.set(A2, C2), g2 = g2 || Number(I.exports.ZSTD_findDecompressedSize(C2, Q2));
    const E = I.exports.malloc(g2), i = I.exports.ZSTD_decompress(E, g2, C2, Q2), D = B.slice(E, E + i);
    return I.exports.free(C2), I.exports.free(E), D;
  }
};
var C = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ";

// node_modules/three/examples/jsm/loaders/KTX2Loader.js
var _taskCache2 = /* @__PURE__ */ new WeakMap();
var _activeLoaders = 0;
var _zstd;
var KTX2Loader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.transcoderPath = "";
    this.transcoderBinary = null;
    this.transcoderPending = null;
    this.workerPool = new WorkerPool();
    this.workerSourceURL = "";
    this.workerConfig = null;
    if (typeof MSC_TRANSCODER !== "undefined") {
      console.warn(
        'THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.'
      );
    }
  }
  setTranscoderPath(path) {
    this.transcoderPath = path;
    return this;
  }
  setWorkerLimit(num) {
    this.workerPool.setWorkerLimit(num);
    return this;
  }
  detectSupport(renderer) {
    if (renderer.isWebGPURenderer === true) {
      this.workerConfig = {
        astcSupported: renderer.hasFeature("texture-compression-astc"),
        etc1Supported: false,
        etc2Supported: renderer.hasFeature("texture-compression-etc2"),
        dxtSupported: renderer.hasFeature("texture-compression-bc"),
        bptcSupported: false,
        pvrtcSupported: false
      };
    } else {
      this.workerConfig = {
        astcSupported: renderer.extensions.has("WEBGL_compressed_texture_astc"),
        etc1Supported: renderer.extensions.has("WEBGL_compressed_texture_etc1"),
        etc2Supported: renderer.extensions.has("WEBGL_compressed_texture_etc"),
        dxtSupported: renderer.extensions.has("WEBGL_compressed_texture_s3tc"),
        bptcSupported: renderer.extensions.has("EXT_texture_compression_bptc"),
        pvrtcSupported: renderer.extensions.has("WEBGL_compressed_texture_pvrtc") || renderer.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
      };
      if (renderer.capabilities.isWebGL2) {
        this.workerConfig.etc1Supported = false;
      }
    }
    return this;
  }
  init() {
    if (!this.transcoderPending) {
      const jsLoader = new FileLoader(this.manager);
      jsLoader.setPath(this.transcoderPath);
      jsLoader.setWithCredentials(this.withCredentials);
      const jsContent = jsLoader.loadAsync("basis_transcoder.js");
      const binaryLoader = new FileLoader(this.manager);
      binaryLoader.setPath(this.transcoderPath);
      binaryLoader.setResponseType("arraybuffer");
      binaryLoader.setWithCredentials(this.withCredentials);
      const binaryContent = binaryLoader.loadAsync("basis_transcoder.wasm");
      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent2, binaryContent2]) => {
        const fn = KTX2Loader.BasisWorker.toString();
        const body = [
          "/* constants */",
          "let _EngineFormat = " + JSON.stringify(KTX2Loader.EngineFormat),
          "let _TranscoderFormat = " + JSON.stringify(KTX2Loader.TranscoderFormat),
          "let _BasisFormat = " + JSON.stringify(KTX2Loader.BasisFormat),
          "/* basis_transcoder.js */",
          jsContent2,
          "/* worker */",
          fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))
        ].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([body]));
        this.transcoderBinary = binaryContent2;
        this.workerPool.setWorkerCreator(() => {
          const worker = new Worker(this.workerSourceURL);
          const transcoderBinary = this.transcoderBinary.slice(0);
          worker.postMessage({ type: "init", config: this.workerConfig, transcoderBinary }, [transcoderBinary]);
          return worker;
        });
      });
      if (_activeLoaders > 0) {
        console.warn(
          "THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."
        );
      }
      _activeLoaders++;
    }
    return this.transcoderPending;
  }
  load(url, onLoad, onProgress, onError) {
    if (this.workerConfig === null) {
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    }
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (buffer) => {
      if (_taskCache2.has(buffer)) {
        const cachedTask = _taskCache2.get(buffer);
        return cachedTask.promise.then(onLoad).catch(onError);
      }
      this._createTexture(buffer).then((texture) => onLoad ? onLoad(texture) : null).catch(onError);
    }, onProgress, onError);
  }
  _createTextureFrom(transcodeResult, container) {
    const { faces, width, height, format, type, error, dfdTransferFn, dfdFlags } = transcodeResult;
    if (type === "error")
      return Promise.reject(error);
    let texture;
    if (container.faceCount === 6) {
      texture = new CompressedTexture();
      texture.image = faces;
      texture.format = format;
      texture.type = UnsignedByteType;
    } else {
      const mipmaps = faces[0].mipmaps;
      texture = container.layerCount > 1 ? new CompressedArrayTexture(mipmaps, width, height, container.layerCount, format, UnsignedByteType) : new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);
    }
    texture.minFilter = faces[0].mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;
    texture.magFilter = LinearFilter;
    texture.generateMipmaps = false;
    texture.needsUpdate = true;
    texture.colorSpace = dfdTransferFn === x ? SRGBColorSpace : NoColorSpace;
    texture.premultiplyAlpha = !!(dfdFlags & p);
    return texture;
  }
  /**
   * @param {ArrayBuffer} buffer
   * @param {object?} config
   * @return {Promise<CompressedTexture|CompressedArrayTexture|DataTexture|Data3DTexture>}
   */
  async _createTexture(buffer, config = {}) {
    const container = Pi(new Uint8Array(buffer));
    if (container.vkFormat !== nt) {
      const mipmaps = [];
      const pendings = [];
      for (let levelIndex = 0; levelIndex < container.levels.length; levelIndex++) {
        pendings.push(createDataTexture(container, levelIndex).then(function(dataTexture) {
          mipmaps[levelIndex] = dataTexture;
        }));
      }
      await Promise.all(pendings);
      const texture = mipmaps[0];
      texture.mipmaps = mipmaps.map((dt2) => {
        return {
          data: dt2.source.data,
          width: dt2.source.data.width,
          height: dt2.source.data.height,
          depth: dt2.source.data.depth
        };
      });
      return texture;
    }
    const taskConfig = config;
    const texturePending = this.init().then(() => {
      return this.workerPool.postMessage({ type: "transcode", buffer, taskConfig }, [buffer]);
    }).then((e) => this._createTextureFrom(e.data, container));
    _taskCache2.set(buffer, { promise: texturePending });
    return texturePending;
  }
  dispose() {
    this.workerPool.dispose();
    if (this.workerSourceURL)
      URL.revokeObjectURL(this.workerSourceURL);
    _activeLoaders--;
    return this;
  }
};
KTX2Loader.BasisFormat = {
  ETC1S: 0,
  UASTC_4x4: 1
};
KTX2Loader.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16
};
KTX2Loader.EngineFormat = {
  RGBAFormat,
  RGBA_ASTC_4x4_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format
};
KTX2Loader.BasisWorker = function() {
  let config;
  let transcoderPending;
  let BasisModule;
  const EngineFormat = _EngineFormat;
  const TranscoderFormat = _TranscoderFormat;
  const BasisFormat = _BasisFormat;
  self.addEventListener("message", function(e) {
    const message = e.data;
    switch (message.type) {
      case "init":
        config = message.config;
        init2(message.transcoderBinary);
        break;
      case "transcode":
        transcoderPending.then(() => {
          try {
            const { faces, buffers, width, height, hasAlpha, format, dfdTransferFn, dfdFlags } = transcode(message.buffer);
            self.postMessage({ type: "transcode", id: message.id, faces, width, height, hasAlpha, format, dfdTransferFn, dfdFlags }, buffers);
          } catch (error) {
            console.error(error);
            self.postMessage({ type: "error", id: message.id, error: error.message });
          }
        });
        break;
    }
  });
  function init2(wasmBinary) {
    transcoderPending = new Promise((resolve) => {
      BasisModule = { wasmBinary, onRuntimeInitialized: resolve };
      BASIS(BasisModule);
    }).then(() => {
      BasisModule.initializeBasis();
      if (BasisModule.KTX2File === void 0) {
        console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
      }
    });
  }
  function transcode(buffer) {
    const ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));
    function cleanup() {
      ktx2File.close();
      ktx2File.delete();
    }
    if (!ktx2File.isValid()) {
      cleanup();
      throw new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
    }
    const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;
    const width = ktx2File.getWidth();
    const height = ktx2File.getHeight();
    const layerCount = ktx2File.getLayers() || 1;
    const levelCount = ktx2File.getLevels();
    const faceCount = ktx2File.getFaces();
    const hasAlpha = ktx2File.getHasAlpha();
    const dfdTransferFn = ktx2File.getDFDTransferFunc();
    const dfdFlags = ktx2File.getDFDFlags();
    const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha);
    if (!width || !height || !levelCount) {
      cleanup();
      throw new Error("THREE.KTX2Loader:	Invalid texture");
    }
    if (!ktx2File.startTranscoding()) {
      cleanup();
      throw new Error("THREE.KTX2Loader: .startTranscoding failed");
    }
    const faces = [];
    const buffers = [];
    for (let face = 0; face < faceCount; face++) {
      const mipmaps = [];
      for (let mip = 0; mip < levelCount; mip++) {
        const layerMips = [];
        let mipWidth, mipHeight;
        for (let layer = 0; layer < layerCount; layer++) {
          const levelInfo = ktx2File.getImageLevelInfo(mip, layer, face);
          if (face === 0 && mip === 0 && layer === 0 && (levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0)) {
            console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.");
          }
          if (levelCount > 1) {
            mipWidth = levelInfo.origWidth;
            mipHeight = levelInfo.origHeight;
          } else {
            mipWidth = levelInfo.width;
            mipHeight = levelInfo.height;
          }
          const dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, transcoderFormat));
          const status = ktx2File.transcodeImage(dst, mip, layer, face, transcoderFormat, 0, -1, -1);
          if (!status) {
            cleanup();
            throw new Error("THREE.KTX2Loader: .transcodeImage failed.");
          }
          layerMips.push(dst);
        }
        const mipData = concat(layerMips);
        mipmaps.push({ data: mipData, width: mipWidth, height: mipHeight });
        buffers.push(mipData.buffer);
      }
      faces.push({ mipmaps, width, height, format: engineFormat });
    }
    cleanup();
    return { faces, buffers, width, height, hasAlpha, format: engineFormat, dfdTransferFn, dfdFlags };
  }
  const FORMAT_OPTIONS = [
    {
      if: "astcSupported",
      basisFormat: [BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],
      engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],
      priorityETC1S: Infinity,
      priorityUASTC: 1,
      needsPowerOfTwo: false
    },
    {
      if: "bptcSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],
      engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],
      priorityETC1S: 3,
      priorityUASTC: 2,
      needsPowerOfTwo: false
    },
    {
      if: "dxtSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],
      engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],
      priorityETC1S: 4,
      priorityUASTC: 5,
      needsPowerOfTwo: false
    },
    {
      if: "etc2Supported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],
      engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],
      priorityETC1S: 1,
      priorityUASTC: 3,
      needsPowerOfTwo: false
    },
    {
      if: "etc1Supported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.ETC1],
      engineFormat: [EngineFormat.RGB_ETC1_Format],
      priorityETC1S: 2,
      priorityUASTC: 4,
      needsPowerOfTwo: false
    },
    {
      if: "pvrtcSupported",
      basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
      transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],
      engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],
      priorityETC1S: 5,
      priorityUASTC: 6,
      needsPowerOfTwo: true
    }
  ];
  const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function(a, b) {
    return a.priorityETC1S - b.priorityETC1S;
  });
  const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function(a, b) {
    return a.priorityUASTC - b.priorityUASTC;
  });
  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {
    let transcoderFormat;
    let engineFormat;
    const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;
    for (let i = 0; i < options.length; i++) {
      const opt = options[i];
      if (!config[opt.if])
        continue;
      if (!opt.basisFormat.includes(basisFormat))
        continue;
      if (hasAlpha && opt.transcoderFormat.length < 2)
        continue;
      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height)))
        continue;
      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];
      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];
      return { transcoderFormat, engineFormat };
    }
    console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.");
    transcoderFormat = TranscoderFormat.RGBA32;
    engineFormat = EngineFormat.RGBAFormat;
    return { transcoderFormat, engineFormat };
  }
  function isPowerOfTwo(value) {
    if (value <= 2)
      return true;
    return (value & value - 1) === 0 && value !== 0;
  }
  function concat(arrays) {
    if (arrays.length === 1)
      return arrays[0];
    let totalByteLength = 0;
    for (let i = 0; i < arrays.length; i++) {
      const array = arrays[i];
      totalByteLength += array.byteLength;
    }
    const result = new Uint8Array(totalByteLength);
    let byteOffset = 0;
    for (let i = 0; i < arrays.length; i++) {
      const array = arrays[i];
      result.set(array, byteOffset);
      byteOffset += array.byteLength;
    }
    return result;
  }
};
var FORMAT_MAP = {
  [Ae]: RGBAFormat,
  [pe]: RGBAFormat,
  [Ot]: RGBAFormat,
  [Ft]: RGBAFormat,
  [de]: RGFormat,
  [se]: RGFormat,
  [yt]: RGFormat,
  [dt]: RGFormat,
  [xe]: RedFormat,
  [$t]: RedFormat,
  [gt]: RedFormat,
  [ct]: RedFormat
};
var TYPE_MAP = {
  [Ae]: FloatType,
  [pe]: HalfFloatType,
  [Ot]: UnsignedByteType,
  [Ft]: UnsignedByteType,
  [de]: FloatType,
  [se]: HalfFloatType,
  [yt]: UnsignedByteType,
  [dt]: UnsignedByteType,
  [xe]: FloatType,
  [$t]: HalfFloatType,
  [gt]: UnsignedByteType,
  [ct]: UnsignedByteType
};
var COLOR_SPACE_MAP = {
  [Ft]: SRGBColorSpace,
  [dt]: SRGBColorSpace,
  [gt]: SRGBColorSpace
};
async function createDataTexture(container, levelIndex = 0) {
  const { vkFormat } = container;
  const pixelWidth = Math.max(1, container.pixelWidth >> levelIndex);
  const pixelHeight = Math.max(1, container.pixelHeight >> levelIndex);
  const pixelDepth = Math.max(1, container.pixelDepth >> levelIndex);
  if (FORMAT_MAP[vkFormat] === void 0) {
    throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
  }
  const level = container.levels[levelIndex];
  let levelData;
  let view;
  if (container.supercompressionScheme === t) {
    levelData = level.levelData;
  } else if (container.supercompressionScheme === n) {
    if (!_zstd) {
      _zstd = new Promise(async (resolve) => {
        const zstd = new Q();
        await zstd.init();
        resolve(zstd);
      });
    }
    levelData = (await _zstd).decode(level.levelData, level.uncompressedByteLength);
  } else {
    throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
  }
  if (TYPE_MAP[vkFormat] === FloatType) {
    view = new Float32Array(
      levelData.buffer,
      levelData.byteOffset,
      levelData.byteLength / Float32Array.BYTES_PER_ELEMENT
    );
  } else if (TYPE_MAP[vkFormat] === HalfFloatType) {
    view = new Uint16Array(
      levelData.buffer,
      levelData.byteOffset,
      levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT
    );
  } else {
    view = levelData;
  }
  const texture = pixelDepth === 0 ? new DataTexture(view, pixelWidth, pixelHeight) : new Data3DTexture(view, pixelWidth, pixelHeight, pixelDepth);
  texture.type = TYPE_MAP[vkFormat];
  texture.format = FORMAT_MAP[vkFormat];
  texture.colorSpace = COLOR_SPACE_MAP[vkFormat] || NoColorSpace;
  texture.needsUpdate = true;
  return Promise.resolve(texture);
}

// node_modules/@threlte/extras/dist/lib/buildSceneGraph.js
var buildSceneGraph = (object) => {
  const data = { nodes: {}, materials: {} };
  if (object) {
    object.traverse((obj) => {
      if (obj.name)
        data.nodes[obj.name] = obj;
      if (obj.material && !data.materials[obj.material.name])
        data.materials[obj.material.name] = obj.material;
    });
  }
  return data;
};

// node_modules/@threlte/extras/dist/hooks/useGltf.js
function useGltf(urlOrOptions, options) {
  const { renderer } = useThrelte();
  const opts = typeof urlOrOptions === "string" ? options : urlOrOptions;
  const loader = useLoader(GLTFLoader, {
    extend(loader2) {
      if (opts == null ? void 0 : opts.useDraco) {
        const dracoDecoderPath = typeof opts.useDraco === "string" ? opts.useDraco : "https://www.gstatic.com/draco/versioned/decoders/1.4.3/";
        const dracoLoader = new DRACOLoader().setDecoderPath(dracoDecoderPath);
        loader2.setDRACOLoader(dracoLoader);
      }
      if (opts == null ? void 0 : opts.useMeshopt) {
        loader2.setMeshoptDecoder(MeshoptDecoder);
      }
      if ((opts == null ? void 0 : opts.ktxTranscoderPath) && renderer) {
        const ktx2Loader = new KTX2Loader();
        ktx2Loader.setTranscoderPath(opts == null ? void 0 : opts.ktxTranscoderPath);
        ktx2Loader.detectSupport(renderer);
        loader2.setKTX2Loader(ktx2Loader);
      }
    }
  });
  const load = (url2) => {
    return loader.load(url2, {
      transform(result) {
        return {
          ...result,
          ...buildSceneGraph(result.scene)
        };
      }
    });
  };
  const url = typeof urlOrOptions === "string" ? urlOrOptions : void 0;
  if (url) {
    return load(url);
  } else {
    return {
      load
    };
  }
}

// node_modules/@threlte/extras/dist/hooks/useGltfAnimations.js
var isRoot = (value) => !!(value == null ? void 0 : value.isObject3D);
var isGltfStore = (value) => !!(value == null ? void 0 : value.subscribe) && typeof value.subscribe === "function";
function useGltfAnimations(rootOrGltf, maybeRoot) {
  const gltf = isGltfStore(rootOrGltf) ? rootOrGltf : writable(void 0);
  const root = currentWritable(isRoot(rootOrGltf) ? rootOrGltf : isRoot(maybeRoot) ? maybeRoot : void 0);
  const actualRoot = derived([root, gltf], ([root2, gltf2]) => {
    return root2 ?? (gltf2 == null ? void 0 : gltf2.scene);
  });
  const actions = currentWritable({});
  const mixer = new AnimationMixer(void 0);
  watch([gltf, actualRoot], async ([gltf2, actualRoot2]) => {
    if (!gltf2 || !gltf2.animations.length || !actualRoot2)
      return;
    await tick();
    const newActions = gltf2.animations.reduce((acc, clip) => {
      const action = mixer.clipAction(clip, actualRoot2);
      return {
        ...acc,
        [clip.name]: action
      };
    }, {});
    actions.set(newActions);
    return () => {
      Object.values(newActions).forEach((a) => {
        const action = a;
        action.stop();
        mixer.uncacheClip(action.getClip());
      });
    };
  });
  const { start, stop } = useFrame((_, delta) => {
    mixer.update(delta);
  }, { autostart: false });
  watch(actions, (actions2) => {
    if (Object.keys(actions2).length)
      start();
    else
      stop();
  });
  return {
    gltf,
    root,
    mixer,
    actions
  };
}

// node_modules/@threlte/extras/dist/hooks/useProgress.js
var previousTotalLoaded = 0;
var useProgress = () => {
  const finishedOnce = writable(false);
  const activeStore = writable(false);
  const itemStore = writable(void 0);
  const loadedStore = writable(0);
  const totalStore = writable(0);
  const errorsStore = writable([]);
  const progressStore = writable(0);
  DefaultLoadingManager.onStart = (item, loaded, total) => {
    activeStore.set(true);
    itemStore.set(item);
    loadedStore.set(loaded);
    totalStore.set(total);
    const progress = (loaded - previousTotalLoaded) / (total - previousTotalLoaded);
    progressStore.set(progress);
    if (progress === 1)
      finishedOnce.set(true);
  };
  DefaultLoadingManager.onLoad = () => {
    activeStore.set(false);
  };
  DefaultLoadingManager.onError = (item) => {
    errorsStore.update((errors) => {
      return [...errors, item];
    });
  };
  DefaultLoadingManager.onProgress = (item, loaded, total) => {
    if (loaded === total) {
      previousTotalLoaded = total;
    }
    activeStore.set(true);
    itemStore.set(item);
    loadedStore.set(loaded);
    totalStore.set(total);
    const progress = (loaded - previousTotalLoaded) / (total - previousTotalLoaded) || 1;
    progressStore.set(progress);
    if (progress === 1)
      finishedOnce.set(true);
  };
  return {
    active: { subscribe: activeStore.subscribe },
    item: { subscribe: itemStore.subscribe },
    loaded: { subscribe: loadedStore.subscribe },
    total: { subscribe: totalStore.subscribe },
    errors: { subscribe: errorsStore.subscribe },
    progress: { subscribe: progressStore.subscribe },
    finishedOnce: { subscribe: finishedOnce.subscribe }
  };
};

// node_modules/@threlte/extras/dist/hooks/useTexture.js
var useTexture = (input, options) => {
  const loader = useLoader(TextureLoader, options);
  return loader.load(input);
};

// node_modules/@threlte/extras/dist/components/Edges/Edges.svelte
var { Error: Error_1 } = globals;
var get_default_slot_changes = (dirty) => ({ ref: dirty & /*ref*/
4096 });
var get_default_slot_context = (ctx) => ({ ref: (
  /*ref*/
  ctx[12]
) });
function create_default_slot(ctx) {
  let t_edgesgeometry;
  let t0;
  let t_linebasicmaterial;
  let t1;
  let current;
  t_edgesgeometry = new T.EdgesGeometry({
    props: {
      args: [
        /*geometry*/
        ctx[4],
        /*thresholdAngle*/
        ctx[0]
      ]
    },
    $$inline: true
  });
  t_linebasicmaterial = new T.LineBasicMaterial({
    props: { color: (
      /*color*/
      ctx[1]
    ) },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      create_component(t_edgesgeometry.$$.fragment);
      t0 = space();
      create_component(t_linebasicmaterial.$$.fragment);
      t1 = space();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      claim_component(t_edgesgeometry.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(t_linebasicmaterial.$$.fragment, nodes);
      t1 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_edgesgeometry, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(t_linebasicmaterial, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_edgesgeometry_changes = {};
      if (dirty & /*thresholdAngle*/
      1)
        t_edgesgeometry_changes.args = [
          /*geometry*/
          ctx2[4],
          /*thresholdAngle*/
          ctx2[0]
        ];
      t_edgesgeometry.$set(t_edgesgeometry_changes);
      const t_linebasicmaterial_changes = {};
      if (dirty & /*color*/
      2)
        t_linebasicmaterial_changes.color = /*color*/
        ctx2[1];
      t_linebasicmaterial.$set(t_linebasicmaterial_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        4608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t_edgesgeometry.$$.fragment, local);
      transition_in(t_linebasicmaterial.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_edgesgeometry.$$.fragment, local);
      transition_out(t_linebasicmaterial.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_edgesgeometry, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(t_linebasicmaterial, detaching);
      if (detaching)
        detach_dev(t1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(12:0) <T.LineSegments let:ref {...$$restProps} bind:this={$component}>",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let t_linesegments;
  let current;
  const t_linesegments_spread_levels = [
    /*$$restProps*/
    ctx[6]
  ];
  let t_linesegments_props = {
    $$slots: {
      default: [
        create_default_slot,
        ({ ref }) => ({ 12: ref }),
        ({ ref }) => ref ? 4096 : 0
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_linesegments_spread_levels.length; i += 1) {
    t_linesegments_props = assign(t_linesegments_props, t_linesegments_spread_levels[i]);
  }
  t_linesegments = new T.LineSegments({
    props: t_linesegments_props,
    $$inline: true
  });
  ctx[8](t_linesegments);
  const block = {
    c: function create() {
      create_component(t_linesegments.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_linesegments.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_linesegments, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_linesegments_changes = dirty & /*$$restProps*/
      64 ? get_spread_update(t_linesegments_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[6]
      )]) : {};
      if (dirty & /*$$scope, ref, color, thresholdAngle*/
      4611) {
        t_linesegments_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t_linesegments.$set(t_linesegments_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t_linesegments.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_linesegments.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[8](null);
      destroy_component(t_linesegments, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["thresholdAngle", "color"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $parent;
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Edges", slots, ["default"]);
  let { thresholdAngle = void 0 } = $$props;
  let { color = void 0 } = $$props;
  const parent = useParent();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(10, $parent = value));
  if (!$parent || $parent.type !== "Mesh")
    throw new Error("Edges: component must be a child of a Mesh");
  const parentMesh = $parent;
  const geometry = "clone" in parentMesh.geometry ? parentMesh.geometry.clone() : parentMesh.geometry;
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(2, $component = value));
  function t_linesegments_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("thresholdAngle" in $$new_props)
      $$invalidate(0, thresholdAngle = $$new_props.thresholdAngle);
    if ("color" in $$new_props)
      $$invalidate(1, color = $$new_props.color);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    T,
    useParent,
    forwardEventHandlers,
    thresholdAngle,
    color,
    parent,
    parentMesh,
    geometry,
    component,
    $parent,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("thresholdAngle" in $$props)
      $$invalidate(0, thresholdAngle = $$new_props.thresholdAngle);
    if ("color" in $$props)
      $$invalidate(1, color = $$new_props.color);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    thresholdAngle,
    color,
    $component,
    parent,
    geometry,
    component,
    $$restProps,
    slots,
    t_linesegments_binding,
    $$scope
  ];
}
var Edges = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { thresholdAngle: 0, color: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Edges",
      options,
      id: create_fragment.name
    });
  }
  get thresholdAngle() {
    throw new Error_1("<Edges>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set thresholdAngle(value) {
    throw new Error_1("<Edges>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error_1("<Edges>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error_1("<Edges>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Edges_default = Edges;

// node_modules/@threlte/extras/dist/hooks/useHasEventListeners.js
var useHasEventListeners = () => {
  const component = get_current_component();
  const hasEventListeners = (type) => {
    const callbacks = component.$$.callbacks;
    return type in callbacks && callbacks[type].length > 0;
  };
  return {
    hasEventListeners
  };
};

// node_modules/@threlte/extras/dist/components/HTML/utils.js
var v1 = new Vector3();
var v2 = new Vector3();
var v3 = new Vector3();
var defaultCalculatePosition = (obj, camera, size) => {
  const objectPos = v1.setFromMatrixPosition(obj.matrixWorld);
  objectPos.project(camera);
  const widthHalf = size.width / 2;
  const heightHalf = size.height / 2;
  return [objectPos.x * widthHalf + widthHalf, -(objectPos.y * heightHalf) + heightHalf];
};
var isObjectBehindCamera = (el, camera) => {
  const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
  const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
  const deltaCamObj = objectPos.sub(cameraPos);
  const camDir = camera.getWorldDirection(v3);
  return deltaCamObj.angleTo(camDir) > Math.PI / 2;
};
var isObjectVisible = (el, camera, raycaster, occlude) => {
  const elPos = v1.setFromMatrixPosition(el.matrixWorld);
  const screenPos = elPos.clone();
  screenPos.project(camera);
  raycaster.setFromCamera(screenPos, camera);
  const intersects = raycaster.intersectObjects(occlude, true);
  if (intersects.length) {
    const intersectionDistance = intersects[0].distance;
    const pointDistance = elPos.distanceTo(raycaster.ray.origin);
    return pointDistance < intersectionDistance;
  }
  return true;
};
var objectScale = (el, camera) => {
  if (camera instanceof OrthographicCamera) {
    return camera.zoom;
  } else if (camera instanceof PerspectiveCamera) {
    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
    const vFOV = camera.fov * Math.PI / 180;
    const dist = objectPos.distanceTo(cameraPos);
    const scaleFOV = 2 * Math.tan(vFOV / 2) * dist;
    return 1 / scaleFOV;
  } else {
    return 1;
  }
};
var objectZIndex = (el, camera, zIndexRange) => {
  if (camera instanceof PerspectiveCamera || camera instanceof OrthographicCamera) {
    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
    const dist = objectPos.distanceTo(cameraPos);
    const A2 = (zIndexRange[1] - zIndexRange[0]) / (camera.far - camera.near);
    const B2 = zIndexRange[1] - A2 * camera.far;
    return Math.round(A2 * dist + B2);
  }
  return void 0;
};
var epsilon = (value) => Math.abs(value) < 1e-10 ? 0 : value;
var getCSSMatrix = (matrix, multipliers, prepend = "") => {
  let matrix3d = "matrix3d(";
  for (let i = 0; i !== 16; i++) {
    matrix3d += epsilon(multipliers[i] * matrix.elements[i]) + (i !== 15 ? "," : ")");
  }
  return prepend + matrix3d;
};
var getCameraCSSMatrix = ((multipliers) => {
  return (matrix) => getCSSMatrix(matrix, multipliers);
})([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]);
var getObjectCSSMatrix = ((scaleMultipliers) => {
  return (matrix, factor) => getCSSMatrix(matrix, scaleMultipliers(factor), "translate(-50%,-50%)");
})((f) => [
  1 / f,
  1 / f,
  1 / f,
  1,
  -1 / f,
  -1 / f,
  -1 / f,
  -1,
  1 / f,
  1 / f,
  1 / f,
  1,
  1,
  1,
  1,
  1
]);
var styleDeclarationKeyToCssString = (s) => {
  return s.split(/(?=[A-Z])/).join("-").toLowerCase();
};
var compileStyles = (styles) => {
  return Object.entries(styles).filter(([_, value]) => !!value).map(([key, value]) => `${styleDeclarationKeyToCssString(key)}: ${value}`).join("; ");
};
var updateStyles = (store, styles) => {
  store.update((values) => {
    return {
      ...values,
      ...styles
    };
  });
};

// node_modules/@threlte/extras/dist/components/HTML/HTML.svelte
var { Error: Error_12 } = globals;
var file = "node_modules\\@threlte\\extras\\dist\\components\\HTML\\HTML.svelte";
var get_threlte_slot_changes = (dirty) => ({ ref: dirty[0] & /*ref*/
4 });
var get_threlte_slot_context = (ctx) => ({ ref: (
  /*ref*/
  ctx[2]
) });
function create_default_slot2(ctx) {
  let current;
  const threlte_slot_template = (
    /*#slots*/
    ctx[40].threlte
  );
  const threlte_slot = create_slot(
    threlte_slot_template,
    ctx,
    /*$$scope*/
    ctx[46],
    get_threlte_slot_context
  );
  const block = {
    c: function create() {
      if (threlte_slot)
        threlte_slot.c();
    },
    l: function claim(nodes) {
      if (threlte_slot)
        threlte_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (threlte_slot) {
        threlte_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (threlte_slot) {
        if (threlte_slot.p && (!current || dirty[0] & /*ref*/
        4 | dirty[1] & /*$$scope*/
        32768)) {
          update_slot_base(
            threlte_slot,
            threlte_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[46],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[46]
            ) : get_slot_changes(
              threlte_slot_template,
              /*$$scope*/
              ctx2[46],
              dirty,
              get_threlte_slot_changes
            ),
            get_threlte_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(threlte_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(threlte_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (threlte_slot)
        threlte_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(243:0) <T is={ref} {...$$restProps} let:ref bind:this={$component}>",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let previous_tag = (
    /*as*/
    ctx[1]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*as*/
    ctx[1]
  );
  validate_void_dynamic_element(
    /*as*/
    ctx[1]
  );
  let svelte_element = (
    /*as*/
    ctx[1] && create_dynamic_element_1(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*as*/
        ctx2[1]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element_1(ctx2);
          previous_tag = /*as*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*as*/
          ctx2[1]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*as*/
            ctx2[1]
          );
          validate_void_dynamic_element(
            /*as*/
            ctx2[1]
          );
          svelte_element = create_dynamic_element_1(ctx2);
          previous_tag = /*as*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*as*/
        ctx2[1];
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(262:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let previous_tag = (
    /*as*/
    ctx[1]
  );
  let svelte_element_anchor;
  let current;
  validate_dynamic_element(
    /*as*/
    ctx[1]
  );
  validate_void_dynamic_element(
    /*as*/
    ctx[1]
  );
  let svelte_element = (
    /*as*/
    ctx[1] && create_dynamic_element(ctx)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*as*/
        ctx2[1]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*as*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*as*/
          ctx2[1]
        )) {
          svelte_element.d(1);
          validate_dynamic_element(
            /*as*/
            ctx2[1]
          );
          validate_void_dynamic_element(
            /*as*/
            ctx2[1]
          );
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*as*/
          ctx2[1];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*as*/
        ctx2[1];
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element_anchor);
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(247:0) {#if transform}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[40].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[46],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[46],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[46]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[46],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(271:6) {#if showEl}",
    ctx
  });
  return block;
}
function create_dynamic_element_1(ctx) {
  let svelte_element;
  let div;
  let div_style_value;
  let svelte_element_style_value;
  let portalAction_action;
  let buildDefaultNonTransformStyles_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*showEl*/
    ctx[6] && create_if_block_2(ctx)
  );
  let svelte_element_levels = [
    {
      style: svelte_element_style_value = compileStyles(
        /*$noTransformElStyles*/
        ctx[11]
      )
    }
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*as*/
        ctx[1]
      );
      div = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*as*/
        (ctx[1] || "null").toUpperCase(),
        { style: true }
      );
      var svelte_element_nodes = children(svelte_element);
      div = claim_element(svelte_element_nodes, "DIV", { style: true });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "style", div_style_value = compileStyles(
        /*$noTransformDivStyles*/
        ctx[12]
      ));
      add_location(div, file, 269, 4, 9486);
      set_dynamic_element_data(
        /*as*/
        ctx[1]
      )(svelte_element, svelte_element_data);
      add_location(svelte_element, file, 262, 2, 9321);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      append_hydration_dev(svelte_element, div);
      if (if_block)
        if_block.m(div, null);
      ctx[45](svelte_element);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(portalAction_action = /*portalAction*/
          ctx[23].call(null, svelte_element)),
          action_destroyer(buildDefaultNonTransformStyles_action = /*buildDefaultNonTransformStyles*/
          ctx[22].call(null, svelte_element))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*showEl*/
        ctx2[6]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*showEl*/
          64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*$noTransformDivStyles*/
      4096 && div_style_value !== (div_style_value = compileStyles(
        /*$noTransformDivStyles*/
        ctx2[12]
      ))) {
        attr_dev(div, "style", div_style_value);
      }
      set_dynamic_element_data(
        /*as*/
        ctx2[1]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty[0] & /*$noTransformElStyles*/
        2048 && svelte_element_style_value !== (svelte_element_style_value = compileStyles(
          /*$noTransformElStyles*/
          ctx2[11]
        ))) && { style: svelte_element_style_value }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if (if_block)
        if_block.d();
      ctx[45](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element_1.name,
    type: "child_dynamic_element",
    source: "(263:2) <svelte:element     this={as}     bind:this={el}     use:portalAction     use:buildDefaultNonTransformStyles     style={compileStyles($noTransformElStyles)}   >",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[40].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[46],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[46],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[46]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[46],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(256:8) {#if showEl}",
    ctx
  });
  return block;
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let div1;
  let div0;
  let div0_style_value;
  let div1_style_value;
  let svelte_element_style_value;
  let portalAction_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*showEl*/
    ctx[6] && create_if_block_1(ctx)
  );
  let svelte_element_levels = [
    {
      style: svelte_element_style_value = compileStyles(
        /*$transformElStyles*/
        ctx[8]
      )
    }
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*as*/
        ctx[1]
      );
      div1 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*as*/
        (ctx[1] || "null").toUpperCase(),
        { style: true }
      );
      var svelte_element_nodes = children(svelte_element);
      div1 = claim_element(svelte_element_nodes, "DIV", { style: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { style: true });
      var div0_nodes = children(div0);
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "style", div0_style_value = compileStyles(
        /*$transformInnerRefStyles*/
        ctx[10]
      ));
      add_location(div0, file, 254, 6, 9129);
      attr_dev(div1, "style", div1_style_value = compileStyles(
        /*$transformOuterRefStyles*/
        ctx[9]
      ));
      add_location(div1, file, 253, 4, 9039);
      set_dynamic_element_data(
        /*as*/
        ctx[1]
      )(svelte_element, svelte_element_data);
      add_location(svelte_element, file, 247, 2, 8915);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      append_hydration_dev(svelte_element, div1);
      append_hydration_dev(div1, div0);
      if (if_block)
        if_block.m(div0, null);
      ctx[42](div0);
      ctx[43](div1);
      ctx[44](svelte_element);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(portalAction_action = /*portalAction*/
        ctx[23].call(null, svelte_element));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*showEl*/
        ctx2[6]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*showEl*/
          64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*$transformInnerRefStyles*/
      1024 && div0_style_value !== (div0_style_value = compileStyles(
        /*$transformInnerRefStyles*/
        ctx2[10]
      ))) {
        attr_dev(div0, "style", div0_style_value);
      }
      if (!current || dirty[0] & /*$transformOuterRefStyles*/
      512 && div1_style_value !== (div1_style_value = compileStyles(
        /*$transformOuterRefStyles*/
        ctx2[9]
      ))) {
        attr_dev(div1, "style", div1_style_value);
      }
      set_dynamic_element_data(
        /*as*/
        ctx2[1]
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty[0] & /*$transformElStyles*/
        256 && svelte_element_style_value !== (svelte_element_style_value = compileStyles(
          /*$transformElStyles*/
          ctx2[8]
        ))) && { style: svelte_element_style_value }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svelte_element);
      if (if_block)
        if_block.d();
      ctx[42](null);
      ctx[43](null);
      ctx[44](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: "(248:2) <svelte:element     this={as}     use:portalAction     bind:this={el}     style={compileStyles($transformElStyles)}   >",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let t0;
  let t1;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const t0_spread_levels = [
    { is: (
      /*ref*/
      ctx[2]
    ) },
    /*$$restProps*/
    ctx[25]
  ];
  let t0_props = {
    $$slots: {
      default: [create_default_slot2, ({ ref }) => ({ 2: ref }), ({ ref }) => [ref ? 4 : 0]]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t0_spread_levels.length; i += 1) {
    t0_props = assign(t0_props, t0_spread_levels[i]);
  }
  t0 = new T({ props: t0_props, $$inline: true });
  ctx[41](t0);
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*transform*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      create_component(t0.$$.fragment);
      t1 = space();
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(t0.$$.fragment, nodes);
      t1 = claim_space(nodes);
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(t0, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t0_changes = dirty[0] & /*ref, $$restProps*/
      33554436 ? get_spread_update(t0_spread_levels, [
        dirty[0] & /*ref*/
        4 && { is: (
          /*ref*/
          ctx2[2]
        ) },
        dirty[0] & /*$$restProps*/
        33554432 && get_spread_object(
          /*$$restProps*/
          ctx2[25]
        )
      ]) : {};
      if (dirty[0] & /*ref*/
      4 | dirty[1] & /*$$scope*/
      32768) {
        t0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t0.$set(t0_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t0.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(t0.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[41](null);
      destroy_component(t0, detaching);
      if (detaching)
        detach_dev(t1);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "transform",
    "calculatePosition",
    "eps",
    "occlude",
    "zIndexRange",
    "sprite",
    "pointerEvents",
    "center",
    "fullscreen",
    "distanceFactor",
    "as",
    "portal",
    "ref",
    "visible"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $size;
  let $camera;
  let $heightHalf;
  let $widthHalf;
  let $component;
  let $transformElStyles;
  let $transformOuterRefStyles;
  let $transformInnerRefStyles;
  let $noTransformElStyles;
  let $noTransformDivStyles;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HTML", slots, ["threlte", "default"]);
  let { transform = false } = $$props;
  let { calculatePosition = defaultCalculatePosition } = $$props;
  let { eps = 1e-3 } = $$props;
  let { occlude = false } = $$props;
  let { zIndexRange = [16777271, 0] } = $$props;
  let { sprite = false } = $$props;
  let { pointerEvents = "auto" } = $$props;
  let { center = false } = $$props;
  let { fullscreen = false } = $$props;
  let { distanceFactor = void 0 } = $$props;
  let { as = "div" } = $$props;
  let { portal = void 0 } = $$props;
  const dispatch = createRawEventDispatcher();
  let { ref = new Group() } = $$props;
  const { renderer, camera, scene, size } = useThrelte();
  validate_store(camera, "camera");
  component_subscribe($$self, camera, (value) => $$invalidate(50, $camera = value));
  validate_store(size, "size");
  component_subscribe($$self, size, (value) => $$invalidate(37, $size = value));
  const getCamera = () => {
    if (!($camera instanceof PerspectiveCamera) && !($camera instanceof OrthographicCamera))
      throw new Error("Only PerspectiveCamera or OrthographicCamera supported for component <HTML>");
    return $camera;
  };
  const raycaster = new Raycaster();
  let oldPosition = [0, 0];
  let oldZoom = 0;
  let { visible = true } = $$props;
  let el = document.createElement(as);
  let transformOuterRef;
  let transformInnerRef;
  const { hasEventListeners } = useHasEventListeners();
  let raytraceTarget = typeof occlude === "boolean" && occlude === true ? [scene] : Array.isArray(occlude) ? occlude : void 0;
  const widthHalf = derived(size, (size2) => size2.width / 2);
  validate_store(widthHalf, "widthHalf");
  component_subscribe($$self, widthHalf, (value) => $$invalidate(39, $widthHalf = value));
  const heightHalf = derived(size, (size2) => size2.height / 2);
  validate_store(heightHalf, "heightHalf");
  component_subscribe($$self, heightHalf, (value) => $$invalidate(38, $heightHalf = value));
  let styles = {
    common: { el: writable({}) },
    transform: {
      el: writable({
        position: "absolute",
        top: "0",
        left: "0",
        pointerEvents: "none",
        overflow: "hidden",
        display: "block",
        width: `${$size.width}px`,
        height: `${$size.height}px`
      }),
      outerRef: writable({
        position: "absolute",
        top: "0",
        left: "0",
        width: `${$size.width}px`,
        height: `${$size.height}px`,
        transformStyle: "preserve-3d",
        pointerEvents: "none"
      }),
      innerRef: writable({ position: "absolute", pointerEvents })
    },
    noTransform: {
      el: writable({}),
      div: writable({
        position: "absolute",
        transform: center ? "translate3d(-50%,-50%,0)" : "none",
        top: fullscreen ? `${-$heightHalf}px` : void 0,
        left: fullscreen ? `${-$widthHalf}px` : void 0,
        width: fullscreen ? `${$size.width}px` : void 0,
        height: fullscreen ? `${$size.height}px` : void 0
      })
    }
  };
  const transformElStyles = derived([styles.transform.el, styles.common.el], ([vA, vB]) => {
    return { ...vA, ...vB };
  });
  validate_store(transformElStyles, "transformElStyles");
  component_subscribe($$self, transformElStyles, (value) => $$invalidate(8, $transformElStyles = value));
  const transformOuterRefStyles = derived(styles.transform.outerRef, (v) => v);
  validate_store(transformOuterRefStyles, "transformOuterRefStyles");
  component_subscribe($$self, transformOuterRefStyles, (value) => $$invalidate(9, $transformOuterRefStyles = value));
  const transformInnerRefStyles = derived(styles.transform.innerRef, (v) => v);
  validate_store(transformInnerRefStyles, "transformInnerRefStyles");
  component_subscribe($$self, transformInnerRefStyles, (value) => $$invalidate(10, $transformInnerRefStyles = value));
  const noTransformElStyles = derived(styles.noTransform.el, (v) => v);
  validate_store(noTransformElStyles, "noTransformElStyles");
  component_subscribe($$self, noTransformElStyles, (value) => $$invalidate(11, $noTransformElStyles = value));
  const noTransformDivStyles = derived(styles.noTransform.div, (v) => v);
  validate_store(noTransformDivStyles, "noTransformDivStyles");
  component_subscribe($$self, noTransformDivStyles, (value) => $$invalidate(12, $noTransformDivStyles = value));
  const getAncestorVisibility = () => {
    let ancestorsAreVisible = true;
    let parent = ref.parent;
    traverse:
      while (parent) {
        if ("visible" in parent && !parent.visible) {
          ancestorsAreVisible = false;
          break traverse;
        }
        parent = parent.parent;
      }
    return ancestorsAreVisible;
  };
  let showEl = getAncestorVisibility();
  useFrame(
    async () => {
      $$invalidate(6, showEl = getAncestorVisibility());
      const camera2 = getCamera();
      camera2.updateMatrixWorld();
      ref.updateWorldMatrix(true, false);
      const vec = transform ? oldPosition : calculatePosition(ref, camera2, $size);
      if (transform || Math.abs(oldZoom - camera2.zoom) > eps || Math.abs(oldPosition[0] - vec[0]) > eps || Math.abs(oldPosition[1] - vec[1]) > eps) {
        const isBehindCamera = isObjectBehindCamera(ref, camera2);
        const previouslyVisible = visible;
        if (raytraceTarget) {
          const isvisible = isObjectVisible(ref, camera2, raycaster, raytraceTarget);
          $$invalidate(26, visible = isvisible && !isBehindCamera);
        } else {
          $$invalidate(26, visible = !isBehindCamera);
        }
        if (previouslyVisible !== visible) {
          if (hasEventListeners("visibilitychange"))
            dispatch("visibilitychange", visible);
          else {
            updateStyles(styles.common.el, { display: visible ? "block" : "none" });
          }
        }
        updateStyles(styles.common.el, {
          zIndex: `${objectZIndex(ref, camera2, zIndexRange)}`
        });
        if (transform) {
          const fov = camera2.projectionMatrix.elements[5] * $heightHalf;
          const { isOrthographicCamera, top, left, bottom, right } = camera2;
          let matrix = ref.matrixWorld;
          if (sprite) {
            matrix = camera2.matrixWorldInverse.clone().transpose().copyPosition(matrix).scale(ref.scale);
            matrix.elements[3] = matrix.elements[7] = matrix.elements[11] = 0;
            matrix.elements[15] = 1;
          }
          updateStyles(styles.transform.el, {
            perspective: isOrthographicCamera ? "" : `${fov}px`
          });
          if (transformOuterRef && transformInnerRef) {
            const cameraTransform = isOrthographicCamera ? `scale(${fov}) translate(${epsilon(-(right + left) / 2)}px,${epsilon((top + bottom) / 2)}px)` : `translateZ(${fov}px)`;
            const cameraMatrix = getCameraCSSMatrix(camera2.matrixWorldInverse);
            updateStyles(styles.transform.outerRef, {
              transform: `${cameraTransform}${cameraMatrix}translate(${$widthHalf}px, ${$heightHalf}px)`
            });
            updateStyles(styles.transform.innerRef, {
              transform: getObjectCSSMatrix(matrix, 1 / ((distanceFactor || 10) / 400))
            });
          }
        } else {
          const scale = distanceFactor === void 0 ? 1 : objectScale(ref, camera2) * distanceFactor;
          updateStyles(styles.noTransform.el, {
            transform: `translate3d(${vec[0]}px, ${vec[1]}px, 0) scale(${scale})`
          });
        }
        oldPosition = vec;
        oldZoom = camera2.zoom;
      }
    },
    {
      debugFrameloopMessage: "HTML: tracking parent"
    }
  );
  const buildDefaultNonTransformStyles = (_) => {
    if (!ref || transform)
      return;
    scene.updateMatrixWorld();
    const vec = calculatePosition(ref, $camera, $size);
    updateStyles(styles.noTransform.el, {
      position: "absolute",
      top: "0",
      left: "0",
      transform: `translate3d(${vec[0]}px, ${vec[1]}px, 0)`,
      transformOrigin: "0 0"
    });
  };
  const portalAction = (el2) => {
    if (!renderer) {
      console.warn("HTML: renderer is undefined. Is this component a child to <Canvas>?");
      return;
    }
    const target = portal ?? renderer.domElement.parentElement;
    if (!target) {
      console.warn("HTML: target is undefined.");
      return;
    }
    target.appendChild(el2);
    return {
      destroy: () => {
        if (!el2.parentNode)
          return;
        el2.parentNode.removeChild(el2);
      }
    };
  };
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(7, $component = value));
  function t0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      transformInnerRef = $$value;
      $$invalidate(5, transformInnerRef);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      transformOuterRef = $$value;
      $$invalidate(4, transformOuterRef);
    });
  }
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  function svelte_element_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(25, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("transform" in $$new_props)
      $$invalidate(0, transform = $$new_props.transform);
    if ("calculatePosition" in $$new_props)
      $$invalidate(27, calculatePosition = $$new_props.calculatePosition);
    if ("eps" in $$new_props)
      $$invalidate(28, eps = $$new_props.eps);
    if ("occlude" in $$new_props)
      $$invalidate(29, occlude = $$new_props.occlude);
    if ("zIndexRange" in $$new_props)
      $$invalidate(30, zIndexRange = $$new_props.zIndexRange);
    if ("sprite" in $$new_props)
      $$invalidate(31, sprite = $$new_props.sprite);
    if ("pointerEvents" in $$new_props)
      $$invalidate(32, pointerEvents = $$new_props.pointerEvents);
    if ("center" in $$new_props)
      $$invalidate(33, center = $$new_props.center);
    if ("fullscreen" in $$new_props)
      $$invalidate(34, fullscreen = $$new_props.fullscreen);
    if ("distanceFactor" in $$new_props)
      $$invalidate(35, distanceFactor = $$new_props.distanceFactor);
    if ("as" in $$new_props)
      $$invalidate(1, as = $$new_props.as);
    if ("portal" in $$new_props)
      $$invalidate(36, portal = $$new_props.portal);
    if ("ref" in $$new_props)
      $$invalidate(2, ref = $$new_props.ref);
    if ("visible" in $$new_props)
      $$invalidate(26, visible = $$new_props.visible);
    if ("$$scope" in $$new_props)
      $$invalidate(46, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createRawEventDispatcher,
    forwardEventHandlers,
    T,
    useFrame,
    useThrelte,
    derived,
    writable,
    Group,
    ThreeeObject3D: Object3D,
    OrthographicCamera,
    PerspectiveCamera,
    Raycaster,
    useHasEventListeners,
    compileStyles,
    defaultCalculatePosition,
    epsilon,
    getCameraCSSMatrix,
    getObjectCSSMatrix,
    isObjectBehindCamera,
    isObjectVisible,
    objectScale,
    objectZIndex,
    updateStyles,
    transform,
    calculatePosition,
    eps,
    occlude,
    zIndexRange,
    sprite,
    pointerEvents,
    center,
    fullscreen,
    distanceFactor,
    as,
    portal,
    dispatch,
    ref,
    renderer,
    camera,
    scene,
    size,
    getCamera,
    raycaster,
    oldPosition,
    oldZoom,
    visible,
    el,
    transformOuterRef,
    transformInnerRef,
    hasEventListeners,
    raytraceTarget,
    widthHalf,
    heightHalf,
    styles,
    transformElStyles,
    transformOuterRefStyles,
    transformInnerRefStyles,
    noTransformElStyles,
    noTransformDivStyles,
    getAncestorVisibility,
    showEl,
    buildDefaultNonTransformStyles,
    portalAction,
    component,
    $size,
    $camera,
    $heightHalf,
    $widthHalf,
    $component,
    $transformElStyles,
    $transformOuterRefStyles,
    $transformInnerRefStyles,
    $noTransformElStyles,
    $noTransformDivStyles
  });
  $$self.$inject_state = ($$new_props) => {
    if ("transform" in $$props)
      $$invalidate(0, transform = $$new_props.transform);
    if ("calculatePosition" in $$props)
      $$invalidate(27, calculatePosition = $$new_props.calculatePosition);
    if ("eps" in $$props)
      $$invalidate(28, eps = $$new_props.eps);
    if ("occlude" in $$props)
      $$invalidate(29, occlude = $$new_props.occlude);
    if ("zIndexRange" in $$props)
      $$invalidate(30, zIndexRange = $$new_props.zIndexRange);
    if ("sprite" in $$props)
      $$invalidate(31, sprite = $$new_props.sprite);
    if ("pointerEvents" in $$props)
      $$invalidate(32, pointerEvents = $$new_props.pointerEvents);
    if ("center" in $$props)
      $$invalidate(33, center = $$new_props.center);
    if ("fullscreen" in $$props)
      $$invalidate(34, fullscreen = $$new_props.fullscreen);
    if ("distanceFactor" in $$props)
      $$invalidate(35, distanceFactor = $$new_props.distanceFactor);
    if ("as" in $$props)
      $$invalidate(1, as = $$new_props.as);
    if ("portal" in $$props)
      $$invalidate(36, portal = $$new_props.portal);
    if ("ref" in $$props)
      $$invalidate(2, ref = $$new_props.ref);
    if ("oldPosition" in $$props)
      oldPosition = $$new_props.oldPosition;
    if ("oldZoom" in $$props)
      oldZoom = $$new_props.oldZoom;
    if ("visible" in $$props)
      $$invalidate(26, visible = $$new_props.visible);
    if ("el" in $$props)
      $$invalidate(3, el = $$new_props.el);
    if ("transformOuterRef" in $$props)
      $$invalidate(4, transformOuterRef = $$new_props.transformOuterRef);
    if ("transformInnerRef" in $$props)
      $$invalidate(5, transformInnerRef = $$new_props.transformInnerRef);
    if ("raytraceTarget" in $$props)
      raytraceTarget = $$new_props.raytraceTarget;
    if ("styles" in $$props)
      $$invalidate(57, styles = $$new_props.styles);
    if ("showEl" in $$props)
      $$invalidate(6, showEl = $$new_props.showEl);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*occlude*/
    536870912) {
      $:
        raytraceTarget = typeof occlude === "boolean" && occlude === true ? [scene] : Array.isArray(occlude) ? occlude : void 0;
    }
    if ($$self.$$.dirty[1] & /*$size*/
    64) {
      $:
        updateStyles(styles.transform.el, {
          width: `${$size.width}px`,
          height: `${$size.height}px`
        });
    }
    if ($$self.$$.dirty[1] & /*$size*/
    64) {
      $:
        updateStyles(styles.transform.outerRef, {
          width: `${$size.width}px`,
          height: `${$size.height}px`
        });
    }
    if ($$self.$$.dirty[1] & /*pointerEvents*/
    2) {
      $:
        updateStyles(styles.transform.innerRef, { pointerEvents });
    }
    if ($$self.$$.dirty[1] & /*center*/
    4) {
      $:
        updateStyles(styles.noTransform.div, {
          transform: center ? "translate3d(-50%, -50%, 0)" : "none"
        });
    }
    if ($$self.$$.dirty[1] & /*fullscreen, $heightHalf, $widthHalf, $size*/
    456) {
      $:
        updateStyles(styles.noTransform.div, {
          top: fullscreen ? `${-$heightHalf}px` : void 0,
          left: fullscreen ? `${-$widthHalf}px` : void 0,
          width: fullscreen ? `${$size.width}px` : void 0,
          height: fullscreen ? `${$size.height}px` : void 0
        });
    }
  };
  return [
    transform,
    as,
    ref,
    el,
    transformOuterRef,
    transformInnerRef,
    showEl,
    $component,
    $transformElStyles,
    $transformOuterRefStyles,
    $transformInnerRefStyles,
    $noTransformElStyles,
    $noTransformDivStyles,
    camera,
    size,
    widthHalf,
    heightHalf,
    transformElStyles,
    transformOuterRefStyles,
    transformInnerRefStyles,
    noTransformElStyles,
    noTransformDivStyles,
    buildDefaultNonTransformStyles,
    portalAction,
    component,
    $$restProps,
    visible,
    calculatePosition,
    eps,
    occlude,
    zIndexRange,
    sprite,
    pointerEvents,
    center,
    fullscreen,
    distanceFactor,
    portal,
    $size,
    $heightHalf,
    $widthHalf,
    slots,
    t0_binding,
    div0_binding,
    div1_binding,
    svelte_element_binding,
    svelte_element_binding_1,
    $$scope
  ];
}
var HTML = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        transform: 0,
        calculatePosition: 27,
        eps: 28,
        occlude: 29,
        zIndexRange: 30,
        sprite: 31,
        pointerEvents: 32,
        center: 33,
        fullscreen: 34,
        distanceFactor: 35,
        as: 1,
        portal: 36,
        ref: 2,
        visible: 26
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HTML",
      options,
      id: create_fragment2.name
    });
  }
  get transform() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transform(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get calculatePosition() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set calculatePosition(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get eps() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set eps(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get occlude() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set occlude(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndexRange() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndexRange(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sprite() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sprite(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pointerEvents() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pointerEvents(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get center() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set center(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fullscreen() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fullscreen(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get distanceFactor() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set distanceFactor(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get as() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set as(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get portal() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set portal(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error_12("<HTML>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error_12("<HTML>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HTML_default = HTML;

// node_modules/@threlte/extras/dist/components/Float/Float.svelte
var get_default_slot_changes2 = (dirty) => ({ ref: dirty & /*ref*/
32768 });
var get_default_slot_context2 = (ctx) => ({ ref: (
  /*ref*/
  ctx[15]
) });
function create_default_slot3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_default_slot_context2
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        36864)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(56:0) <T.Group   position={floatPosition}   rotation={floatRotation}   let:ref   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let t_group;
  let current;
  const t_group_spread_levels = [
    { position: (
      /*floatPosition*/
      ctx[0]
    ) },
    { rotation: (
      /*floatRotation*/
      ctx[1]
    ) },
    /*$$restProps*/
    ctx[2]
  ];
  let t_group_props = {
    $$slots: {
      default: [
        create_default_slot3,
        ({ ref }) => ({ 15: ref }),
        ({ ref }) => ref ? 32768 : 0
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_group_spread_levels.length; i += 1) {
    t_group_props = assign(t_group_props, t_group_spread_levels[i]);
  }
  t_group = new T.Group({ props: t_group_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(t_group.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_group.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_group, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_group_changes = dirty & /*floatPosition, floatRotation, $$restProps*/
      7 ? get_spread_update(t_group_spread_levels, [
        dirty & /*floatPosition*/
        1 && { position: (
          /*floatPosition*/
          ctx2[0]
        ) },
        dirty & /*floatRotation*/
        2 && { rotation: (
          /*floatRotation*/
          ctx2[1]
        ) },
        dirty & /*$$restProps*/
        4 && get_spread_object(
          /*$$restProps*/
          ctx2[2]
        )
      ]) : {};
      if (dirty & /*$$scope, ref*/
      36864) {
        t_group_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t_group.$set(t_group_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t_group.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_group.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_group, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "position",
    "rotation",
    "speed",
    "floatIntensity",
    "floatingRange",
    "rotationSpeed",
    "rotationIntensity",
    "seed"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Float", slots, ["default"]);
  let { position = 0 } = $$props;
  let { rotation = 0 } = $$props;
  let { speed = 1 } = $$props;
  let { floatIntensity = 1 } = $$props;
  let { floatingRange = [-0.1, 0.1] } = $$props;
  let { rotationSpeed = 0 } = $$props;
  let { rotationIntensity = 0 } = $$props;
  let { seed = Math.random() * 1e4 } = $$props;
  let t2 = seed;
  let floatPosition = Array.isArray(position) ? position : [position, position, position];
  const map = MathUtils.mapLinear;
  let floatRotation = Array.isArray(rotation) ? rotation : [rotation, rotation, rotation];
  useFrame(
    (_, delta) => {
      t2 += delta;
      const fSpeed = Array.isArray(speed) ? speed : [speed, speed, speed];
      const fIntensity = Array.isArray(floatIntensity) ? floatIntensity : [floatIntensity, floatIntensity, floatIntensity];
      const fRange = floatingRange.length == 3 ? floatingRange : [[0, 0], floatingRange, [0, 0]];
      $$invalidate(0, floatPosition = Array.isArray(position) ? position : [position, position, position]);
      $$invalidate(0, floatPosition[0] = floatPosition[0] + map(Math.sin(t2 / 4 * fSpeed[0]) / 10, -0.1, 0.1, ...fRange[0]) * fIntensity[0], floatPosition);
      $$invalidate(0, floatPosition[1] = floatPosition[1] + map(Math.sin(t2 / 4 * fSpeed[1]) / 10, -0.1, 0.1, ...fRange[1]) * fIntensity[1], floatPosition);
      $$invalidate(0, floatPosition[2] = floatPosition[2] + map(Math.sin(t2 / 4 * fSpeed[2]) / 10, -0.1, 0.1, ...fRange[2]) * fIntensity[2], floatPosition);
      $$invalidate(0, floatPosition);
      const rSpeed = Array.isArray(rotationSpeed) ? rotationSpeed : [rotationSpeed, rotationSpeed, rotationSpeed];
      const rIntensity = Array.isArray(rotationIntensity) ? rotationIntensity : [rotationIntensity, rotationIntensity, rotationIntensity];
      $$invalidate(1, floatRotation = Array.isArray(rotation) ? rotation : [rotation, rotation, rotation]);
      $$invalidate(1, floatRotation[0] += Math.cos(t2 / 4 * rSpeed[0]) / 8 * rIntensity[0], floatRotation);
      $$invalidate(1, floatRotation[1] += Math.cos(t2 / 4 * rSpeed[1]) / 8 * rIntensity[1], floatRotation);
      $$invalidate(1, floatRotation[2] += Math.cos(t2 / 4 * rSpeed[2]) / 8 * rIntensity[2], floatRotation);
    },
    {
      debugFrameloopMessage: "Float: framehandler"
    }
  );
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("position" in $$new_props)
      $$invalidate(3, position = $$new_props.position);
    if ("rotation" in $$new_props)
      $$invalidate(4, rotation = $$new_props.rotation);
    if ("speed" in $$new_props)
      $$invalidate(5, speed = $$new_props.speed);
    if ("floatIntensity" in $$new_props)
      $$invalidate(6, floatIntensity = $$new_props.floatIntensity);
    if ("floatingRange" in $$new_props)
      $$invalidate(7, floatingRange = $$new_props.floatingRange);
    if ("rotationSpeed" in $$new_props)
      $$invalidate(8, rotationSpeed = $$new_props.rotationSpeed);
    if ("rotationIntensity" in $$new_props)
      $$invalidate(9, rotationIntensity = $$new_props.rotationIntensity);
    if ("seed" in $$new_props)
      $$invalidate(10, seed = $$new_props.seed);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    MathUtils,
    useFrame,
    T,
    position,
    rotation,
    speed,
    floatIntensity,
    floatingRange,
    rotationSpeed,
    rotationIntensity,
    seed,
    t: t2,
    floatPosition,
    map,
    floatRotation
  });
  $$self.$inject_state = ($$new_props) => {
    if ("position" in $$props)
      $$invalidate(3, position = $$new_props.position);
    if ("rotation" in $$props)
      $$invalidate(4, rotation = $$new_props.rotation);
    if ("speed" in $$props)
      $$invalidate(5, speed = $$new_props.speed);
    if ("floatIntensity" in $$props)
      $$invalidate(6, floatIntensity = $$new_props.floatIntensity);
    if ("floatingRange" in $$props)
      $$invalidate(7, floatingRange = $$new_props.floatingRange);
    if ("rotationSpeed" in $$props)
      $$invalidate(8, rotationSpeed = $$new_props.rotationSpeed);
    if ("rotationIntensity" in $$props)
      $$invalidate(9, rotationIntensity = $$new_props.rotationIntensity);
    if ("seed" in $$props)
      $$invalidate(10, seed = $$new_props.seed);
    if ("t" in $$props)
      t2 = $$new_props.t;
    if ("floatPosition" in $$props)
      $$invalidate(0, floatPosition = $$new_props.floatPosition);
    if ("floatRotation" in $$props)
      $$invalidate(1, floatRotation = $$new_props.floatRotation);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    floatPosition,
    floatRotation,
    $$restProps,
    position,
    rotation,
    speed,
    floatIntensity,
    floatingRange,
    rotationSpeed,
    rotationIntensity,
    seed,
    slots,
    $$scope
  ];
}
var Float = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      position: 3,
      rotation: 4,
      speed: 5,
      floatIntensity: 6,
      floatingRange: 7,
      rotationSpeed: 8,
      rotationIntensity: 9,
      seed: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Float",
      options,
      id: create_fragment3.name
    });
  }
  get position() {
    throw new Error("<Float>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Float>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotation() {
    throw new Error("<Float>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotation(value) {
    throw new Error("<Float>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get speed() {
    throw new Error("<Float>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set speed(value) {
    throw new Error("<Float>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get floatIntensity() {
    throw new Error("<Float>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set floatIntensity(value) {
    throw new Error("<Float>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get floatingRange() {
    throw new Error("<Float>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set floatingRange(value) {
    throw new Error("<Float>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotationSpeed() {
    throw new Error("<Float>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotationSpeed(value) {
    throw new Error("<Float>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotationIntensity() {
    throw new Error("<Float>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotationIntensity(value) {
    throw new Error("<Float>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get seed() {
    throw new Error("<Float>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set seed(value) {
    throw new Error("<Float>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Float_default = Float;

// node_modules/@threlte/extras/dist/components/GLTF/GLTF.svelte
var { console: console_1 } = globals;
var get_default_slot_changes3 = (dirty) => ({ ref: dirty & /*ref*/
33554432 });
var get_default_slot_context3 = (ctx) => ({ ref: (
  /*ref*/
  ctx[25]
) });
function create_if_block2(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*scene*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let t_props = {
    $$slots: {
      default: [
        create_default_slot4,
        ({ ref }) => ({ 25: ref }),
        ({ ref }) => ref ? 33554432 : 0
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[18](t2);
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_changes = dirty & /*scene, $$restProps*/
      9 ? get_spread_update(t_spread_levels, [
        dirty & /*scene*/
        1 && { is: (
          /*scene*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope, ref*/
      34078720) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[18](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(69:0) {#if scene}",
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_default_slot_context3
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        34078720)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_default_slot_changes3
            ),
            get_default_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(70:2) <T is={scene} {...$$restProps} let:ref bind:this={$component}>",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*scene*/
    ctx[0] && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*scene*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*scene*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "url",
    "useDraco",
    "useMeshopt",
    "ktxTranscoderPath",
    "gltf",
    "scene",
    "animations",
    "asset",
    "cameras",
    "scenes",
    "userData",
    "parser",
    "materials",
    "nodes"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GLTF", slots, ["default"]);
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(1, $component = value));
  let { url } = $$props;
  let { useDraco = false } = $$props;
  let { useMeshopt = false } = $$props;
  let { ktxTranscoderPath = void 0 } = $$props;
  const dispatch = createRawEventDispatcher();
  let { gltf = void 0 } = $$props;
  let { scene = void 0 } = $$props;
  let { animations = void 0 } = $$props;
  let { asset = void 0 } = $$props;
  let { cameras = void 0 } = $$props;
  let { scenes = void 0 } = $$props;
  let { userData = void 0 } = $$props;
  let { parser = void 0 } = $$props;
  let { materials = void 0 } = $$props;
  let { nodes = void 0 } = $$props;
  const loader = useGltf({
    useDraco: useDraco ? typeof useDraco === "string" ? useDraco : "https://www.gstatic.com/draco/v1/decoders/" : void 0,
    useMeshopt,
    ktxTranscoderPath
  });
  const onLoad = (data) => {
    if (gltf)
      dispatch("unload");
    $$invalidate(4, gltf = data);
    $$invalidate(0, scene = data.scene);
    $$invalidate(5, animations = data.animations);
    $$invalidate(6, asset = data.asset);
    $$invalidate(7, cameras = data.cameras);
    $$invalidate(8, scenes = data.scenes);
    $$invalidate(9, userData = data.userData);
    $$invalidate(10, parser = data.parser);
    $$invalidate(11, materials = data.materials);
    $$invalidate(12, nodes = data.nodes);
    dispatch("load", gltf);
  };
  const onError = (error) => {
    console.error(`Error loading GLTF: ${error.message}`);
    $$invalidate(4, gltf = void 0);
    $$invalidate(0, scene = void 0);
    $$invalidate(5, animations = void 0);
    $$invalidate(6, asset = void 0);
    $$invalidate(7, cameras = void 0);
    $$invalidate(8, scenes = void 0);
    $$invalidate(9, userData = void 0);
    $$invalidate(10, parser = void 0);
    $$invalidate(12, nodes = void 0);
    $$invalidate(11, materials = void 0);
    dispatch("error", error.message);
  };
  const loadGltf = async (url2) => {
    try {
      const model = await loader.load(url2);
      onLoad(model);
    } catch (error) {
      onError(error);
    }
  };
  $$self.$$.on_mount.push(function() {
    if (url === void 0 && !("url" in $$props || $$self.$$.bound[$$self.$$.props["url"]])) {
      console_1.warn("<GLTF> was created without expected prop 'url'");
    }
  });
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("url" in $$new_props)
      $$invalidate(13, url = $$new_props.url);
    if ("useDraco" in $$new_props)
      $$invalidate(14, useDraco = $$new_props.useDraco);
    if ("useMeshopt" in $$new_props)
      $$invalidate(15, useMeshopt = $$new_props.useMeshopt);
    if ("ktxTranscoderPath" in $$new_props)
      $$invalidate(16, ktxTranscoderPath = $$new_props.ktxTranscoderPath);
    if ("gltf" in $$new_props)
      $$invalidate(4, gltf = $$new_props.gltf);
    if ("scene" in $$new_props)
      $$invalidate(0, scene = $$new_props.scene);
    if ("animations" in $$new_props)
      $$invalidate(5, animations = $$new_props.animations);
    if ("asset" in $$new_props)
      $$invalidate(6, asset = $$new_props.asset);
    if ("cameras" in $$new_props)
      $$invalidate(7, cameras = $$new_props.cameras);
    if ("scenes" in $$new_props)
      $$invalidate(8, scenes = $$new_props.scenes);
    if ("userData" in $$new_props)
      $$invalidate(9, userData = $$new_props.userData);
    if ("parser" in $$new_props)
      $$invalidate(10, parser = $$new_props.parser);
    if ("materials" in $$new_props)
      $$invalidate(11, materials = $$new_props.materials);
    if ("nodes" in $$new_props)
      $$invalidate(12, nodes = $$new_props.nodes);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createRawEventDispatcher,
    forwardEventHandlers,
    T,
    useGltf,
    component,
    url,
    useDraco,
    useMeshopt,
    ktxTranscoderPath,
    dispatch,
    gltf,
    scene,
    animations,
    asset,
    cameras,
    scenes,
    userData,
    parser,
    materials,
    nodes,
    loader,
    onLoad,
    onError,
    loadGltf,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("url" in $$props)
      $$invalidate(13, url = $$new_props.url);
    if ("useDraco" in $$props)
      $$invalidate(14, useDraco = $$new_props.useDraco);
    if ("useMeshopt" in $$props)
      $$invalidate(15, useMeshopt = $$new_props.useMeshopt);
    if ("ktxTranscoderPath" in $$props)
      $$invalidate(16, ktxTranscoderPath = $$new_props.ktxTranscoderPath);
    if ("gltf" in $$props)
      $$invalidate(4, gltf = $$new_props.gltf);
    if ("scene" in $$props)
      $$invalidate(0, scene = $$new_props.scene);
    if ("animations" in $$props)
      $$invalidate(5, animations = $$new_props.animations);
    if ("asset" in $$props)
      $$invalidate(6, asset = $$new_props.asset);
    if ("cameras" in $$props)
      $$invalidate(7, cameras = $$new_props.cameras);
    if ("scenes" in $$props)
      $$invalidate(8, scenes = $$new_props.scenes);
    if ("userData" in $$props)
      $$invalidate(9, userData = $$new_props.userData);
    if ("parser" in $$props)
      $$invalidate(10, parser = $$new_props.parser);
    if ("materials" in $$props)
      $$invalidate(11, materials = $$new_props.materials);
    if ("nodes" in $$props)
      $$invalidate(12, nodes = $$new_props.nodes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*url*/
    8192) {
      $:
        loadGltf(url);
    }
  };
  return [
    scene,
    $component,
    component,
    $$restProps,
    gltf,
    animations,
    asset,
    cameras,
    scenes,
    userData,
    parser,
    materials,
    nodes,
    url,
    useDraco,
    useMeshopt,
    ktxTranscoderPath,
    slots,
    t_binding,
    $$scope
  ];
}
var GLTF = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      url: 13,
      useDraco: 14,
      useMeshopt: 15,
      ktxTranscoderPath: 16,
      gltf: 4,
      scene: 0,
      animations: 5,
      asset: 6,
      cameras: 7,
      scenes: 8,
      userData: 9,
      parser: 10,
      materials: 11,
      nodes: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GLTF",
      options,
      id: create_fragment4.name
    });
  }
  get url() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useDraco() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useDraco(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useMeshopt() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useMeshopt(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ktxTranscoderPath() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ktxTranscoderPath(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gltf() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gltf(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scene() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scene(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animations() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animations(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asset() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asset(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cameras() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cameras(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scenes() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scenes(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get userData() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set userData(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parser() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parser(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get materials() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set materials(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodes() {
    throw new Error("<GLTF>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodes(value) {
    throw new Error("<GLTF>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GLTF_default = GLTF;

// node_modules/@threlte/extras/dist/components/Disposables/Disposables.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let disposableobject;
  let current;
  disposableobject = new DisposableObject_default({
    props: {
      dispose: true,
      object: (
        /*disposable*/
        ctx[3]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(disposableobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(disposableobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(disposableobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const disposableobject_changes = {};
      if (dirty & /*disposables*/
      1)
        disposableobject_changes.object = /*disposable*/
        ctx2[3];
      disposableobject.$set(disposableobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(disposableobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(disposableobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(disposableobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(6:0) {#each disposables as disposable}",
    ctx
  });
  return block;
}
function create_default_slot5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: "(11:0) <DisposableObject dispose={false}>",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let t2;
  let disposableobject;
  let current;
  let each_value = (
    /*disposables*/
    ctx[0]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  disposableobject = new DisposableObject_default({
    props: {
      dispose: false,
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      create_component(disposableobject.$$.fragment);
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      t2 = claim_space(nodes);
      claim_component(disposableobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, t2, anchor);
      mount_component(disposableobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*disposables*/
      1) {
        each_value = /*disposables*/
        ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(t2.parentNode, t2);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      const disposableobject_changes = {};
      if (dirty & /*$$scope*/
      4) {
        disposableobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      disposableobject.$set(disposableobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(disposableobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(disposableobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(disposableobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Disposables", slots, ["default"]);
  let { disposables } = $$props;
  $$self.$$.on_mount.push(function() {
    if (disposables === void 0 && !("disposables" in $$props || $$self.$$.bound[$$self.$$.props["disposables"]])) {
      console.warn("<Disposables> was created without expected prop 'disposables'");
    }
  });
  const writable_props = ["disposables"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Disposables> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("disposables" in $$props2)
      $$invalidate(0, disposables = $$props2.disposables);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ DisposableObject: DisposableObject_default, disposables });
  $$self.$inject_state = ($$props2) => {
    if ("disposables" in $$props2)
      $$invalidate(0, disposables = $$props2.disposables);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [disposables, slots, $$scope];
}
var Disposables = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { disposables: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Disposables",
      options,
      id: create_fragment5.name
    });
  }
  get disposables() {
    throw new Error("<Disposables>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disposables(value) {
    throw new Error("<Disposables>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Disposables_default = Disposables;

// node_modules/three/examples/jsm/shaders/HorizontalBlurShader.js
var HorizontalBlurShader = {
  name: "HorizontalBlurShader",
  uniforms: {
    "tDiffuse": { value: null },
    "h": { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float h;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
};

// node_modules/three/examples/jsm/shaders/VerticalBlurShader.js
var VerticalBlurShader = {
  name: "VerticalBlurShader",
  uniforms: {
    "tDiffuse": { value: null },
    "v": { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform float v;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

			gl_FragColor = sum;

		}`
  )
};

// node_modules/@threlte/extras/dist/lib/useMemo.js
var useMemo = (callback) => {
  let initialCallDone = false;
  const memoized = writable(callback());
  const memoize2 = (..._args) => {
    if (!initialCallDone) {
      initialCallDone = true;
      return;
    }
    memoized.set(callback());
  };
  return {
    ...memoized,
    memoize: memoize2
  };
};

// node_modules/@threlte/extras/dist/components/ContactShadows/ContactShadows.svelte
var { Error: Error_13 } = globals;
var get_default_slot_changes4 = (dirty) => ({ ref: dirty[1] & /*ref*/
1024 });
var get_default_slot_context4 = (ctx) => ({ ref: (
  /*ref*/
  ctx[41]
) });
function create_default_slot_1(ctx) {
  let t_mesh;
  let t0;
  let t1;
  let t2;
  let current;
  t_mesh = new T.Mesh({
    props: {
      "scale.y": -1,
      "rotation.x": -Math.PI / 2,
      material: (
        /*shadowMaterial*/
        ctx[10]
      ),
      geometry: (
        /*$planeGeometry*/
        ctx[0]
      )
    },
    $$inline: true
  });
  t1 = new T({
    props: {
      is: (
        /*shadowCamera*/
        ctx[9]
      ),
      manual: true
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[27].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    get_default_slot_context4
  );
  const block = {
    c: function create() {
      create_component(t_mesh.$$.fragment);
      t0 = space();
      create_component(t1.$$.fragment);
      t2 = space();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      claim_component(t_mesh.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(t1.$$.fragment, nodes);
      t2 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_mesh, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(t1, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_mesh_changes = {};
      if (dirty[0] & /*$planeGeometry*/
      1)
        t_mesh_changes.geometry = /*$planeGeometry*/
        ctx2[0];
      t_mesh.$set(t_mesh_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        536870912 | dirty[1] & /*ref*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[29],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[29]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[29],
              dirty,
              get_default_slot_changes4
            ),
            get_default_slot_context4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t_mesh.$$.fragment, local);
      transition_in(t1.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_mesh.$$.fragment, local);
      transition_out(t1.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_mesh, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(t1, detaching);
      if (detaching)
        detach_dev(t2);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(150:2) <T.Group rotation.x={Math.PI / 2}>",
    ctx
  });
  return block;
}
function create_default_slot6(ctx) {
  let t_group;
  let current;
  t_group = new T.Group({
    props: {
      "rotation.x": Math.PI / 2,
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t_group.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_group.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_group, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_group_changes = {};
      if (dirty[0] & /*$$scope, $planeGeometry*/
      536870913 | dirty[1] & /*ref*/
      1024) {
        t_group_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t_group.$set(t_group_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t_group.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_group.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_group, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: "(149:0) <T.Group {...$$restProps} let:ref bind:this={$components}>",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let t_group;
  let current;
  const t_group_spread_levels = [
    /*$$restProps*/
    ctx[12]
  ];
  let t_group_props = {
    $$slots: {
      default: [
        create_default_slot6,
        ({ ref }) => ({ 41: ref }),
        ({ ref }) => [0, ref ? 1024 : 0]
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_group_spread_levels.length; i += 1) {
    t_group_props = assign(t_group_props, t_group_spread_levels[i]);
  }
  t_group = new T.Group({ props: t_group_props, $$inline: true });
  ctx[28](t_group);
  const block = {
    c: function create() {
      create_component(t_group.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_group.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_group, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_group_changes = dirty[0] & /*$$restProps*/
      4096 ? get_spread_update(t_group_spread_levels, [get_spread_object(
        /*$$restProps*/
        ctx2[12]
      )]) : {};
      if (dirty[0] & /*$$scope, $planeGeometry*/
      536870913 | dirty[1] & /*ref*/
      1024) {
        t_group_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t_group.$set(t_group_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t_group.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_group.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[28](null);
      destroy_component(t_group, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "opacity",
    "width",
    "height",
    "blur",
    "far",
    "smooth",
    "resolution",
    "frames",
    "scale",
    "color",
    "depthWrite",
    "refresh"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $depthMaterial;
  let $planeGeometry;
  let $renderTargetBlur;
  let $renderTarget;
  let $blurPlane;
  let $scaledHeight;
  let $scaledWidth;
  let $components;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContactShadows", slots, ["default"]);
  let { opacity = 1 } = $$props;
  let { width = 1 } = $$props;
  let { height = 1 } = $$props;
  let { blur = 1 } = $$props;
  let { far = 10 } = $$props;
  let { smooth = true } = $$props;
  let { resolution = 512 } = $$props;
  let { frames = Infinity } = $$props;
  let { scale = 10 } = $$props;
  let { color = "#000000" } = $$props;
  let { depthWrite = false } = $$props;
  const { scene, renderer } = useThrelte();
  if (!renderer)
    throw new Error("ContactShadow: WebGLRenderer is undefined, is this component a child of <Canvas>?");
  const scaledWidth = useMemo(() => {
    return width * (Array.isArray(scale) ? scale[0] : scale || 1);
  });
  validate_store(scaledWidth, "scaledWidth");
  component_subscribe($$self, scaledWidth, (value) => $$invalidate(26, $scaledWidth = value));
  const scaledHeight = useMemo(() => {
    return height * (Array.isArray(scale) ? scale[1] : scale || 1);
  });
  validate_store(scaledHeight, "scaledHeight");
  component_subscribe($$self, scaledHeight, (value) => $$invalidate(25, $scaledHeight = value));
  const renderTarget = useMemo(() => {
    const rt = new WebGLRenderTarget(resolution, resolution);
    rt.texture.generateMipmaps = false;
    rt.texture.encoding = renderer.outputEncoding;
    return rt;
  });
  validate_store(renderTarget, "renderTarget");
  component_subscribe($$self, renderTarget, (value) => $$invalidate(36, $renderTarget = value));
  const renderTargetBlur = useMemo(() => {
    const rt = new WebGLRenderTarget(resolution, resolution);
    rt.texture.generateMipmaps = false;
    return rt;
  });
  validate_store(renderTargetBlur, "renderTargetBlur");
  component_subscribe($$self, renderTargetBlur, (value) => $$invalidate(35, $renderTargetBlur = value));
  const planeGeometry = useMemo(() => {
    return new PlaneGeometry($scaledWidth, $scaledHeight).rotateX(Math.PI / 2);
  });
  validate_store(planeGeometry, "planeGeometry");
  component_subscribe($$self, planeGeometry, (value) => $$invalidate(0, $planeGeometry = value));
  const blurPlane = useMemo(() => {
    return new Mesh($planeGeometry);
  });
  validate_store(blurPlane, "blurPlane");
  component_subscribe($$self, blurPlane, (value) => $$invalidate(37, $blurPlane = value));
  const depthMaterial = useMemo(() => {
    const dm = new MeshDepthMaterial({ depthTest: false, depthWrite: false });
    dm.onBeforeCompile = (shader) => {
      shader.uniforms = {
        ...shader.uniforms,
        uColor: {
          value: new Color(color).convertSRGBToLinear()
        }
      };
      shader.fragmentShader = "uniform vec3 uColor;\n" + shader.fragmentShader;
      shader.fragmentShader = shader.fragmentShader.replace("vec4( vec3( 1.0 - fragCoordZ ), opacity );", "vec4( uColor, ( 1.0 - fragCoordZ ) * 1.0 );");
      shader.fragmentShader = shader.fragmentShader.replace("vec4(vec3(1.0-fragCoordZ),opacity);", "vec4(uColor,(1.0-fragCoordZ)*1.0);");
    };
    return dm;
  });
  validate_store(depthMaterial, "depthMaterial");
  component_subscribe($$self, depthMaterial, (value) => $$invalidate(34, $depthMaterial = value));
  const horizontalBlurMaterial = new ShaderMaterial({
    ...HorizontalBlurShader,
    depthTest: false
  });
  const verticalBlurMaterial = new ShaderMaterial({ ...VerticalBlurShader, depthTest: false });
  const shadowCamera = new OrthographicCamera(-$scaledWidth / 2, $scaledWidth / 2, $scaledHeight / 2, -$scaledHeight / 2, 0, far);
  shadowCamera.updateProjectionMatrix();
  const shadowMaterial = new MeshBasicMaterial({
    map: $renderTarget.texture,
    transparent: true,
    opacity,
    depthWrite
  });
  const blurShadows = (blur2) => {
    const bp = $blurPlane;
    bp.visible = true;
    bp.material = horizontalBlurMaterial;
    horizontalBlurMaterial.uniforms.tDiffuse.value = $renderTarget.texture;
    horizontalBlurMaterial.uniforms.h.value = blur2 * 1 / 256;
    renderer.setRenderTarget($renderTargetBlur);
    renderer.render(bp, shadowCamera);
    bp.material = verticalBlurMaterial;
    verticalBlurMaterial.uniforms.tDiffuse.value = $renderTargetBlur.texture;
    verticalBlurMaterial.uniforms.v.value = blur2 * 1 / 256;
    renderer.setRenderTarget($renderTarget);
    renderer.render(bp, shadowCamera);
    bp.visible = false;
  };
  const renderShadows = () => {
    const initialBackground = scene.background;
    scene.background = null;
    const initialOverrideMaterial = scene.overrideMaterial;
    scene.overrideMaterial = $depthMaterial;
    const initialClearAlpha = renderer.getClearAlpha();
    renderer.setClearAlpha(0);
    renderer.setRenderTarget($renderTarget);
    renderer.render(scene, shadowCamera);
    scene.overrideMaterial = initialOverrideMaterial;
    blurShadows(blur);
    if (smooth)
      blurShadows(blur * 0.4);
    renderer.setRenderTarget(null);
    scene.background = initialBackground;
    renderer.setClearAlpha(initialClearAlpha);
  };
  const refresh = () => {
    renderShadows();
  };
  let count = 0;
  useFrame(() => {
    if (frames === Infinity || count < frames) {
      renderShadows();
      count += 1;
    }
  });
  onDestroy(() => {
    $renderTarget.dispose();
    $renderTargetBlur.dispose();
    $planeGeometry.dispose();
    $depthMaterial.dispose();
    horizontalBlurMaterial.dispose();
    verticalBlurMaterial.dispose();
    shadowMaterial.dispose();
  });
  const components = forwardEventHandlers();
  validate_store(components, "components");
  component_subscribe($$self, components, (value) => $$invalidate(1, $components = value));
  function t_group_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $components = $$value;
      components.set($components);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("opacity" in $$new_props)
      $$invalidate(13, opacity = $$new_props.opacity);
    if ("width" in $$new_props)
      $$invalidate(14, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(15, height = $$new_props.height);
    if ("blur" in $$new_props)
      $$invalidate(16, blur = $$new_props.blur);
    if ("far" in $$new_props)
      $$invalidate(17, far = $$new_props.far);
    if ("smooth" in $$new_props)
      $$invalidate(18, smooth = $$new_props.smooth);
    if ("resolution" in $$new_props)
      $$invalidate(19, resolution = $$new_props.resolution);
    if ("frames" in $$new_props)
      $$invalidate(20, frames = $$new_props.frames);
    if ("scale" in $$new_props)
      $$invalidate(21, scale = $$new_props.scale);
    if ("color" in $$new_props)
      $$invalidate(22, color = $$new_props.color);
    if ("depthWrite" in $$new_props)
      $$invalidate(23, depthWrite = $$new_props.depthWrite);
    if ("$$scope" in $$new_props)
      $$invalidate(29, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    forwardEventHandlers,
    T,
    useFrame,
    useThrelte,
    onDestroy,
    Color,
    Mesh,
    MeshBasicMaterial,
    MeshDepthMaterial,
    OrthographicCamera,
    PlaneGeometry,
    ShaderMaterial,
    WebGLRenderTarget,
    HorizontalBlurShader,
    VerticalBlurShader,
    useMemo,
    opacity,
    width,
    height,
    blur,
    far,
    smooth,
    resolution,
    frames,
    scale,
    color,
    depthWrite,
    scene,
    renderer,
    scaledWidth,
    scaledHeight,
    renderTarget,
    renderTargetBlur,
    planeGeometry,
    blurPlane,
    depthMaterial,
    horizontalBlurMaterial,
    verticalBlurMaterial,
    shadowCamera,
    shadowMaterial,
    blurShadows,
    renderShadows,
    refresh,
    count,
    components,
    $depthMaterial,
    $planeGeometry,
    $renderTargetBlur,
    $renderTarget,
    $blurPlane,
    $scaledHeight,
    $scaledWidth,
    $components
  });
  $$self.$inject_state = ($$new_props) => {
    if ("opacity" in $$props)
      $$invalidate(13, opacity = $$new_props.opacity);
    if ("width" in $$props)
      $$invalidate(14, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(15, height = $$new_props.height);
    if ("blur" in $$props)
      $$invalidate(16, blur = $$new_props.blur);
    if ("far" in $$props)
      $$invalidate(17, far = $$new_props.far);
    if ("smooth" in $$props)
      $$invalidate(18, smooth = $$new_props.smooth);
    if ("resolution" in $$props)
      $$invalidate(19, resolution = $$new_props.resolution);
    if ("frames" in $$props)
      $$invalidate(20, frames = $$new_props.frames);
    if ("scale" in $$props)
      $$invalidate(21, scale = $$new_props.scale);
    if ("color" in $$props)
      $$invalidate(22, color = $$new_props.color);
    if ("depthWrite" in $$props)
      $$invalidate(23, depthWrite = $$new_props.depthWrite);
    if ("count" in $$props)
      count = $$new_props.count;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*width, scale*/
    2113536) {
      $:
        scaledWidth.memoize([width, scale]);
    }
    if ($$self.$$.dirty[0] & /*height, scale*/
    2129920) {
      $:
        scaledHeight.memoize(height, scale);
    }
    if ($$self.$$.dirty[0] & /*resolution*/
    524288) {
      $:
        renderTarget.memoize(resolution);
    }
    if ($$self.$$.dirty[0] & /*resolution*/
    524288) {
      $:
        renderTargetBlur.memoize(resolution);
    }
    if ($$self.$$.dirty[0] & /*$scaledWidth, $scaledHeight*/
    100663296) {
      $:
        planeGeometry.memoize($scaledWidth, $scaledHeight);
    }
    if ($$self.$$.dirty[0] & /*$planeGeometry*/
    1) {
      $:
        blurPlane.memoize($planeGeometry);
    }
    if ($$self.$$.dirty[0] & /*color*/
    4194304) {
      $:
        depthMaterial.memoize(color);
    }
  };
  return [
    $planeGeometry,
    $components,
    scaledWidth,
    scaledHeight,
    renderTarget,
    renderTargetBlur,
    planeGeometry,
    blurPlane,
    depthMaterial,
    shadowCamera,
    shadowMaterial,
    components,
    $$restProps,
    opacity,
    width,
    height,
    blur,
    far,
    smooth,
    resolution,
    frames,
    scale,
    color,
    depthWrite,
    refresh,
    $scaledHeight,
    $scaledWidth,
    slots,
    t_group_binding,
    $$scope
  ];
}
var ContactShadows = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance6,
      create_fragment6,
      safe_not_equal,
      {
        opacity: 13,
        width: 14,
        height: 15,
        blur: 16,
        far: 17,
        smooth: 18,
        resolution: 19,
        frames: 20,
        scale: 21,
        color: 22,
        depthWrite: 23,
        refresh: 24
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContactShadows",
      options,
      id: create_fragment6.name
    });
  }
  get opacity() {
    throw new Error_13("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error_13("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error_13("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error_13("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error_13("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error_13("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blur() {
    throw new Error_13("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blur(value) {
    throw new Error_13("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get far() {
    throw new Error_13("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set far(value) {
    throw new Error_13("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smooth() {
    throw new Error_13("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set smooth(value) {
    throw new Error_13("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resolution() {
    throw new Error_13("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resolution(value) {
    throw new Error_13("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get frames() {
    throw new Error_13("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set frames(value) {
    throw new Error_13("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error_13("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error_13("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error_13("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error_13("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get depthWrite() {
    throw new Error_13("<ContactShadows>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set depthWrite(value) {
    throw new Error_13("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get refresh() {
    return this.$$.ctx[24];
  }
  set refresh(value) {
    throw new Error_13("<ContactShadows>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContactShadows_default = ContactShadows;

// node_modules/three/examples/jsm/loaders/RGBELoader.js
var RGBELoader = class extends DataTextureLoader {
  constructor(manager) {
    super(manager);
    this.type = HalfFloatType;
  }
  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
  parse(buffer) {
    const RGBE_RETURN_FAILURE = -1, rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {
      switch (rgbe_error_code) {
        case rgbe_read_error:
          console.error("THREE.RGBELoader Read Error: " + (msg || ""));
          break;
        case rgbe_write_error:
          console.error("THREE.RGBELoader Write Error: " + (msg || ""));
          break;
        case rgbe_format_error:
          console.error("THREE.RGBELoader Bad File Format: " + (msg || ""));
          break;
        default:
        case rgbe_memory_error:
          console.error("THREE.RGBELoader: Error: " + (msg || ""));
      }
      return RGBE_RETURN_FAILURE;
    }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = "\n", fgets = function(buffer2, lineLimit, consume) {
      const chunkSize = 128;
      lineLimit = !lineLimit ? 1024 : lineLimit;
      let p2 = buffer2.pos, i = -1, len = 0, s = "", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p2, p2 + chunkSize)));
      while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p2 < buffer2.byteLength) {
        s += chunk;
        len += chunk.length;
        p2 += chunkSize;
        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p2, p2 + chunkSize)));
      }
      if (-1 < i) {
        if (false !== consume)
          buffer2.pos += len + i + 1;
        return s + chunk.slice(0, i);
      }
      return false;
    }, RGBE_ReadHeader = function(buffer2) {
      const magic_token_re = /^#\?(\S+)/, gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, format_re = /^\s*FORMAT=(\S+)\s*$/, dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, header = {
        valid: 0,
        /* indicate which fields are valid */
        string: "",
        /* the actual header string */
        comments: "",
        /* comments found in header */
        programtype: "RGBE",
        /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */
        format: "",
        /* RGBE format, default 32-bit_rle_rgbe */
        gamma: 1,
        /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */
        exposure: 1,
        /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */
        width: 0,
        height: 0
        /* image dimensions, width/height */
      };
      let line, match;
      if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {
        return rgbe_error(rgbe_read_error, "no header found");
      }
      if (!(match = line.match(magic_token_re))) {
        return rgbe_error(rgbe_format_error, "bad initial token");
      }
      header.valid |= RGBE_VALID_PROGRAMTYPE;
      header.programtype = match[1];
      header.string += line + "\n";
      while (true) {
        line = fgets(buffer2);
        if (false === line)
          break;
        header.string += line + "\n";
        if ("#" === line.charAt(0)) {
          header.comments += line + "\n";
          continue;
        }
        if (match = line.match(gamma_re)) {
          header.gamma = parseFloat(match[1]);
        }
        if (match = line.match(exposure_re)) {
          header.exposure = parseFloat(match[1]);
        }
        if (match = line.match(format_re)) {
          header.valid |= RGBE_VALID_FORMAT;
          header.format = match[1];
        }
        if (match = line.match(dimensions_re)) {
          header.valid |= RGBE_VALID_DIMENSIONS;
          header.height = parseInt(match[1], 10);
          header.width = parseInt(match[2], 10);
        }
        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS)
          break;
      }
      if (!(header.valid & RGBE_VALID_FORMAT)) {
        return rgbe_error(rgbe_format_error, "missing format specifier");
      }
      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {
        return rgbe_error(rgbe_format_error, "missing image size specifier");
      }
      return header;
    }, RGBE_ReadPixels_RLE = function(buffer2, w, h) {
      const scanline_width = w;
      if (
        // run length encoding is not allowed so read flat
        scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded
        (2 !== buffer2[0] || 2 !== buffer2[1] || buffer2[2] & 128)
      ) {
        return new Uint8Array(buffer2);
      }
      if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {
        return rgbe_error(rgbe_format_error, "wrong scanline width");
      }
      const data_rgba = new Uint8Array(4 * w * h);
      if (!data_rgba.length) {
        return rgbe_error(rgbe_memory_error, "unable to allocate buffer space");
      }
      let offset = 0, pos = 0;
      const ptr_end = 4 * scanline_width;
      const rgbeStart = new Uint8Array(4);
      const scanline_buffer = new Uint8Array(ptr_end);
      let num_scanlines = h;
      while (num_scanlines > 0 && pos < buffer2.byteLength) {
        if (pos + 4 > buffer2.byteLength) {
          return rgbe_error(rgbe_read_error);
        }
        rgbeStart[0] = buffer2[pos++];
        rgbeStart[1] = buffer2[pos++];
        rgbeStart[2] = buffer2[pos++];
        rgbeStart[3] = buffer2[pos++];
        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {
          return rgbe_error(rgbe_format_error, "bad rgbe scanline format");
        }
        let ptr = 0, count;
        while (ptr < ptr_end && pos < buffer2.byteLength) {
          count = buffer2[pos++];
          const isEncodedRun = count > 128;
          if (isEncodedRun)
            count -= 128;
          if (0 === count || ptr + count > ptr_end) {
            return rgbe_error(rgbe_format_error, "bad scanline data");
          }
          if (isEncodedRun) {
            const byteValue = buffer2[pos++];
            for (let i = 0; i < count; i++) {
              scanline_buffer[ptr++] = byteValue;
            }
          } else {
            scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);
            ptr += count;
            pos += count;
          }
        }
        const l = scanline_width;
        for (let i = 0; i < l; i++) {
          let off = 0;
          data_rgba[offset] = scanline_buffer[i + off];
          off += scanline_width;
          data_rgba[offset + 1] = scanline_buffer[i + off];
          off += scanline_width;
          data_rgba[offset + 2] = scanline_buffer[i + off];
          off += scanline_width;
          data_rgba[offset + 3] = scanline_buffer[i + off];
          offset += 4;
        }
        num_scanlines--;
      }
      return data_rgba;
    };
    const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {
      const e = sourceArray[sourceOffset + 3];
      const scale = Math.pow(2, e - 128) / 255;
      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
      destArray[destOffset + 3] = 1;
    };
    const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {
      const e = sourceArray[sourceOffset + 3];
      const scale = Math.pow(2, e - 128) / 255;
      destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));
      destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));
      destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));
      destArray[destOffset + 3] = DataUtils.toHalfFloat(1);
    };
    const byteArray = new Uint8Array(buffer);
    byteArray.pos = 0;
    const rgbe_header_info = RGBE_ReadHeader(byteArray);
    if (RGBE_RETURN_FAILURE !== rgbe_header_info) {
      const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);
      if (RGBE_RETURN_FAILURE !== image_rgba_data) {
        let data, type;
        let numElements;
        switch (this.type) {
          case FloatType:
            numElements = image_rgba_data.length / 4;
            const floatArray = new Float32Array(numElements * 4);
            for (let j = 0; j < numElements; j++) {
              RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);
            }
            data = floatArray;
            type = FloatType;
            break;
          case HalfFloatType:
            numElements = image_rgba_data.length / 4;
            const halfArray = new Uint16Array(numElements * 4);
            for (let j = 0; j < numElements; j++) {
              RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);
            }
            data = halfArray;
            type = HalfFloatType;
            break;
          default:
            console.error("THREE.RGBELoader: unsupported type: ", this.type);
            break;
        }
        return {
          width: w,
          height: h,
          data,
          header: rgbe_header_info.string,
          gamma: rgbe_header_info.gamma,
          exposure: rgbe_header_info.exposure,
          type
        };
      }
    }
    return null;
  }
  setDataType(value) {
    this.type = value;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    function onLoadCallback(texture, texData) {
      switch (texture.type) {
        case FloatType:
        case HalfFloatType:
          texture.colorSpace = LinearSRGBColorSpace;
          texture.minFilter = LinearFilter;
          texture.magFilter = LinearFilter;
          texture.generateMipmaps = false;
          texture.flipY = true;
          break;
      }
      if (onLoad)
        onLoad(texture, texData);
    }
    return super.load(url, onLoadCallback, onProgress, onError);
  }
};

// node_modules/three/examples/jsm/loaders/HDRCubeTextureLoader.js
var HDRCubeTextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.hdrLoader = new RGBELoader();
    this.type = HalfFloatType;
  }
  load(urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture();
    texture.type = this.type;
    switch (texture.type) {
      case FloatType:
        texture.colorSpace = LinearSRGBColorSpace;
        texture.minFilter = LinearFilter;
        texture.magFilter = LinearFilter;
        texture.generateMipmaps = false;
        break;
      case HalfFloatType:
        texture.colorSpace = LinearSRGBColorSpace;
        texture.minFilter = LinearFilter;
        texture.magFilter = LinearFilter;
        texture.generateMipmaps = false;
        break;
    }
    const scope = this;
    let loaded = 0;
    function loadHDRData(i, onLoad2, onProgress2, onError2) {
      new FileLoader(scope.manager).setPath(scope.path).setResponseType("arraybuffer").setWithCredentials(scope.withCredentials).load(urls[i], function(buffer) {
        loaded++;
        const texData = scope.hdrLoader.parse(buffer);
        if (!texData)
          return;
        if (texData.data !== void 0) {
          const dataTexture = new DataTexture(texData.data, texData.width, texData.height);
          dataTexture.type = texture.type;
          dataTexture.colorSpace = texture.colorSpace;
          dataTexture.format = texture.format;
          dataTexture.minFilter = texture.minFilter;
          dataTexture.magFilter = texture.magFilter;
          dataTexture.generateMipmaps = texture.generateMipmaps;
          texture.images[i] = dataTexture;
        }
        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad2)
            onLoad2(texture);
        }
      }, onProgress2, onError2);
    }
    for (let i = 0; i < urls.length; i++) {
      loadHDRData(i, onLoad, onProgress, onError);
    }
    return texture;
  }
  setDataType(value) {
    this.type = value;
    this.hdrLoader.setDataType(value);
    return this;
  }
};

// node_modules/three/examples/jsm/objects/GroundProjectedSkybox.js
var GroundProjectedSkybox = class extends Mesh {
  constructor(texture, options = {}) {
    const isCubeMap = texture.isCubeTexture;
    const defines = [
      isCubeMap ? "#define ENVMAP_TYPE_CUBE" : ""
    ];
    const vertexShader = (
      /* glsl */
      `
			varying vec3 vWorldPosition;

			void main() {

				vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
				vWorldPosition = worldPosition.xyz;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}
			`
    );
    const fragmentShader = defines.join("\n") + /* glsl */
    `

				varying vec3 vWorldPosition;

				uniform float radius;
				uniform float height;
				uniform float angle;

				#ifdef ENVMAP_TYPE_CUBE

					uniform samplerCube map;

				#else

					uniform sampler2D map;

				#endif

				// From: https://www.shadertoy.com/view/4tsBD7
				float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
				{

					float d = dot ( rd, n );

					if( d > 0.0 ) { return 1e6; }

					vec3 o = ro - c;
					float t = - dot( n, o ) / d;
					vec3 q = o + rd * t;

					return ( dot( q, q ) < r * r ) ? t : 1e6;

				}

				// From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
				float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) {

					vec3 oc = ro - ce;
					float b = dot( oc, rd );
					float c = dot( oc, oc ) - ra * ra;
					float h = b * b - c;

					if( h < 0.0 ) { return -1.0; }

					h = sqrt( h );

					return - b + h;

				}

				vec3 project() {

					vec3 p = normalize( vWorldPosition );
					vec3 camPos = cameraPosition;
					camPos.y -= height;

					float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
					if( intersection > 0.0 ) {

						vec3 h = vec3( 0.0, - height, 0.0 );
						float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
						p = ( camPos + min( intersection, intersection2 ) * p ) / radius;

					} else {

						p = vec3( 0.0, 1.0, 0.0 );

					}

					return p;

				}

				#include <common>

				void main() {

					vec3 projectedWorldPosition = project();

					#ifdef ENVMAP_TYPE_CUBE

						vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;

					#else

						vec3 direction = normalize( projectedWorldPosition );
						vec2 uv = equirectUv( direction );
						vec3 outcolor = texture2D( map, uv ).rgb;

					#endif

					gl_FragColor = vec4( outcolor, 1.0 );

					#include <tonemapping_fragment>
					#include <encodings_fragment>

				}
				`;
    const uniforms = {
      map: { value: texture },
      height: { value: options.height || 15 },
      radius: { value: options.radius || 100 }
    };
    const geometry = new IcosahedronGeometry(1, 16);
    const material = new ShaderMaterial({
      uniforms,
      fragmentShader,
      vertexShader,
      side: DoubleSide
    });
    super(geometry, material);
  }
  set radius(radius) {
    this.material.uniforms.radius.value = radius;
  }
  get radius() {
    return this.material.uniforms.radius.value;
  }
  set height(height) {
    this.material.uniforms.height.value = height;
  }
  get height() {
    return this.material.uniforms.height.value;
  }
};

// node_modules/@threlte/extras/dist/components/Environment/GroundProjectedSkybox.svelte
function create_if_block3(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: GroundProjectedSkybox },
    { args: [
      /*envMap*/
      ctx[0]
    ] },
    /*$$restProps*/
    ctx[1]
  ];
  let t_props = {};
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_changes = dirty & /*GroundProjectedSkybox, envMap, $$restProps*/
      3 ? get_spread_update(t_spread_levels, [
        dirty & /*GroundProjectedSkybox*/
        0 && { is: GroundProjectedSkybox },
        dirty & /*envMap*/
        1 && { args: [
          /*envMap*/
          ctx2[0]
        ] },
        dirty & /*$$restProps*/
        2 && get_spread_object(
          /*$$restProps*/
          ctx2[1]
        )
      ]) : {};
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(6:0) {#if envMap}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*envMap*/
    ctx[0] && create_if_block3(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*envMap*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*envMap*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  const omit_props_names = ["envMap"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GroundProjectedSkybox", slots, []);
  let { envMap } = $$props;
  $$self.$$.on_mount.push(function() {
    if (envMap === void 0 && !("envMap" in $$props || $$self.$$.bound[$$self.$$.props["envMap"]])) {
      console.warn("<GroundProjectedSkybox> was created without expected prop 'envMap'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("envMap" in $$new_props)
      $$invalidate(0, envMap = $$new_props.envMap);
  };
  $$self.$capture_state = () => ({ T, GroundProjectedSkybox, envMap });
  $$self.$inject_state = ($$new_props) => {
    if ("envMap" in $$props)
      $$invalidate(0, envMap = $$new_props.envMap);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [envMap, $$restProps];
}
var GroundProjectedSkybox_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { envMap: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GroundProjectedSkybox_1",
      options,
      id: create_fragment7.name
    });
  }
  get envMap() {
    throw new Error("<GroundProjectedSkybox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set envMap(value) {
    throw new Error("<GroundProjectedSkybox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GroundProjectedSkybox_default = GroundProjectedSkybox_1;

// node_modules/@threlte/extras/dist/components/Environment/Environment.svelte
var { Error: Error_14 } = globals;
function create_if_block4(ctx) {
  let groundprojectedskybox;
  let current;
  const groundprojectedskybox_spread_levels = [
    /*groundProjection*/
    ctx[0],
    { envMap: (
      /*previousEnvMap*/
      ctx[1]
    ) }
  ];
  let groundprojectedskybox_props = {};
  for (let i = 0; i < groundprojectedskybox_spread_levels.length; i += 1) {
    groundprojectedskybox_props = assign(groundprojectedskybox_props, groundprojectedskybox_spread_levels[i]);
  }
  groundprojectedskybox = new GroundProjectedSkybox_default({
    props: groundprojectedskybox_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(groundprojectedskybox.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(groundprojectedskybox.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(groundprojectedskybox, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const groundprojectedskybox_changes = dirty & /*groundProjection, previousEnvMap*/
      3 ? get_spread_update(groundprojectedskybox_spread_levels, [
        dirty & /*groundProjection*/
        1 && get_spread_object(
          /*groundProjection*/
          ctx2[0]
        ),
        dirty & /*previousEnvMap*/
        2 && { envMap: (
          /*previousEnvMap*/
          ctx2[1]
        ) }
      ]) : {};
      groundprojectedskybox.$set(groundprojectedskybox_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(groundprojectedskybox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(groundprojectedskybox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(groundprojectedskybox, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(91:0) {#if groundProjection}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*groundProjection*/
    ctx[0] && create_if_block4(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*groundProjection*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*groundProjection*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let isCubeMap;
  let envPath;
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Environment", slots, []);
  let { path = "" } = $$props;
  let { files } = $$props;
  let { isBackground = void 0 } = $$props;
  let { groundProjection = void 0 } = $$props;
  let { format = void 0 } = $$props;
  let { encoding = void 0 } = $$props;
  const isScene = (obj) => !!obj.isScene;
  const { scene: globalScene, invalidate, renderer } = useThrelte();
  const parent = useParent();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(13, $parent = value));
  let scene = globalScene;
  if (isScene($parent))
    scene = $parent;
  let previousSceneEnvironment = scene.environment;
  let previousSceneBackground = scene.background;
  let previousEnvPath = envPath;
  let previousEnvMap;
  let previousFormat;
  const pickLoader = () => {
    const inferredFormat = format || (Array.isArray(files) ? files[0] : files).split(".").pop() == "hdr" ? "hdr" : "ldr";
    if (isCubeMap && inferredFormat == "ldr")
      return CubeTextureLoader;
    if (!isCubeMap && inferredFormat == "ldr")
      return TextureLoader;
    if (isCubeMap && inferredFormat == "hdr")
      return HDRCubeTextureLoader;
    if (!isCubeMap && inferredFormat == "hdr")
      return RGBELoader;
    return TextureLoader;
  };
  const { remember } = useCache();
  const loadEnvironment = async () => {
    var _a;
    if (!renderer)
      throw new Error("Threlte renderer undefined. Component <Environment/> must be a descendant of <Canvas/>.");
    const LoaderType = pickLoader();
    const loader = new LoaderType();
    (_a = loader.setDataType) == null ? void 0 : _a.call(loader, FloatType);
    const filesKey = Array.isArray(files) ? files.join(",") : files;
    const cacheKey = [LoaderType, path, filesKey];
    const texture = await remember(
      async () => {
        return new Promise((resolve, reject) => {
          loader.setPath(path).load(files, (texture2) => {
            resolve(texture2);
          });
        });
      },
      cacheKey
    );
    texture.mapping = isCubeMap ? CubeReflectionMapping : EquirectangularReflectionMapping;
    texture.encoding = encoding || isCubeMap ? LinearEncoding : sRGBEncoding;
    $$invalidate(1, previousEnvMap = texture);
    $$invalidate(8, scene.environment = previousEnvMap, scene);
    if (isBackground)
      $$invalidate(8, scene.background = previousEnvMap, scene);
    invalidate();
    $$invalidate(10, previousFormat = format || void 0);
    $$invalidate(9, previousEnvPath = envPath);
  };
  onDestroy(() => {
    $$invalidate(8, scene.environment = previousSceneEnvironment, scene);
    $$invalidate(8, scene.background = previousSceneBackground, scene);
    if (previousEnvMap)
      previousEnvMap.dispose();
    $$invalidate(0, groundProjection = void 0);
    invalidate("Environment destroyed");
  });
  $$self.$$.on_mount.push(function() {
    if (files === void 0 && !("files" in $$props || $$self.$$.bound[$$self.$$.props["files"]])) {
      console.warn("<Environment> was created without expected prop 'files'");
    }
  });
  const writable_props = ["path", "files", "isBackground", "groundProjection", "format", "encoding"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Environment> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(3, path = $$props2.path);
    if ("files" in $$props2)
      $$invalidate(4, files = $$props2.files);
    if ("isBackground" in $$props2)
      $$invalidate(5, isBackground = $$props2.isBackground);
    if ("groundProjection" in $$props2)
      $$invalidate(0, groundProjection = $$props2.groundProjection);
    if ("format" in $$props2)
      $$invalidate(6, format = $$props2.format);
    if ("encoding" in $$props2)
      $$invalidate(7, encoding = $$props2.encoding);
  };
  $$self.$capture_state = () => ({
    useCache,
    useParent,
    useThrelte,
    onDestroy,
    CubeReflectionMapping,
    CubeTextureLoader,
    EquirectangularReflectionMapping,
    FloatType,
    LinearEncoding,
    sRGBEncoding,
    Texture,
    TextureLoader,
    HDRCubeTextureLoader,
    RGBELoader,
    GroundProjectedSkybox: GroundProjectedSkybox_default,
    path,
    files,
    isBackground,
    groundProjection,
    format,
    encoding,
    isScene,
    globalScene,
    invalidate,
    renderer,
    parent,
    scene,
    previousSceneEnvironment,
    previousSceneBackground,
    previousEnvPath,
    previousEnvMap,
    previousFormat,
    pickLoader,
    remember,
    loadEnvironment,
    envPath,
    isCubeMap,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(3, path = $$props2.path);
    if ("files" in $$props2)
      $$invalidate(4, files = $$props2.files);
    if ("isBackground" in $$props2)
      $$invalidate(5, isBackground = $$props2.isBackground);
    if ("groundProjection" in $$props2)
      $$invalidate(0, groundProjection = $$props2.groundProjection);
    if ("format" in $$props2)
      $$invalidate(6, format = $$props2.format);
    if ("encoding" in $$props2)
      $$invalidate(7, encoding = $$props2.encoding);
    if ("scene" in $$props2)
      $$invalidate(8, scene = $$props2.scene);
    if ("previousSceneEnvironment" in $$props2)
      previousSceneEnvironment = $$props2.previousSceneEnvironment;
    if ("previousSceneBackground" in $$props2)
      previousSceneBackground = $$props2.previousSceneBackground;
    if ("previousEnvPath" in $$props2)
      $$invalidate(9, previousEnvPath = $$props2.previousEnvPath);
    if ("previousEnvMap" in $$props2)
      $$invalidate(1, previousEnvMap = $$props2.previousEnvMap);
    if ("previousFormat" in $$props2)
      $$invalidate(10, previousFormat = $$props2.previousFormat);
    if ("envPath" in $$props2)
      $$invalidate(11, envPath = $$props2.envPath);
    if ("isCubeMap" in $$props2)
      isCubeMap = $$props2.isCubeMap;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*files*/
    16) {
      $:
        isCubeMap = Array.isArray(files);
    }
    if ($$self.$$.dirty & /*path, files*/
    24) {
      $:
        $$invalidate(11, envPath = `${path}${files}`);
    }
    if ($$self.$$.dirty & /*envPath, previousEnvPath, format, previousFormat, previousEnvMap, groundProjection, isBackground, scene*/
    3939) {
      $: {
        if (envPath != previousEnvPath || format != previousFormat) {
          if (previousEnvMap) {
            previousEnvMap.dispose();
          }
          loadEnvironment();
          $$invalidate(0, groundProjection), $$invalidate(11, envPath), $$invalidate(9, previousEnvPath), $$invalidate(6, format), $$invalidate(10, previousFormat), $$invalidate(1, previousEnvMap), $$invalidate(5, isBackground), $$invalidate(8, scene), $$invalidate(3, path), $$invalidate(4, files);
        }
        if (!isBackground && scene.background) {
          $$invalidate(8, scene.background = null, scene);
          invalidate("Removing Environment as scene.background");
        }
        if (isBackground && !scene.background && previousEnvMap) {
          $$invalidate(8, scene.background = previousEnvMap, scene);
          invalidate("Adding Environment as scene.background");
        }
      }
    }
  };
  return [
    groundProjection,
    previousEnvMap,
    parent,
    path,
    files,
    isBackground,
    format,
    encoding,
    scene,
    previousEnvPath,
    previousFormat,
    envPath
  ];
}
var Environment = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      path: 3,
      files: 4,
      isBackground: 5,
      groundProjection: 0,
      format: 6,
      encoding: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Environment",
      options,
      id: create_fragment8.name
    });
  }
  get path() {
    throw new Error_14("<Environment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set path(value) {
    throw new Error_14("<Environment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get files() {
    throw new Error_14("<Environment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error_14("<Environment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isBackground() {
    throw new Error_14("<Environment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isBackground(value) {
    throw new Error_14("<Environment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get groundProjection() {
    throw new Error_14("<Environment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set groundProjection(value) {
    throw new Error_14("<Environment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get format() {
    throw new Error_14("<Environment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set format(value) {
    throw new Error_14("<Environment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get encoding() {
    throw new Error_14("<Environment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set encoding(value) {
    throw new Error_14("<Environment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Environment_default = Environment;

// node_modules/@threlte/extras/dist/components/Grid/Grid.svelte
var get_default_slot_changes5 = (dirty) => ({ ref: dirty & /*ref*/
1 });
var get_default_slot_context5 = (ctx) => ({ ref: (
  /*ref*/
  ctx[0]
) });
function create_default_slot7(ctx) {
  let t_planegeometry;
  let t2;
  let current;
  t_planegeometry = new T.PlaneGeometry({
    props: {
      args: typeof /*gridSize*/
      ctx[1] == "number" ? [
        /*gridSize*/
        ctx[1],
        /*gridSize*/
        ctx[1]
      ] : (
        /*gridSize*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_default_slot_context5
  );
  const block = {
    c: function create() {
      create_component(t_planegeometry.$$.fragment);
      t2 = space();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      claim_component(t_planegeometry.$$.fragment, nodes);
      t2 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_planegeometry, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_planegeometry_changes = {};
      if (dirty & /*gridSize*/
      2)
        t_planegeometry_changes.args = typeof /*gridSize*/
        ctx2[1] == "number" ? [
          /*gridSize*/
          ctx2[1],
          /*gridSize*/
          ctx2[1]
        ] : (
          /*gridSize*/
          ctx2[1]
        );
      t_planegeometry.$set(t_planegeometry_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        1048577)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_default_slot_changes5
            ),
            get_default_slot_context5
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t_planegeometry.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_planegeometry.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_planegeometry, detaching);
      if (detaching)
        detach_dev(t2);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: "(134:0) <T.Mesh bind:this={$component} bind:ref {material} frustumCulled={false} {...$$restProps} let:ref>",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let t_mesh;
  let updating_ref;
  let current;
  const t_mesh_spread_levels = [
    { material: (
      /*material*/
      ctx[2]
    ) },
    { frustumCulled: false },
    /*$$restProps*/
    ctx[5]
  ];
  function t_mesh_ref_binding(value) {
    ctx[19](value);
  }
  let t_mesh_props = {
    $$slots: {
      default: [create_default_slot7, ({ ref }) => ({ 0: ref }), ({ ref }) => ref ? 1 : 0]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_mesh_spread_levels.length; i += 1) {
    t_mesh_props = assign(t_mesh_props, t_mesh_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[0] !== void 0
  ) {
    t_mesh_props.ref = /*ref*/
    ctx[0];
  }
  t_mesh = new T.Mesh({ props: t_mesh_props, $$inline: true });
  ctx[18](t_mesh);
  binding_callbacks.push(() => bind(t_mesh, "ref", t_mesh_ref_binding));
  const block = {
    c: function create() {
      create_component(t_mesh.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_mesh.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_mesh, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_mesh_changes = dirty & /*material, $$restProps*/
      36 ? get_spread_update(t_mesh_spread_levels, [
        dirty & /*material*/
        4 && { material: (
          /*material*/
          ctx2[2]
        ) },
        t_mesh_spread_levels[1],
        dirty & /*$$restProps*/
        32 && get_spread_object(
          /*$$restProps*/
          ctx2[5]
        )
      ]) : {};
      if (dirty & /*$$scope, ref, gridSize*/
      1048579) {
        t_mesh_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_ref && dirty & /*ref*/
      1) {
        updating_ref = true;
        t_mesh_changes.ref = /*ref*/
        ctx2[0];
        add_flush_callback(() => updating_ref = false);
      }
      t_mesh.$set(t_mesh_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t_mesh.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_mesh.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[18](null);
      destroy_component(t_mesh, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let material;
  const omit_props_names = [
    "cellColor",
    "sectionColor",
    "cellSize",
    "sectionSize",
    "axes",
    "gridSize",
    "followCamera",
    "infiniteGrid",
    "fadeDistance",
    "fadeStrength",
    "cellThickness",
    "sectionThickness",
    "ref"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Grid", slots, ["default"]);
  let { cellColor = "#000000" } = $$props;
  let { sectionColor = "#0000ee" } = $$props;
  let { cellSize = 1 } = $$props;
  let { sectionSize = 10 } = $$props;
  let { axes = "xzy" } = $$props;
  let { gridSize = [20, 20] } = $$props;
  let { followCamera = false } = $$props;
  let { infiniteGrid = false } = $$props;
  let { fadeDistance = 100 } = $$props;
  let { fadeStrength = 1 } = $$props;
  let { cellThickness = 1 } = $$props;
  let { sectionThickness = 2 } = $$props;
  let { ref } = $$props;
  const { invalidate } = useThrelte();
  const makeGridMaterial = (axes2) => {
    return new ShaderMaterial({
      side: DoubleSide,
      uniforms: {
        uSize1: { value: cellSize },
        uSize2: { value: sectionSize },
        uColor1: { value: new Color(cellColor) },
        uColor2: { value: new Color(sectionColor) },
        uFadeDistance: { value: fadeDistance },
        uFadeStrength: { value: fadeStrength },
        uThickness1: { value: 1 },
        uThickness2: { value: 1 },
        uInfiniteGrid: { value: infiniteGrid ? 1 : 0 },
        uFollowCamera: { value: 0 }
      },
      transparent: true,
      vertexShader: `
      varying vec3 worldPosition;
      uniform float uFadeDistance;
      uniform float uInfiniteGrid;
      uniform float uFollowCamera;

      void main() {

        vec3 pos = position.${axes2} * (1. + uFadeDistance * uInfiniteGrid);
        pos.${axes2.slice(0, 2)} += (cameraPosition.${axes2.slice(0, 2)} * uFollowCamera);

        worldPosition = pos;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);

      }`,
      fragmentShader: `
      varying vec3 worldPosition;
      uniform float uSize1;
      uniform float uSize2;
      uniform vec3 uColor1;
      uniform vec3 uColor2;
      uniform float uFadeDistance;
      uniform float uFadeStrength;
      uniform float uThickness1;
      uniform float uThickness2;
      uniform float uInfiniteGrid;

      float getGrid(float size, float thickness) {

        vec2 r = worldPosition.${axes2.slice(0, 2)} / size;

        vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
        float line = min(grid.x, grid.y) + 1. - thickness;

        return 1.0 - min(line, 1.);
      }

      void main() {

        float g1 = getGrid(uSize1, uThickness1);
        float g2 = getGrid(uSize2, uThickness2);

        float d = 1.0 - min(distance(cameraPosition.${axes2.slice(0, 2)}, worldPosition.${axes2.slice(0, 2)}) / uFadeDistance, 1.);
        vec3 color = mix(uColor1, uColor2, min(1.,uThickness2*g2));

        gl_FragColor = vec4(color, (g1 + g2) * pow(d,uFadeStrength));
        gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);

        if(gl_FragColor.a <= 0.0)
          discard;
        #include <tonemapping_fragment>
        #include <encodings_fragment>
      }
       `,
      extensions: { derivatives: true }
    });
  };
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(3, $component = value));
  $$self.$$.on_mount.push(function() {
    if (ref === void 0 && !("ref" in $$props || $$self.$$.bound[$$self.$$.props["ref"]])) {
      console.warn("<Grid> was created without expected prop 'ref'");
    }
  });
  function t_mesh_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  function t_mesh_ref_binding(value) {
    ref = value;
    $$invalidate(0, ref);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("cellColor" in $$new_props)
      $$invalidate(6, cellColor = $$new_props.cellColor);
    if ("sectionColor" in $$new_props)
      $$invalidate(7, sectionColor = $$new_props.sectionColor);
    if ("cellSize" in $$new_props)
      $$invalidate(8, cellSize = $$new_props.cellSize);
    if ("sectionSize" in $$new_props)
      $$invalidate(9, sectionSize = $$new_props.sectionSize);
    if ("axes" in $$new_props)
      $$invalidate(10, axes = $$new_props.axes);
    if ("gridSize" in $$new_props)
      $$invalidate(1, gridSize = $$new_props.gridSize);
    if ("followCamera" in $$new_props)
      $$invalidate(11, followCamera = $$new_props.followCamera);
    if ("infiniteGrid" in $$new_props)
      $$invalidate(12, infiniteGrid = $$new_props.infiniteGrid);
    if ("fadeDistance" in $$new_props)
      $$invalidate(13, fadeDistance = $$new_props.fadeDistance);
    if ("fadeStrength" in $$new_props)
      $$invalidate(14, fadeStrength = $$new_props.fadeStrength);
    if ("cellThickness" in $$new_props)
      $$invalidate(15, cellThickness = $$new_props.cellThickness);
    if ("sectionThickness" in $$new_props)
      $$invalidate(16, sectionThickness = $$new_props.sectionThickness);
    if ("ref" in $$new_props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useThrelte,
    T,
    forwardEventHandlers,
    Color,
    ShaderMaterial,
    DoubleSide,
    cellColor,
    sectionColor,
    cellSize,
    sectionSize,
    axes,
    gridSize,
    followCamera,
    infiniteGrid,
    fadeDistance,
    fadeStrength,
    cellThickness,
    sectionThickness,
    ref,
    invalidate,
    makeGridMaterial,
    component,
    material,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("cellColor" in $$props)
      $$invalidate(6, cellColor = $$new_props.cellColor);
    if ("sectionColor" in $$props)
      $$invalidate(7, sectionColor = $$new_props.sectionColor);
    if ("cellSize" in $$props)
      $$invalidate(8, cellSize = $$new_props.cellSize);
    if ("sectionSize" in $$props)
      $$invalidate(9, sectionSize = $$new_props.sectionSize);
    if ("axes" in $$props)
      $$invalidate(10, axes = $$new_props.axes);
    if ("gridSize" in $$props)
      $$invalidate(1, gridSize = $$new_props.gridSize);
    if ("followCamera" in $$props)
      $$invalidate(11, followCamera = $$new_props.followCamera);
    if ("infiniteGrid" in $$props)
      $$invalidate(12, infiniteGrid = $$new_props.infiniteGrid);
    if ("fadeDistance" in $$props)
      $$invalidate(13, fadeDistance = $$new_props.fadeDistance);
    if ("fadeStrength" in $$props)
      $$invalidate(14, fadeStrength = $$new_props.fadeStrength);
    if ("cellThickness" in $$props)
      $$invalidate(15, cellThickness = $$new_props.cellThickness);
    if ("sectionThickness" in $$props)
      $$invalidate(16, sectionThickness = $$new_props.sectionThickness);
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("material" in $$props)
      $$invalidate(2, material = $$new_props.material);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*axes*/
    1024) {
      $:
        $$invalidate(2, material = makeGridMaterial(axes));
    }
    if ($$self.$$.dirty & /*axes, cellSize, sectionSize, cellColor, sectionColor, fadeDistance, fadeStrength, cellThickness, sectionThickness, followCamera, infiniteGrid*/
    131008) {
      $: {
        axes;
        $$invalidate(2, material.uniforms.uSize1 = { value: cellSize }, material);
        $$invalidate(2, material.uniforms.uSize2 = { value: sectionSize }, material);
        $$invalidate(2, material.uniforms.uColor1 = { value: new Color(cellColor) }, material);
        $$invalidate(2, material.uniforms.uColor2 = { value: new Color(sectionColor) }, material);
        $$invalidate(2, material.uniforms.uFadeDistance = { value: fadeDistance }, material);
        $$invalidate(2, material.uniforms.uFadeStrength = { value: fadeStrength }, material);
        $$invalidate(2, material.uniforms.uThickness1 = { value: cellThickness }, material);
        $$invalidate(2, material.uniforms.uThickness2 = { value: sectionThickness }, material);
        $$invalidate(2, material.uniforms.uFollowCamera = { value: followCamera ? 1 : 0 }, material);
        $$invalidate(2, material.uniforms.uInfiniteGrid = { value: infiniteGrid ? 1 : 0 }, material);
        invalidate("Grid uniforms changed");
      }
    }
    if ($$self.$$.dirty & /*material*/
    4) {
      $:
        material && invalidate("Grid axes changed");
    }
  };
  return [
    ref,
    gridSize,
    material,
    $component,
    component,
    $$restProps,
    cellColor,
    sectionColor,
    cellSize,
    sectionSize,
    axes,
    followCamera,
    infiniteGrid,
    fadeDistance,
    fadeStrength,
    cellThickness,
    sectionThickness,
    slots,
    t_mesh_binding,
    t_mesh_ref_binding,
    $$scope
  ];
}
var Grid = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      cellColor: 6,
      sectionColor: 7,
      cellSize: 8,
      sectionSize: 9,
      axes: 10,
      gridSize: 1,
      followCamera: 11,
      infiniteGrid: 12,
      fadeDistance: 13,
      fadeStrength: 14,
      cellThickness: 15,
      sectionThickness: 16,
      ref: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Grid",
      options,
      id: create_fragment9.name
    });
  }
  get cellColor() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cellColor(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sectionColor() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sectionColor(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cellSize() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cellSize(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sectionSize() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sectionSize(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get axes() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set axes(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gridSize() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gridSize(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get followCamera() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set followCamera(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get infiniteGrid() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set infiniteGrid(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fadeDistance() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fadeDistance(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fadeStrength() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fadeStrength(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cellThickness() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cellThickness(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sectionThickness() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sectionThickness(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Grid_default = Grid;

// node_modules/@threlte/extras/dist/components/controls/TransformControls/TransformControls.svelte
var import_lodash = __toESM(require_lodash());

// node_modules/three/examples/jsm/controls/TransformControls.js
var _raycaster = new Raycaster();
var _tempVector = new Vector3();
var _tempVector2 = new Vector3();
var _tempQuaternion = new Quaternion();
var _unit = {
  X: new Vector3(1, 0, 0),
  Y: new Vector3(0, 1, 0),
  Z: new Vector3(0, 0, 1)
};
var _changeEvent = { type: "change" };
var _mouseDownEvent = { type: "mouseDown" };
var _mouseUpEvent = { type: "mouseUp", mode: null };
var _objectChangeEvent = { type: "objectChange" };
var TransformControls = class extends Object3D {
  constructor(camera, domElement) {
    super();
    if (domElement === void 0) {
      console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.');
      domElement = document;
    }
    this.isTransformControls = true;
    this.visible = false;
    this.domElement = domElement;
    this.domElement.style.touchAction = "none";
    const _gizmo = new TransformControlsGizmo();
    this._gizmo = _gizmo;
    this.add(_gizmo);
    const _plane = new TransformControlsPlane();
    this._plane = _plane;
    this.add(_plane);
    const scope = this;
    function defineProperty(propName, defaultValue) {
      let propValue = defaultValue;
      Object.defineProperty(scope, propName, {
        get: function() {
          return propValue !== void 0 ? propValue : defaultValue;
        },
        set: function(value) {
          if (propValue !== value) {
            propValue = value;
            _plane[propName] = value;
            _gizmo[propName] = value;
            scope.dispatchEvent({ type: propName + "-changed", value });
            scope.dispatchEvent(_changeEvent);
          }
        }
      });
      scope[propName] = defaultValue;
      _plane[propName] = defaultValue;
      _gizmo[propName] = defaultValue;
    }
    defineProperty("camera", camera);
    defineProperty("object", void 0);
    defineProperty("enabled", true);
    defineProperty("axis", null);
    defineProperty("mode", "translate");
    defineProperty("translationSnap", null);
    defineProperty("rotationSnap", null);
    defineProperty("scaleSnap", null);
    defineProperty("space", "world");
    defineProperty("size", 1);
    defineProperty("dragging", false);
    defineProperty("showX", true);
    defineProperty("showY", true);
    defineProperty("showZ", true);
    const worldPosition = new Vector3();
    const worldPositionStart = new Vector3();
    const worldQuaternion = new Quaternion();
    const worldQuaternionStart = new Quaternion();
    const cameraPosition = new Vector3();
    const cameraQuaternion = new Quaternion();
    const pointStart = new Vector3();
    const pointEnd = new Vector3();
    const rotationAxis = new Vector3();
    const rotationAngle = 0;
    const eye = new Vector3();
    defineProperty("worldPosition", worldPosition);
    defineProperty("worldPositionStart", worldPositionStart);
    defineProperty("worldQuaternion", worldQuaternion);
    defineProperty("worldQuaternionStart", worldQuaternionStart);
    defineProperty("cameraPosition", cameraPosition);
    defineProperty("cameraQuaternion", cameraQuaternion);
    defineProperty("pointStart", pointStart);
    defineProperty("pointEnd", pointEnd);
    defineProperty("rotationAxis", rotationAxis);
    defineProperty("rotationAngle", rotationAngle);
    defineProperty("eye", eye);
    this._offset = new Vector3();
    this._startNorm = new Vector3();
    this._endNorm = new Vector3();
    this._cameraScale = new Vector3();
    this._parentPosition = new Vector3();
    this._parentQuaternion = new Quaternion();
    this._parentQuaternionInv = new Quaternion();
    this._parentScale = new Vector3();
    this._worldScaleStart = new Vector3();
    this._worldQuaternionInv = new Quaternion();
    this._worldScale = new Vector3();
    this._positionStart = new Vector3();
    this._quaternionStart = new Quaternion();
    this._scaleStart = new Vector3();
    this._getPointer = getPointer.bind(this);
    this._onPointerDown = onPointerDown.bind(this);
    this._onPointerHover = onPointerHover.bind(this);
    this._onPointerMove = onPointerMove.bind(this);
    this._onPointerUp = onPointerUp.bind(this);
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointermove", this._onPointerHover);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  // updateMatrixWorld  updates key transformation variables
  updateMatrixWorld() {
    if (this.object !== void 0) {
      this.object.updateMatrixWorld();
      if (this.object.parent === null) {
        console.error("TransformControls: The attached 3D object must be a part of the scene graph.");
      } else {
        this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale);
      }
      this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale);
      this._parentQuaternionInv.copy(this._parentQuaternion).invert();
      this._worldQuaternionInv.copy(this.worldQuaternion).invert();
    }
    this.camera.updateMatrixWorld();
    this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale);
    if (this.camera.isOrthographicCamera) {
      this.camera.getWorldDirection(this.eye).negate();
    } else {
      this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize();
    }
    super.updateMatrixWorld(this);
  }
  pointerHover(pointer) {
    if (this.object === void 0 || this.dragging === true)
      return;
    _raycaster.setFromCamera(pointer, this.camera);
    const intersect = intersectObjectWithRay(this._gizmo.picker[this.mode], _raycaster);
    if (intersect) {
      this.axis = intersect.object.name;
    } else {
      this.axis = null;
    }
  }
  pointerDown(pointer) {
    if (this.object === void 0 || this.dragging === true || pointer.button !== 0)
      return;
    if (this.axis !== null) {
      _raycaster.setFromCamera(pointer, this.camera);
      const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
      if (planeIntersect) {
        this.object.updateMatrixWorld();
        this.object.parent.updateMatrixWorld();
        this._positionStart.copy(this.object.position);
        this._quaternionStart.copy(this.object.quaternion);
        this._scaleStart.copy(this.object.scale);
        this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart);
        this.pointStart.copy(planeIntersect.point).sub(this.worldPositionStart);
      }
      this.dragging = true;
      _mouseDownEvent.mode = this.mode;
      this.dispatchEvent(_mouseDownEvent);
    }
  }
  pointerMove(pointer) {
    const axis = this.axis;
    const mode = this.mode;
    const object = this.object;
    let space2 = this.space;
    if (mode === "scale") {
      space2 = "local";
    } else if (axis === "E" || axis === "XYZE" || axis === "XYZ") {
      space2 = "world";
    }
    if (object === void 0 || axis === null || this.dragging === false || pointer.button !== -1)
      return;
    _raycaster.setFromCamera(pointer, this.camera);
    const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
    if (!planeIntersect)
      return;
    this.pointEnd.copy(planeIntersect.point).sub(this.worldPositionStart);
    if (mode === "translate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      if (space2 === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._worldQuaternionInv);
      }
      if (axis.indexOf("X") === -1)
        this._offset.x = 0;
      if (axis.indexOf("Y") === -1)
        this._offset.y = 0;
      if (axis.indexOf("Z") === -1)
        this._offset.z = 0;
      if (space2 === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale);
      } else {
        this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale);
      }
      object.position.copy(this._offset).add(this._positionStart);
      if (this.translationSnap) {
        if (space2 === "local") {
          object.position.applyQuaternion(_tempQuaternion.copy(this._quaternionStart).invert());
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          object.position.applyQuaternion(this._quaternionStart);
        }
        if (space2 === "world") {
          if (object.parent) {
            object.position.add(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          if (object.parent) {
            object.position.sub(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
        }
      }
    } else if (mode === "scale") {
      if (axis.search("XYZ") !== -1) {
        let d = this.pointEnd.length() / this.pointStart.length();
        if (this.pointEnd.dot(this.pointStart) < 0)
          d *= -1;
        _tempVector2.set(d, d, d);
      } else {
        _tempVector.copy(this.pointStart);
        _tempVector2.copy(this.pointEnd);
        _tempVector.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.divide(_tempVector);
        if (axis.search("X") === -1) {
          _tempVector2.x = 1;
        }
        if (axis.search("Y") === -1) {
          _tempVector2.y = 1;
        }
        if (axis.search("Z") === -1) {
          _tempVector2.z = 1;
        }
      }
      object.scale.copy(this._scaleStart).multiply(_tempVector2);
      if (this.scaleSnap) {
        if (axis.search("X") !== -1) {
          object.scale.x = Math.round(object.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Y") !== -1) {
          object.scale.y = Math.round(object.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Z") !== -1) {
          object.scale.z = Math.round(object.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
      }
    } else if (mode === "rotate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      const ROTATION_SPEED = 20 / this.worldPosition.distanceTo(_tempVector.setFromMatrixPosition(this.camera.matrixWorld));
      if (axis === "E") {
        this.rotationAxis.copy(this.eye);
        this.rotationAngle = this.pointEnd.angleTo(this.pointStart);
        this._startNorm.copy(this.pointStart).normalize();
        this._endNorm.copy(this.pointEnd).normalize();
        this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1;
      } else if (axis === "XYZE") {
        this.rotationAxis.copy(this._offset).cross(this.eye).normalize();
        this.rotationAngle = this._offset.dot(_tempVector.copy(this.rotationAxis).cross(this.eye)) * ROTATION_SPEED;
      } else if (axis === "X" || axis === "Y" || axis === "Z") {
        this.rotationAxis.copy(_unit[axis]);
        _tempVector.copy(_unit[axis]);
        if (space2 === "local") {
          _tempVector.applyQuaternion(this.worldQuaternion);
        }
        this.rotationAngle = this._offset.dot(_tempVector.cross(this.eye).normalize()) * ROTATION_SPEED;
      }
      if (this.rotationSnap)
        this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap;
      if (space2 === "local" && axis !== "E" && axis !== "XYZE") {
        object.quaternion.copy(this._quaternionStart);
        object.quaternion.multiply(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize();
      } else {
        this.rotationAxis.applyQuaternion(this._parentQuaternionInv);
        object.quaternion.copy(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle));
        object.quaternion.multiply(this._quaternionStart).normalize();
      }
    }
    this.dispatchEvent(_changeEvent);
    this.dispatchEvent(_objectChangeEvent);
  }
  pointerUp(pointer) {
    if (pointer.button !== 0)
      return;
    if (this.dragging && this.axis !== null) {
      _mouseUpEvent.mode = this.mode;
      this.dispatchEvent(_mouseUpEvent);
    }
    this.dragging = false;
    this.axis = null;
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointermove", this._onPointerHover);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.traverse(function(child) {
      if (child.geometry)
        child.geometry.dispose();
      if (child.material)
        child.material.dispose();
    });
  }
  // Set current object
  attach(object) {
    this.object = object;
    this.visible = true;
    return this;
  }
  // Detach from object
  detach() {
    this.object = void 0;
    this.visible = false;
    this.axis = null;
    return this;
  }
  reset() {
    if (!this.enabled)
      return;
    if (this.dragging) {
      this.object.position.copy(this._positionStart);
      this.object.quaternion.copy(this._quaternionStart);
      this.object.scale.copy(this._scaleStart);
      this.dispatchEvent(_changeEvent);
      this.dispatchEvent(_objectChangeEvent);
      this.pointStart.copy(this.pointEnd);
    }
  }
  getRaycaster() {
    return _raycaster;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(mode) {
    this.mode = mode;
  }
  setTranslationSnap(translationSnap) {
    this.translationSnap = translationSnap;
  }
  setRotationSnap(rotationSnap) {
    this.rotationSnap = rotationSnap;
  }
  setScaleSnap(scaleSnap) {
    this.scaleSnap = scaleSnap;
  }
  setSize(size) {
    this.size = size;
  }
  setSpace(space2) {
    this.space = space2;
  }
};
function getPointer(event) {
  if (this.domElement.ownerDocument.pointerLockElement) {
    return {
      x: 0,
      y: 0,
      button: event.button
    };
  } else {
    const rect = this.domElement.getBoundingClientRect();
    return {
      x: (event.clientX - rect.left) / rect.width * 2 - 1,
      y: -(event.clientY - rect.top) / rect.height * 2 + 1,
      button: event.button
    };
  }
}
function onPointerHover(event) {
  if (!this.enabled)
    return;
  switch (event.pointerType) {
    case "mouse":
    case "pen":
      this.pointerHover(this._getPointer(event));
      break;
  }
}
function onPointerDown(event) {
  if (!this.enabled)
    return;
  if (!document.pointerLockElement) {
    this.domElement.setPointerCapture(event.pointerId);
  }
  this.domElement.addEventListener("pointermove", this._onPointerMove);
  this.pointerHover(this._getPointer(event));
  this.pointerDown(this._getPointer(event));
}
function onPointerMove(event) {
  if (!this.enabled)
    return;
  this.pointerMove(this._getPointer(event));
}
function onPointerUp(event) {
  if (!this.enabled)
    return;
  this.domElement.releasePointerCapture(event.pointerId);
  this.domElement.removeEventListener("pointermove", this._onPointerMove);
  this.pointerUp(this._getPointer(event));
}
function intersectObjectWithRay(object, raycaster, includeInvisible) {
  const allIntersections = raycaster.intersectObject(object, true);
  for (let i = 0; i < allIntersections.length; i++) {
    if (allIntersections[i].object.visible || includeInvisible) {
      return allIntersections[i];
    }
  }
  return false;
}
var _tempEuler = new Euler();
var _alignVector = new Vector3(0, 1, 0);
var _zeroVector = new Vector3(0, 0, 0);
var _lookAtMatrix = new Matrix4();
var _tempQuaternion2 = new Quaternion();
var _identityQuaternion = new Quaternion();
var _dirVector = new Vector3();
var _tempMatrix = new Matrix4();
var _unitX = new Vector3(1, 0, 0);
var _unitY = new Vector3(0, 1, 0);
var _unitZ = new Vector3(0, 0, 1);
var _v1 = new Vector3();
var _v2 = new Vector3();
var _v3 = new Vector3();
var TransformControlsGizmo = class extends Object3D {
  constructor() {
    super();
    this.isTransformControlsGizmo = true;
    this.type = "TransformControlsGizmo";
    const gizmoMaterial = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const gizmoLineMaterial = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const matInvisible = gizmoMaterial.clone();
    matInvisible.opacity = 0.15;
    const matHelper = gizmoLineMaterial.clone();
    matHelper.opacity = 0.5;
    const matRed = gizmoMaterial.clone();
    matRed.color.setHex(16711680);
    const matGreen = gizmoMaterial.clone();
    matGreen.color.setHex(65280);
    const matBlue = gizmoMaterial.clone();
    matBlue.color.setHex(255);
    const matRedTransparent = gizmoMaterial.clone();
    matRedTransparent.color.setHex(16711680);
    matRedTransparent.opacity = 0.5;
    const matGreenTransparent = gizmoMaterial.clone();
    matGreenTransparent.color.setHex(65280);
    matGreenTransparent.opacity = 0.5;
    const matBlueTransparent = gizmoMaterial.clone();
    matBlueTransparent.color.setHex(255);
    matBlueTransparent.opacity = 0.5;
    const matWhiteTransparent = gizmoMaterial.clone();
    matWhiteTransparent.opacity = 0.25;
    const matYellowTransparent = gizmoMaterial.clone();
    matYellowTransparent.color.setHex(16776960);
    matYellowTransparent.opacity = 0.25;
    const matYellow = gizmoMaterial.clone();
    matYellow.color.setHex(16776960);
    const matGray = gizmoMaterial.clone();
    matGray.color.setHex(7895160);
    const arrowGeometry = new CylinderGeometry(0, 0.04, 0.1, 12);
    arrowGeometry.translate(0, 0.05, 0);
    const scaleHandleGeometry = new BoxGeometry(0.08, 0.08, 0.08);
    scaleHandleGeometry.translate(0, 0.04, 0);
    const lineGeometry = new BufferGeometry();
    lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
    const lineGeometry2 = new CylinderGeometry(75e-4, 75e-4, 0.5, 3);
    lineGeometry2.translate(0, 0.25, 0);
    function CircleGeometry(radius, arc) {
      const geometry = new TorusGeometry(radius, 75e-4, 3, 64, arc * Math.PI * 2);
      geometry.rotateY(Math.PI / 2);
      geometry.rotateX(Math.PI / 2);
      return geometry;
    }
    function TranslateHelperGeometry() {
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3));
      return geometry;
    }
    const gizmoTranslate = {
      X: [
        [new Mesh(arrowGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(arrowGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(arrowGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(arrowGeometry, matGreen), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Mesh(lineGeometry2, matGreen)]
      ],
      Z: [
        [new Mesh(arrowGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(arrowGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.1, 0), matWhiteTransparent.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const pickerTranslate = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.2, 0), matInvisible)]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const helperTranslate = {
      START: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      END: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      DELTA: [
        [new Line(TranslateHelperGeometry(), matHelper), null, null, null, "helper"]
      ],
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    const gizmoRotate = {
      XYZE: [
        [new Mesh(CircleGeometry(0.5, 1), matGray), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Mesh(CircleGeometry(0.5, 0.5), matRed)]
      ],
      Y: [
        [new Mesh(CircleGeometry(0.5, 0.5), matGreen), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Mesh(CircleGeometry(0.5, 0.5), matBlue), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Mesh(CircleGeometry(0.75, 1), matYellowTransparent), null, [0, Math.PI / 2, 0]]
      ]
    };
    const helperRotate = {
      AXIS: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    };
    const pickerRotate = {
      XYZE: [
        [new Mesh(new SphereGeometry(0.25, 10, 8), matInvisible)]
      ],
      X: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Mesh(new TorusGeometry(0.75, 0.1, 2, 24), matInvisible)]
      ]
    };
    const gizmoScale = {
      X: [
        [new Mesh(scaleHandleGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(scaleHandleGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(scaleHandleGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(lineGeometry2, matGreen)],
        [new Mesh(scaleHandleGeometry, matGreen), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.1, 0.1, 0.1), matWhiteTransparent.clone())]
      ]
    };
    const pickerScale = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.2), matInvisible), [0, 0, 0]]
      ]
    };
    const helperScale = {
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function setupGizmo(gizmoMap) {
      const gizmo = new Object3D();
      for (const name in gizmoMap) {
        for (let i = gizmoMap[name].length; i--; ) {
          const object = gizmoMap[name][i][0].clone();
          const position = gizmoMap[name][i][1];
          const rotation = gizmoMap[name][i][2];
          const scale = gizmoMap[name][i][3];
          const tag = gizmoMap[name][i][4];
          object.name = name;
          object.tag = tag;
          if (position) {
            object.position.set(position[0], position[1], position[2]);
          }
          if (rotation) {
            object.rotation.set(rotation[0], rotation[1], rotation[2]);
          }
          if (scale) {
            object.scale.set(scale[0], scale[1], scale[2]);
          }
          object.updateMatrix();
          const tempGeometry = object.geometry.clone();
          tempGeometry.applyMatrix4(object.matrix);
          object.geometry = tempGeometry;
          object.renderOrder = Infinity;
          object.position.set(0, 0, 0);
          object.rotation.set(0, 0, 0);
          object.scale.set(1, 1, 1);
          gizmo.add(object);
        }
      }
      return gizmo;
    }
    this.gizmo = {};
    this.picker = {};
    this.helper = {};
    this.add(this.gizmo["translate"] = setupGizmo(gizmoTranslate));
    this.add(this.gizmo["rotate"] = setupGizmo(gizmoRotate));
    this.add(this.gizmo["scale"] = setupGizmo(gizmoScale));
    this.add(this.picker["translate"] = setupGizmo(pickerTranslate));
    this.add(this.picker["rotate"] = setupGizmo(pickerRotate));
    this.add(this.picker["scale"] = setupGizmo(pickerScale));
    this.add(this.helper["translate"] = setupGizmo(helperTranslate));
    this.add(this.helper["rotate"] = setupGizmo(helperRotate));
    this.add(this.helper["scale"] = setupGizmo(helperScale));
    this.picker["translate"].visible = false;
    this.picker["rotate"].visible = false;
    this.picker["scale"].visible = false;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(force) {
    const space2 = this.mode === "scale" ? "local" : this.space;
    const quaternion = space2 === "local" ? this.worldQuaternion : _identityQuaternion;
    this.gizmo["translate"].visible = this.mode === "translate";
    this.gizmo["rotate"].visible = this.mode === "rotate";
    this.gizmo["scale"].visible = this.mode === "scale";
    this.helper["translate"].visible = this.mode === "translate";
    this.helper["rotate"].visible = this.mode === "rotate";
    this.helper["scale"].visible = this.mode === "scale";
    let handles = [];
    handles = handles.concat(this.picker[this.mode].children);
    handles = handles.concat(this.gizmo[this.mode].children);
    handles = handles.concat(this.helper[this.mode].children);
    for (let i = 0; i < handles.length; i++) {
      const handle = handles[i];
      handle.visible = true;
      handle.rotation.set(0, 0, 0);
      handle.position.copy(this.worldPosition);
      let factor;
      if (this.camera.isOrthographicCamera) {
        factor = (this.camera.top - this.camera.bottom) / this.camera.zoom;
      } else {
        factor = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7);
      }
      handle.scale.set(1, 1, 1).multiplyScalar(factor * this.size / 4);
      if (handle.tag === "helper") {
        handle.visible = false;
        if (handle.name === "AXIS") {
          handle.visible = !!this.axis;
          if (this.axis === "X") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Y") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, Math.PI / 2));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Z") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "XYZE") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            _alignVector.copy(this.rotationAxis);
            handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(_zeroVector, _alignVector, _unitY));
            handle.quaternion.multiply(_tempQuaternion);
            handle.visible = this.dragging;
          }
          if (this.axis === "E") {
            handle.visible = false;
          }
        } else if (handle.name === "START") {
          handle.position.copy(this.worldPositionStart);
          handle.visible = this.dragging;
        } else if (handle.name === "END") {
          handle.position.copy(this.worldPosition);
          handle.visible = this.dragging;
        } else if (handle.name === "DELTA") {
          handle.position.copy(this.worldPositionStart);
          handle.quaternion.copy(this.worldQuaternionStart);
          _tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1);
          _tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert());
          handle.scale.copy(_tempVector);
          handle.visible = this.dragging;
        } else {
          handle.quaternion.copy(quaternion);
          if (this.dragging) {
            handle.position.copy(this.worldPositionStart);
          } else {
            handle.position.copy(this.worldPosition);
          }
          if (this.axis) {
            handle.visible = this.axis.search(handle.name) !== -1;
          }
        }
        continue;
      }
      handle.quaternion.copy(quaternion);
      if (this.mode === "translate" || this.mode === "scale") {
        const AXIS_HIDE_THRESHOLD = 0.99;
        const PLANE_HIDE_THRESHOLD = 0.2;
        if (handle.name === "X") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Y") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Z") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XY") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "YZ") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XZ") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
      } else if (this.mode === "rotate") {
        _tempQuaternion2.copy(quaternion);
        _alignVector.copy(this.eye).applyQuaternion(_tempQuaternion.copy(quaternion).invert());
        if (handle.name.search("E") !== -1) {
          handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(this.eye, _zeroVector, _unitY));
        }
        if (handle.name === "X") {
          _tempQuaternion.setFromAxisAngle(_unitX, Math.atan2(-_alignVector.y, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Y") {
          _tempQuaternion.setFromAxisAngle(_unitY, Math.atan2(_alignVector.x, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Z") {
          _tempQuaternion.setFromAxisAngle(_unitZ, Math.atan2(_alignVector.y, _alignVector.x));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
      }
      handle.visible = handle.visible && (handle.name.indexOf("X") === -1 || this.showX);
      handle.visible = handle.visible && (handle.name.indexOf("Y") === -1 || this.showY);
      handle.visible = handle.visible && (handle.name.indexOf("Z") === -1 || this.showZ);
      handle.visible = handle.visible && (handle.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ);
      handle.material._color = handle.material._color || handle.material.color.clone();
      handle.material._opacity = handle.material._opacity || handle.material.opacity;
      handle.material.color.copy(handle.material._color);
      handle.material.opacity = handle.material._opacity;
      if (this.enabled && this.axis) {
        if (handle.name === this.axis) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        } else if (this.axis.split("").some(function(a) {
          return handle.name === a;
        })) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        }
      }
    }
    super.updateMatrixWorld(force);
  }
};
var TransformControlsPlane = class extends Mesh {
  constructor() {
    super(
      new PlaneGeometry(1e5, 1e5, 2, 2),
      new MeshBasicMaterial({ visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false })
    );
    this.isTransformControlsPlane = true;
    this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(force) {
    let space2 = this.space;
    this.position.copy(this.worldPosition);
    if (this.mode === "scale")
      space2 = "local";
    _v1.copy(_unitX).applyQuaternion(space2 === "local" ? this.worldQuaternion : _identityQuaternion);
    _v2.copy(_unitY).applyQuaternion(space2 === "local" ? this.worldQuaternion : _identityQuaternion);
    _v3.copy(_unitZ).applyQuaternion(space2 === "local" ? this.worldQuaternion : _identityQuaternion);
    _alignVector.copy(_v2);
    switch (this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            _alignVector.copy(this.eye).cross(_v1);
            _dirVector.copy(_v1).cross(_alignVector);
            break;
          case "Y":
            _alignVector.copy(this.eye).cross(_v2);
            _dirVector.copy(_v2).cross(_alignVector);
            break;
          case "Z":
            _alignVector.copy(this.eye).cross(_v3);
            _dirVector.copy(_v3).cross(_alignVector);
            break;
          case "XY":
            _dirVector.copy(_v3);
            break;
          case "YZ":
            _dirVector.copy(_v1);
            break;
          case "XZ":
            _alignVector.copy(_v3);
            _dirVector.copy(_v2);
            break;
          case "XYZ":
          case "E":
            _dirVector.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        _dirVector.set(0, 0, 0);
    }
    if (_dirVector.length() === 0) {
      this.quaternion.copy(this.cameraQuaternion);
    } else {
      _tempMatrix.lookAt(_tempVector.set(0, 0, 0), _dirVector, _alignVector);
      this.quaternion.setFromRotationMatrix(_tempMatrix);
    }
    super.updateMatrixWorld(force);
  }
};

// node_modules/@threlte/extras/dist/components/controls/useControlsContext.js
var useControlsContext = () => {
  return useThrelteUserContext("threlte-controls", {
    orbitControls: writable(void 0)
  });
};

// node_modules/@threlte/extras/dist/components/controls/TransformControls/TransformControls.svelte
var { Error: Error_15 } = globals;
var get_default_slot_changes6 = (dirty) => ({ ref: dirty & /*ref*/
33554432 });
var get_default_slot_context6 = (ctx) => ({ ref: (
  /*ref*/
  ctx[25]
) });
function create_default_slot_12(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*$controls*/
      ctx[4]
    ) },
    /*transformProps*/
    ctx[3]
  ];
  let t_props = {};
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[13](t2);
  t2.$on(
    "dragging-changed",
    /*onDraggingChanged*/
    ctx[8]
  );
  t2.$on(
    "change",
    /*invalidate*/
    ctx[6]
  );
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_changes = dirty & /*$controls, transformProps*/
      24 ? get_spread_update(t_spread_levels, [
        dirty & /*$controls*/
        16 && { is: (
          /*$controls*/
          ctx2[4]
        ) },
        dirty & /*transformProps*/
        8 && get_spread_object(
          /*transformProps*/
          ctx2[3]
        )
      ]) : {};
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[13](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: "(65:0) <HierarchicalObject   onChildMount={(child) => {     scene.add(child)   }}   onChildDestroy={(child) => {     scene.remove(child)   }} >",
    ctx
  });
  return block;
}
function create_default_slot8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context6
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        33619968)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_default_slot_changes6
            ),
            get_default_slot_context6
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: "(82:0) <T is={group} let:ref {...objectProps}>",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let hierarchicalobject;
  let t0;
  let t1;
  let current;
  hierarchicalobject = new HierarchicalObject_default({
    props: {
      onChildMount: (
        /*func*/
        ctx[14]
      ),
      onChildDestroy: (
        /*func_1*/
        ctx[15]
      ),
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const t1_spread_levels = [
    { is: (
      /*group*/
      ctx[0]
    ) },
    /*objectProps*/
    ctx[2]
  ];
  let t1_props = {
    $$slots: {
      default: [
        create_default_slot8,
        ({ ref }) => ({ 25: ref }),
        ({ ref }) => ref ? 33554432 : 0
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t1_spread_levels.length; i += 1) {
    t1_props = assign(t1_props, t1_spread_levels[i]);
  }
  t1 = new T({ props: t1_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(hierarchicalobject.$$.fragment);
      t0 = space();
      create_component(t1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hierarchicalobject.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(t1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hierarchicalobject, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(t1, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hierarchicalobject_changes = {};
      if (dirty & /*$$scope, $controls, transformProps, $component*/
      65592) {
        hierarchicalobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hierarchicalobject.$set(hierarchicalobject_changes);
      const t1_changes = dirty & /*group, objectProps*/
      5 ? get_spread_update(t1_spread_levels, [
        dirty & /*group*/
        1 && { is: (
          /*group*/
          ctx2[0]
        ) },
        dirty & /*objectProps*/
        4 && get_spread_object(
          /*objectProps*/
          ctx2[2]
        )
      ]) : {};
      if (dirty & /*$$scope, ref*/
      33619968) {
        t1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t1.$set(t1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hierarchicalobject.$$.fragment, local);
      transition_in(t1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hierarchicalobject.$$.fragment, local);
      transition_out(t1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hierarchicalobject, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(t1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let transformProps;
  let objectProps;
  const omit_props_names = ["autoPauseOrbitControls", "object", "group", "controls"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $controls, $$unsubscribe_controls = noop, $$subscribe_controls = () => ($$unsubscribe_controls(), $$unsubscribe_controls = subscribe(controls, ($$value) => $$invalidate(4, $controls = $$value)), controls);
  let $component;
  $$self.$$.on_destroy.push(() => $$unsubscribe_controls());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TransformControls", slots, ["default"]);
  let { autoPauseOrbitControls = true } = $$props;
  let { object = void 0 } = $$props;
  const { camera, renderer, invalidate, scene } = useThrelte();
  const { orbitControls } = useControlsContext();
  const isDragging = writable(false);
  const useAutoPauseOrbitControls = writable(autoPauseOrbitControls) ?? true;
  const onDraggingChanged = (e) => {
    isDragging.set(e.value);
  };
  watch([orbitControls, isDragging, useAutoPauseOrbitControls], ([orbitControls2, isDragging2, useAutoPauseOrbitControls2]) => {
    if (!orbitControls2 || !orbitControls2.enabled && isDragging2)
      return;
    orbitControls2.enabled = !(isDragging2 && useAutoPauseOrbitControls2);
    return () => {
      orbitControls2.enabled = true;
    };
  });
  if (!renderer) {
    throw new Error("TransformControls: renderer is undefined, is this component a child of <Canvas>?");
  }
  const group = new Group();
  const controls = derived(camera, (camera2) => {
    return new TransformControls(camera2, renderer.domElement);
  });
  validate_store(controls, "controls");
  $$subscribe_controls();
  const attachTo = writable(object ?? group);
  watch([controls, attachTo], ([controls2, attachTo2]) => {
    controls2.attach(attachTo2);
    return () => {
      controls2.detach();
    };
  });
  const transformOnlyPropNames = [
    "enabled",
    "axis",
    "mode",
    "translationSnap",
    "rotationSnap",
    "scaleSnap",
    "space",
    "size",
    "showX",
    "showY",
    "showZ",
    "visible"
  ];
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(5, $component = value));
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  const func2 = (child) => {
    scene.add(child);
  };
  const func_1 = (child) => {
    scene.remove(child);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(24, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("autoPauseOrbitControls" in $$new_props)
      $$invalidate(10, autoPauseOrbitControls = $$new_props.autoPauseOrbitControls);
    if ("object" in $$new_props)
      $$invalidate(11, object = $$new_props.object);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    forwardEventHandlers,
    HierarchicalObject: HierarchicalObject_default,
    T,
    useThrelte,
    watch,
    omit: import_lodash.omit,
    pick: import_lodash.pick,
    derived,
    writable,
    Group,
    TransformControls,
    useControlsContext,
    autoPauseOrbitControls,
    object,
    camera,
    renderer,
    invalidate,
    scene,
    orbitControls,
    isDragging,
    useAutoPauseOrbitControls,
    onDraggingChanged,
    group,
    controls,
    attachTo,
    transformOnlyPropNames,
    component,
    objectProps,
    transformProps,
    $controls,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("autoPauseOrbitControls" in $$props)
      $$invalidate(10, autoPauseOrbitControls = $$new_props.autoPauseOrbitControls);
    if ("object" in $$props)
      $$invalidate(11, object = $$new_props.object);
    if ("objectProps" in $$props)
      $$invalidate(2, objectProps = $$new_props.objectProps);
    if ("transformProps" in $$props)
      $$invalidate(3, transformProps = $$new_props.transformProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*autoPauseOrbitControls*/
    1024) {
      $:
        useAutoPauseOrbitControls.set(autoPauseOrbitControls ?? true);
    }
    $:
      $$invalidate(3, transformProps = (0, import_lodash.pick)($$restProps, transformOnlyPropNames));
    $:
      $$invalidate(2, objectProps = (0, import_lodash.omit)($$restProps, transformOnlyPropNames));
  };
  return [
    group,
    controls,
    objectProps,
    transformProps,
    $controls,
    $component,
    invalidate,
    scene,
    onDraggingChanged,
    component,
    autoPauseOrbitControls,
    object,
    slots,
    t_binding,
    func2,
    func_1,
    $$scope
  ];
}
var TransformControls_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      autoPauseOrbitControls: 10,
      object: 11,
      group: 0,
      controls: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TransformControls_1",
      options,
      id: create_fragment10.name
    });
  }
  get autoPauseOrbitControls() {
    throw new Error_15("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoPauseOrbitControls(value) {
    throw new Error_15("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get object() {
    throw new Error_15("<TransformControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error_15("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    return this.$$.ctx[0];
  }
  set group(value) {
    throw new Error_15("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get controls() {
    return this.$$.ctx[1];
  }
  set controls(value) {
    throw new Error_15("<TransformControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TransformControls_default = TransformControls_1;

// node_modules/@threlte/extras/dist/components/controls/OrbitControls/OrbitControls.svelte
var { Error: Error_16 } = globals;
var get_default_slot_changes7 = (dirty) => ({ ref: dirty & /*ref*/
1 });
var get_default_slot_context7 = (ctx) => ({ ref: (
  /*ref*/
  ctx[0]
) });
function create_default_slot9(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context7
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        1025)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes7
            ),
            get_default_slot_context7
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: "(27:0) <T   is={ref}   let:ref   {...$$restProps}   bind:this={$component}   on:change={invalidate}   on:create={({ ref, cleanup }) => {     orbitControls.set(ref)     cleanup(() => {       orbitControls.set(undefined)     })   }} >",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*ref*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[6]
  ];
  let t_props = {
    $$slots: {
      default: [create_default_slot9, ({ ref }) => ({ 0: ref }), ({ ref }) => ref ? 1 : 0]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[8](t2);
  t2.$on(
    "change",
    /*invalidate*/
    ctx[3]
  );
  t2.$on(
    "create",
    /*create_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = dirty & /*ref, $$restProps*/
      65 ? get_spread_update(t_spread_levels, [
        dirty & /*ref*/
        1 && { is: (
          /*ref*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        64 && get_spread_object(
          /*$$restProps*/
          ctx2[6]
        )
      ]) : {};
      if (dirty & /*$$scope, ref*/
      1025) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[8](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  const omit_props_names = ["ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $parent;
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OrbitControls", slots, ["default"]);
  const parent = useParent();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(11, $parent = value));
  const { renderer, invalidate } = useThrelte();
  if (!renderer)
    throw new Error("Threlte Context missing: Is <OrbitControls> a child of <Canvas>?");
  if (!($parent instanceof Camera)) {
    throw new Error("Parent missing: <OrbitControls> need to be a child of a <Camera>");
  }
  const ref = new OrbitControls($parent, renderer.domElement);
  const { start, stop } = useFrame(() => ref.update(), {
    autostart: false,
    debugFrameloopMessage: "OrbitControls: updating controls"
  });
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(1, $component = value));
  const { orbitControls } = useControlsContext();
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  const create_handler = ({ ref: ref2, cleanup }) => {
    orbitControls.set(ref2);
    cleanup(() => {
      orbitControls.set(void 0);
    });
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    forwardEventHandlers,
    T,
    useFrame,
    useParent,
    useThrelte,
    Camera,
    ThreeOrbitControls: OrbitControls,
    useControlsContext,
    parent,
    renderer,
    invalidate,
    ref,
    start,
    stop,
    component,
    orbitControls,
    $parent,
    $component
  });
  $$self.$$.update = () => {
    $: {
      if ($$restProps.autoRotate || $$restProps.enableDamping)
        start();
      else
        stop();
    }
  };
  return [
    ref,
    $component,
    parent,
    invalidate,
    component,
    orbitControls,
    $$restProps,
    slots,
    t_binding,
    create_handler,
    $$scope
  ];
}
var OrbitControls2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { ref: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OrbitControls",
      options,
      id: create_fragment11.name
    });
  }
  get ref() {
    return this.$$.ctx[0];
  }
  set ref(value) {
    throw new Error_16("<OrbitControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OrbitControls_default = OrbitControls2;

// node_modules/@threlte/extras/dist/components/Instancing/api.js
var getContextId = (instancedMeshId) => `threlte-instanced-mesh-${instancedMeshId}`;
var createApi = (instancedMesh, instancedMeshId) => {
  const api = {
    instancedMesh: currentWritable(instancedMesh),
    addInstance(instance24) {
      api.instances.update((arr) => {
        arr.push(instance24);
        return arr;
      });
    },
    removeInstance(instance24) {
      api.instances.update((arr) => {
        const index = arr.indexOf(instance24);
        if (index > -1)
          arr.splice(index, 1);
        return arr;
      });
    },
    instances: currentWritable([])
  };
  setContext(getContextId(instancedMeshId), api);
  return api;
};
var useApi = (instancedMeshId) => {
  const context = getContext(getContextId(instancedMeshId));
  if (!context)
    throw new Error(`No <InstancedMesh> component found for id ${instancedMeshId}`);
  return context;
};

// node_modules/@threlte/extras/dist/components/Instancing/Api.svelte
function create_fragment12(ctx) {
  let t_instancedbufferattribute0;
  let t0;
  let t_instancedbufferattribute1;
  let t1;
  let current;
  t_instancedbufferattribute0 = new T.InstancedBufferAttribute({
    props: {
      attach: "instanceMatrix",
      count: (
        /*matrices*/
        ctx[1].length / 16
      ),
      array: (
        /*matrices*/
        ctx[1]
      ),
      itemSize: 16,
      usage: DynamicDrawUsage
    },
    $$inline: true
  });
  t_instancedbufferattribute1 = new T.InstancedBufferAttribute({
    props: {
      attach: "instanceColor",
      count: (
        /*colors*/
        ctx[2].length / 3
      ),
      array: (
        /*colors*/
        ctx[2]
      ),
      itemSize: 3,
      usage: DynamicDrawUsage
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const block = {
    c: function create() {
      create_component(t_instancedbufferattribute0.$$.fragment);
      t0 = space();
      create_component(t_instancedbufferattribute1.$$.fragment);
      t1 = space();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      claim_component(t_instancedbufferattribute0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(t_instancedbufferattribute1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_instancedbufferattribute0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(t_instancedbufferattribute1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t_instancedbufferattribute0.$$.fragment, local);
      transition_in(t_instancedbufferattribute1.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_instancedbufferattribute0.$$.fragment, local);
      transition_out(t_instancedbufferattribute1.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_instancedbufferattribute0, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(t_instancedbufferattribute1, detaching);
      if (detaching)
        detach_dev(t1);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let $instances;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Api", slots, ["default"]);
  let { instancedMesh } = $$props;
  let { id } = $$props;
  let { limit } = $$props;
  let { range } = $$props;
  let { update } = $$props;
  const { instances } = createApi(instancedMesh, id);
  validate_store(instances, "instances");
  component_subscribe($$self, instances, (value) => $$invalidate(11, $instances = value));
  const tempMatrix = new Matrix4();
  const matrices = new Float32Array(limit * 16);
  for (let i = 0; i < limit; i++)
    tempMatrix.identity().toArray(matrices, i * 16);
  const colors = new Float32Array([...new Array(limit * 3)].map(() => 1));
  const parentMatrix = new Matrix4();
  const instanceMatrix = new Matrix4();
  const translation = new Vector3();
  const rotation = new Quaternion();
  const scale = new Vector3();
  let initialUpdateDone = false;
  useFrame(() => {
    instancedMesh.updateMatrix();
    if (update || !initialUpdateDone) {
      instancedMesh.updateMatrixWorld();
      parentMatrix.copy(instancedMesh.matrixWorld).invert();
      const updateRange = Math.min(limit, range !== void 0 ? range : limit, $instances.length);
      $$invalidate(3, instancedMesh.count = updateRange, instancedMesh);
      $$invalidate(3, instancedMesh.instanceMatrix.updateRange.count = updateRange * 16, instancedMesh);
      if (instancedMesh.instanceColor) {
        $$invalidate(3, instancedMesh.instanceColor.updateRange.count = updateRange * 3, instancedMesh);
      }
      if (instancedMesh.instanceColor) {
        $$invalidate(3, instancedMesh.instanceColor.needsUpdate = true, instancedMesh);
      }
      $$invalidate(3, instancedMesh.instanceMatrix.needsUpdate = true, instancedMesh);
      for (let i = 0; i < instances.current.length; i++) {
        const instance24 = instances.current[i];
        instance24.matrixWorld.decompose(translation, rotation, scale);
        instanceMatrix.compose(translation, rotation, scale).premultiply(parentMatrix);
        instanceMatrix.toArray(matrices, i * 16);
        instance24.color.toArray(colors, i * 3);
      }
      initialUpdateDone = true;
    }
  });
  $$self.$$.on_mount.push(function() {
    if (instancedMesh === void 0 && !("instancedMesh" in $$props || $$self.$$.bound[$$self.$$.props["instancedMesh"]])) {
      console.warn("<Api> was created without expected prop 'instancedMesh'");
    }
    if (id === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<Api> was created without expected prop 'id'");
    }
    if (limit === void 0 && !("limit" in $$props || $$self.$$.bound[$$self.$$.props["limit"]])) {
      console.warn("<Api> was created without expected prop 'limit'");
    }
    if (range === void 0 && !("range" in $$props || $$self.$$.bound[$$self.$$.props["range"]])) {
      console.warn("<Api> was created without expected prop 'range'");
    }
    if (update === void 0 && !("update" in $$props || $$self.$$.bound[$$self.$$.props["update"]])) {
      console.warn("<Api> was created without expected prop 'update'");
    }
  });
  const writable_props = ["instancedMesh", "id", "limit", "range", "update"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Api> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("instancedMesh" in $$props2)
      $$invalidate(3, instancedMesh = $$props2.instancedMesh);
    if ("id" in $$props2)
      $$invalidate(4, id = $$props2.id);
    if ("limit" in $$props2)
      $$invalidate(5, limit = $$props2.limit);
    if ("range" in $$props2)
      $$invalidate(6, range = $$props2.range);
    if ("update" in $$props2)
      $$invalidate(7, update = $$props2.update);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    T,
    useFrame,
    DynamicDrawUsage,
    Matrix4,
    Quaternion,
    Vector3,
    createApi,
    instancedMesh,
    id,
    limit,
    range,
    update,
    instances,
    tempMatrix,
    matrices,
    colors,
    parentMatrix,
    instanceMatrix,
    translation,
    rotation,
    scale,
    initialUpdateDone,
    $instances
  });
  $$self.$inject_state = ($$props2) => {
    if ("instancedMesh" in $$props2)
      $$invalidate(3, instancedMesh = $$props2.instancedMesh);
    if ("id" in $$props2)
      $$invalidate(4, id = $$props2.id);
    if ("limit" in $$props2)
      $$invalidate(5, limit = $$props2.limit);
    if ("range" in $$props2)
      $$invalidate(6, range = $$props2.range);
    if ("update" in $$props2)
      $$invalidate(7, update = $$props2.update);
    if ("initialUpdateDone" in $$props2)
      initialUpdateDone = $$props2.initialUpdateDone;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    instances,
    matrices,
    colors,
    instancedMesh,
    id,
    limit,
    range,
    update,
    $$scope,
    slots
  ];
}
var Api = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      instancedMesh: 3,
      id: 4,
      limit: 5,
      range: 6,
      update: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Api",
      options,
      id: create_fragment12.name
    });
  }
  get instancedMesh() {
    throw new Error("<Api>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instancedMesh(value) {
    throw new Error("<Api>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Api>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Api>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get limit() {
    throw new Error("<Api>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set limit(value) {
    throw new Error("<Api>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get range() {
    throw new Error("<Api>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set range(value) {
    throw new Error("<Api>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get update() {
    throw new Error("<Api>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set update(value) {
    throw new Error("<Api>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Api_default = Api;

// node_modules/@threlte/extras/dist/components/Instancing/InstancedMesh.svelte
var get_default_slot_changes8 = (dirty) => ({ ref: dirty & /*ref*/
2048 });
var get_default_slot_context8 = (ctx) => ({ ref: (
  /*ref*/
  ctx[11]
) });
function create_default_slot_13(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context8
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        3072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes8
            ),
            get_default_slot_context8
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13.name,
    type: "slot",
    source: "(19:2) <Api instancedMesh={ref} {id} {limit} {range} {update}>",
    ctx
  });
  return block;
}
function create_default_slot10(ctx) {
  let api;
  let current;
  api = new Api_default({
    props: {
      instancedMesh: (
        /*ref*/
        ctx[11]
      ),
      id: (
        /*id*/
        ctx[0]
      ),
      limit: (
        /*limit*/
        ctx[1]
      ),
      range: (
        /*range*/
        ctx[2]
      ),
      update: (
        /*update*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(api.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(api.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(api, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const api_changes = {};
      if (dirty & /*ref*/
      2048)
        api_changes.instancedMesh = /*ref*/
        ctx2[11];
      if (dirty & /*id*/
      1)
        api_changes.id = /*id*/
        ctx2[0];
      if (dirty & /*limit*/
      2)
        api_changes.limit = /*limit*/
        ctx2[1];
      if (dirty & /*range*/
      4)
        api_changes.range = /*range*/
        ctx2[2];
      if (dirty & /*update*/
      8)
        api_changes.update = /*update*/
        ctx2[3];
      if (dirty & /*$$scope, ref*/
      3072) {
        api_changes.$$scope = { dirty, ctx: ctx2 };
      }
      api.$set(api_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(api.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(api.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(api, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot10.name,
    type: "slot",
    source: "(11:0) <T.InstancedMesh   raycast={() => null}   matrixAutoUpdate={false}   {args}   let:ref   {...$$restProps}   bind:bind={$dispatchingComponent} >",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let t_instancedmesh;
  let updating_bind;
  let current;
  const t_instancedmesh_spread_levels = [
    { raycast: func },
    { matrixAutoUpdate: false },
    { args: (
      /*args*/
      ctx[6]
    ) },
    /*$$restProps*/
    ctx[7]
  ];
  function t_instancedmesh_bind_binding(value) {
    ctx[9](value);
  }
  let t_instancedmesh_props = {
    $$slots: {
      default: [
        create_default_slot10,
        ({ ref }) => ({ 11: ref }),
        ({ ref }) => ref ? 2048 : 0
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_instancedmesh_spread_levels.length; i += 1) {
    t_instancedmesh_props = assign(t_instancedmesh_props, t_instancedmesh_spread_levels[i]);
  }
  if (
    /*$dispatchingComponent*/
    ctx[4] !== void 0
  ) {
    t_instancedmesh_props.bind = /*$dispatchingComponent*/
    ctx[4];
  }
  t_instancedmesh = new T.InstancedMesh({
    props: t_instancedmesh_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(t_instancedmesh, "bind", t_instancedmesh_bind_binding));
  const block = {
    c: function create() {
      create_component(t_instancedmesh.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t_instancedmesh.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t_instancedmesh, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_instancedmesh_changes = dirty & /*args, $$restProps*/
      192 ? get_spread_update(t_instancedmesh_spread_levels, [
        t_instancedmesh_spread_levels[0],
        t_instancedmesh_spread_levels[1],
        dirty & /*args*/
        64 && { args: (
          /*args*/
          ctx2[6]
        ) },
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx2[7]
        )
      ]) : {};
      if (dirty & /*$$scope, ref, id, limit, range, update*/
      3087) {
        t_instancedmesh_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_bind && dirty & /*$dispatchingComponent*/
      16) {
        updating_bind = true;
        t_instancedmesh_changes.bind = /*$dispatchingComponent*/
        ctx2[4];
        add_flush_callback(() => updating_bind = false);
      }
      t_instancedmesh.$set(t_instancedmesh_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t_instancedmesh.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t_instancedmesh.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t_instancedmesh, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = () => null;
function instance13($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "limit", "range", "update"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $dispatchingComponent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InstancedMesh", slots, ["default"]);
  let { id = "default" } = $$props;
  let { limit = 1e3 } = $$props;
  let { range = 1e3 } = $$props;
  let { update = true } = $$props;
  const dispatchingComponent = forwardEventHandlers();
  validate_store(dispatchingComponent, "dispatchingComponent");
  component_subscribe($$self, dispatchingComponent, (value) => $$invalidate(4, $dispatchingComponent = value));
  const args = [null, null, 0];
  function t_instancedmesh_bind_binding(value) {
    $dispatchingComponent = value;
    dispatchingComponent.set($dispatchingComponent);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(0, id = $$new_props.id);
    if ("limit" in $$new_props)
      $$invalidate(1, limit = $$new_props.limit);
    if ("range" in $$new_props)
      $$invalidate(2, range = $$new_props.range);
    if ("update" in $$new_props)
      $$invalidate(3, update = $$new_props.update);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    T,
    forwardEventHandlers,
    useFrame,
    Api: Api_default,
    id,
    limit,
    range,
    update,
    dispatchingComponent,
    args,
    $dispatchingComponent
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props)
      $$invalidate(0, id = $$new_props.id);
    if ("limit" in $$props)
      $$invalidate(1, limit = $$new_props.limit);
    if ("range" in $$props)
      $$invalidate(2, range = $$new_props.range);
    if ("update" in $$props)
      $$invalidate(3, update = $$new_props.update);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    id,
    limit,
    range,
    update,
    $dispatchingComponent,
    dispatchingComponent,
    args,
    $$restProps,
    slots,
    t_instancedmesh_bind_binding,
    $$scope
  ];
}
var InstancedMesh = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { id: 0, limit: 1, range: 2, update: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InstancedMesh",
      options,
      id: create_fragment13.name
    });
  }
  get id() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get limit() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set limit(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get range() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set range(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get update() {
    throw new Error("<InstancedMesh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set update(value) {
    throw new Error("<InstancedMesh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InstancedMesh_default = InstancedMesh;

// node_modules/@threlte/extras/dist/components/Instancing/PositionMesh.js
var _instanceLocalMatrix = new Matrix4();
var _instanceWorldMatrix = new Matrix4();
var _instanceIntersects = [];
var _mesh = new Mesh();
var PositionMesh = class extends Group {
  constructor(instancedMesh, instances) {
    super();
    __publicField(this, "color");
    __publicField(this, "instancedMesh");
    __publicField(this, "instances");
    this.color = new Color("white");
    this.instancedMesh = instancedMesh;
    this.instances = instances;
  }
  // This will allow the virtual instance have bounds
  get geometry() {
    var _a;
    return (_a = this.instancedMesh.current) == null ? void 0 : _a.geometry;
  }
  // And this will allow the virtual instance to receive events
  raycast(raycaster, intersects) {
    var _a;
    const parent = this.instancedMesh.current;
    if (!parent)
      return;
    if (!parent.geometry || !parent.material)
      return;
    _mesh.geometry = parent.geometry;
    const matrixWorld = parent.matrixWorld;
    const instanceId = this.instances.current.indexOf(this);
    if (instanceId === -1 || instanceId > parent.count)
      return;
    parent.getMatrixAt(instanceId, _instanceLocalMatrix);
    _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
    _mesh.matrixWorld = _instanceWorldMatrix;
    if (parent.material instanceof Material)
      _mesh.material.side = parent.material.side;
    else
      _mesh.material.side = ((_a = parent.material[0]) == null ? void 0 : _a.side) ?? FrontSide;
    _mesh.raycast(raycaster, _instanceIntersects);
    for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
      const intersect = _instanceIntersects[i];
      intersect.instanceId = instanceId;
      intersect.object = this;
      intersects.push(intersect);
    }
    _instanceIntersects.length = 0;
  }
};

// node_modules/@threlte/extras/dist/components/Instancing/Instance.svelte
var get_default_slot_changes9 = (dirty) => ({});
var get_default_slot_context9 = (ctx) => ({ ref: (
  /*ref*/
  ctx[0]
) });
function create_default_slot11(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context9
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes9
            ),
            get_default_slot_context9
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot11.name,
    type: "slot",
    source: "(15:0) <T is={ref} bind:this={$dispatchingComponent} {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*ref*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let t_props = {
    $$slots: { default: [create_default_slot11] },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[6](t2);
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = dirty & /*ref, $$restProps*/
      9 ? get_spread_update(t_spread_levels, [
        dirty & /*ref*/
        1 && { is: (
          /*ref*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      128) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[6](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $dispatchingComponent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Instance", slots, ["default"]);
  let { id = "default" } = $$props;
  const { addInstance, removeInstance, instancedMesh, instances } = useApi(id);
  const ref = new PositionMesh(instancedMesh, instances);
  addInstance(ref);
  onDestroy(() => {
    removeInstance(ref);
  });
  const dispatchingComponent = forwardEventHandlers();
  validate_store(dispatchingComponent, "dispatchingComponent");
  component_subscribe($$self, dispatchingComponent, (value) => $$invalidate(1, $dispatchingComponent = value));
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $dispatchingComponent = $$value;
      dispatchingComponent.set($dispatchingComponent);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(4, id = $$new_props.id);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    T,
    forwardEventHandlers,
    onDestroy,
    PositionMesh,
    useApi,
    id,
    addInstance,
    removeInstance,
    instancedMesh,
    instances,
    ref,
    dispatchingComponent,
    $dispatchingComponent
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props)
      $$invalidate(4, id = $$new_props.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    ref,
    $dispatchingComponent,
    dispatchingComponent,
    $$restProps,
    id,
    slots,
    t_binding,
    $$scope
  ];
}
var Instance = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, { id: 4, ref: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Instance",
      options,
      id: create_fragment14.name
    });
  }
  get id() {
    throw new Error("<Instance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Instance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    return this.$$.ctx[0];
  }
  set ref(value) {
    throw new Error("<Instance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Instance_default = Instance;

// node_modules/@threlte/extras/dist/components/Instancing/InstancedMeshes/InnerInstancedMeshes.svelte
function create_else_block2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(21:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let instancedmesh;
  let current;
  const instancedmesh_spread_levels = [
    { geometry: (
      /*mesh*/
      ctx[2].geometry
    ) },
    { material: (
      /*mesh*/
      ctx[2].material
    ) },
    { id: (
      /*mesh*/
      ctx[2].uuid
    ) },
    /*$$restProps*/
    ctx[4]
  ];
  let instancedmesh_props = {
    $$slots: { default: [create_default_slot12] },
    $$scope: { ctx }
  };
  for (let i = 0; i < instancedmesh_spread_levels.length; i += 1) {
    instancedmesh_props = assign(instancedmesh_props, instancedmesh_spread_levels[i]);
  }
  instancedmesh = new InstancedMesh_default({
    props: instancedmesh_props,
    $$inline: true
  });
  ctx[7](instancedmesh);
  const block = {
    c: function create() {
      create_component(instancedmesh.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(instancedmesh.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(instancedmesh, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const instancedmesh_changes = dirty & /*mesh, $$restProps*/
      20 ? get_spread_update(instancedmesh_spread_levels, [
        dirty & /*mesh*/
        4 && { geometry: (
          /*mesh*/
          ctx2[2].geometry
        ) },
        dirty & /*mesh*/
        4 && { material: (
          /*mesh*/
          ctx2[2].material
        ) },
        dirty & /*mesh*/
        4 && { id: (
          /*mesh*/
          ctx2[2].uuid
        ) },
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      256) {
        instancedmesh_changes.$$scope = { dirty, ctx: ctx2 };
      }
      instancedmesh.$set(instancedmesh_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(instancedmesh.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(instancedmesh.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[7](null);
      destroy_component(instancedmesh, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(9:0) {#if mesh}",
    ctx
  });
  return block;
}
function create_default_slot_14(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_14.name,
    type: "slot",
    source: "(17:4) <svelte:self meshes={copiedArray}>",
    ctx
  });
  return block;
}
function create_default_slot12(ctx) {
  let innerinstancedmeshes;
  let current;
  innerinstancedmeshes = new InnerInstancedMeshes({
    props: {
      meshes: (
        /*copiedArray*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(innerinstancedmeshes.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(innerinstancedmeshes.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(innerinstancedmeshes, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const innerinstancedmeshes_changes = {};
      if (dirty & /*$$scope*/
      256) {
        innerinstancedmeshes_changes.$$scope = { dirty, ctx: ctx2 };
      }
      innerinstancedmeshes.$set(innerinstancedmeshes_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(innerinstancedmeshes.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(innerinstancedmeshes.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(innerinstancedmeshes, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot12.name,
    type: "slot",
    source: "(10:2) <InstancedMesh     geometry={mesh.geometry}     material={mesh.material}     id={mesh.uuid}     bind:this={$dispatchingComponent}     {...$$restProps}   >",
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block5, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*mesh*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  const omit_props_names = ["meshes"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $dispatchingComponent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InnerInstancedMeshes", slots, ["default"]);
  let { meshes } = $$props;
  const copiedArray = [...meshes];
  const mesh = copiedArray.pop();
  const dispatchingComponent = forwardEventHandlers();
  validate_store(dispatchingComponent, "dispatchingComponent");
  component_subscribe($$self, dispatchingComponent, (value) => $$invalidate(0, $dispatchingComponent = value));
  $$self.$$.on_mount.push(function() {
    if (meshes === void 0 && !("meshes" in $$props || $$self.$$.bound[$$self.$$.props["meshes"]])) {
      console.warn("<InnerInstancedMeshes> was created without expected prop 'meshes'");
    }
  });
  function instancedmesh_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $dispatchingComponent = $$value;
      dispatchingComponent.set($dispatchingComponent);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("meshes" in $$new_props)
      $$invalidate(5, meshes = $$new_props.meshes);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    forwardEventHandlers,
    InstancedMesh: InstancedMesh_default,
    meshes,
    copiedArray,
    mesh,
    dispatchingComponent,
    $dispatchingComponent
  });
  $$self.$inject_state = ($$new_props) => {
    if ("meshes" in $$props)
      $$invalidate(5, meshes = $$new_props.meshes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    $dispatchingComponent,
    copiedArray,
    mesh,
    dispatchingComponent,
    $$restProps,
    meshes,
    slots,
    instancedmesh_binding,
    $$scope
  ];
}
var InnerInstancedMeshes = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { meshes: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InnerInstancedMeshes",
      options,
      id: create_fragment15.name
    });
  }
  get meshes() {
    throw new Error("<InnerInstancedMeshes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set meshes(value) {
    throw new Error("<InnerInstancedMeshes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InnerInstancedMeshes_default = InnerInstancedMeshes;

// node_modules/@threlte/extras/dist/components/Instancing/InstancedMeshes/InstancedMeshes.svelte
var get_default_slot_changes10 = (dirty) => ({ components: dirty & /*components*/
2 });
var get_default_slot_context10 = (ctx) => ({ components: (
  /*components*/
  ctx[1]
) });
function create_default_slot13(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context10
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, components*/
        514)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes10
            ),
            get_default_slot_context10
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot13.name,
    type: "slot",
    source: "(39:0) <InnerInstancedMeshes   meshes={filteredMeshesArray}   bind:this={$dispatchingComponent}   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let innerinstancedmeshes;
  let current;
  const innerinstancedmeshes_spread_levels = [
    { meshes: (
      /*filteredMeshesArray*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[4]
  ];
  let innerinstancedmeshes_props = {
    $$slots: { default: [create_default_slot13] },
    $$scope: { ctx }
  };
  for (let i = 0; i < innerinstancedmeshes_spread_levels.length; i += 1) {
    innerinstancedmeshes_props = assign(innerinstancedmeshes_props, innerinstancedmeshes_spread_levels[i]);
  }
  innerinstancedmeshes = new InnerInstancedMeshes_default({
    props: innerinstancedmeshes_props,
    $$inline: true
  });
  ctx[8](innerinstancedmeshes);
  const block = {
    c: function create() {
      create_component(innerinstancedmeshes.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(innerinstancedmeshes.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(innerinstancedmeshes, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const innerinstancedmeshes_changes = dirty & /*filteredMeshesArray, $$restProps*/
      17 ? get_spread_update(innerinstancedmeshes_spread_levels, [
        dirty & /*filteredMeshesArray*/
        1 && { meshes: (
          /*filteredMeshesArray*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        )
      ]) : {};
      if (dirty & /*$$scope, components*/
      514) {
        innerinstancedmeshes_changes.$$scope = { dirty, ctx: ctx2 };
      }
      innerinstancedmeshes.$set(innerinstancedmeshes_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(innerinstancedmeshes.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(innerinstancedmeshes.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[8](null);
      destroy_component(innerinstancedmeshes, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let components;
  let meshesArray;
  let filteredMeshesArray;
  const omit_props_names = ["meshes"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $dispatchingComponent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InstancedMeshes", slots, ["default"]);
  let { meshes } = $$props;
  const getInstance = (id) => {
    return new Proxy(
      Instance_default,
      {
        construct(Instance2, args) {
          const opts = {
            ...args[0],
            props: { ...args[0].props, id }
          };
          return new Instance2(opts);
        }
      }
    );
  };
  const getInstanceComponentsArray = (meshes2) => {
    return meshes2.filter((mesh) => mesh.isMesh).map((mesh) => getInstance(mesh.uuid));
  };
  const getInstanceComponentsObject = (meshes2) => {
    return Object.entries(meshes2).reduce(
      (acc, [id, mesh]) => {
        if (!mesh.isMesh)
          return acc;
        acc[id] = getInstance(mesh.uuid);
        return acc;
      },
      {}
    );
  };
  const dispatchingComponent = forwardEventHandlers();
  validate_store(dispatchingComponent, "dispatchingComponent");
  component_subscribe($$self, dispatchingComponent, (value) => $$invalidate(2, $dispatchingComponent = value));
  $$self.$$.on_mount.push(function() {
    if (meshes === void 0 && !("meshes" in $$props || $$self.$$.bound[$$self.$$.props["meshes"]])) {
      console.warn("<InstancedMeshes> was created without expected prop 'meshes'");
    }
  });
  function innerinstancedmeshes_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $dispatchingComponent = $$value;
      dispatchingComponent.set($dispatchingComponent);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("meshes" in $$new_props)
      $$invalidate(5, meshes = $$new_props.meshes);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    forwardEventHandlers,
    Instance: Instance_default,
    InnerInstancedMeshes: InnerInstancedMeshes_default,
    meshes,
    getInstance,
    getInstanceComponentsArray,
    getInstanceComponentsObject,
    dispatchingComponent,
    meshesArray,
    filteredMeshesArray,
    components,
    $dispatchingComponent
  });
  $$self.$inject_state = ($$new_props) => {
    if ("meshes" in $$props)
      $$invalidate(5, meshes = $$new_props.meshes);
    if ("meshesArray" in $$props)
      $$invalidate(6, meshesArray = $$new_props.meshesArray);
    if ("filteredMeshesArray" in $$props)
      $$invalidate(0, filteredMeshesArray = $$new_props.filteredMeshesArray);
    if ("components" in $$props)
      $$invalidate(1, components = $$new_props.components);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*meshes*/
    32) {
      $:
        $$invalidate(1, components = Array.isArray(meshes) ? getInstanceComponentsArray(meshes) : getInstanceComponentsObject(meshes));
    }
    if ($$self.$$.dirty & /*meshes*/
    32) {
      $:
        $$invalidate(6, meshesArray = Array.isArray(meshes) ? meshes : Object.values(meshes));
    }
    if ($$self.$$.dirty & /*meshesArray*/
    64) {
      $:
        $$invalidate(0, filteredMeshesArray = meshesArray.filter((mesh) => mesh.isMesh));
    }
  };
  return [
    filteredMeshesArray,
    components,
    $dispatchingComponent,
    dispatchingComponent,
    $$restProps,
    meshes,
    meshesArray,
    slots,
    innerinstancedmeshes_binding,
    $$scope
  ];
}
var InstancedMeshes = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { meshes: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InstancedMeshes",
      options,
      id: create_fragment16.name
    });
  }
  get meshes() {
    throw new Error("<InstancedMeshes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set meshes(value) {
    throw new Error("<InstancedMeshes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InstancedMeshes_default = InstancedMeshes;

// node_modules/@threlte/extras/dist/suspense/context.js
var suspenseContextIdentifier = Symbol("THRELTE_SUSPENSE_CONTEXT_IDENTIFIER");
var createSuspenseContext = (options) => {
  const dispatch = createRawEventDispatcher();
  const promises = currentWritable(/* @__PURE__ */ new Map());
  const errors = currentWritable(/* @__PURE__ */ new Map());
  const finalized = writable(false);
  const checkFinalized = () => {
    if (promises.current.size === 0 && errors.current.size === 0)
      finalized.set(true);
  };
  const finalStore = writable((options == null ? void 0 : options.final) ?? false);
  const addPromise = (component, promise) => {
    promises.update((map) => {
      var _a;
      if (map.has(component)) {
        (_a = map.get(component)) == null ? void 0 : _a.add(promise);
      } else {
        map.set(component, /* @__PURE__ */ new Set([promise]));
      }
      return map;
    });
  };
  const removePromise = (component, promise) => {
    promises.update((map) => {
      var _a, _b;
      if (map.has(component)) {
        (_a = map.get(component)) == null ? void 0 : _a.delete(promise);
      }
      if (((_b = map.get(component)) == null ? void 0 : _b.size) === 0) {
        map.delete(component);
      }
      return map;
    });
  };
  const addError = (component, error) => {
    errors.update((map) => {
      var _a;
      if (map.has(component)) {
        (_a = map.get(component)) == null ? void 0 : _a.push(error);
      } else {
        map.set(component, [error]);
      }
      return map;
    });
  };
  const suspended = derived([promises, errors, finalStore, finalized], ([promises2, errors2, final, finalized2]) => {
    if (final && finalized2) {
      return false;
    } else if (errors2.size > 0) {
      return true;
    } else {
      return promises2.size > 0;
    }
  });
  const context = {
    suspend(component, promise) {
      addPromise(component, promise);
      promise.then(() => {
        var _a;
        if ((_a = promises.current.get(component)) == null ? void 0 : _a.has(promise)) {
          removePromise(component, promise);
        }
      }).catch((error) => {
        var _a;
        if ((_a = promises.current.get(component)) == null ? void 0 : _a.has(promise)) {
          removePromise(component, promise);
          addError(component, error);
          dispatch("error", error);
        }
      }).finally(() => {
        checkFinalized();
      });
    },
    onComponentDestroy(component) {
      promises.update((map) => {
        map.delete(component);
        return map;
      });
      errors.update((map) => {
        map.delete(component);
        return map;
      });
      checkFinalized();
    },
    suspended
  };
  const errorsArray = derived(errors, (errors2) => Array.from(errors2.values()).flat());
  setContext(suspenseContextIdentifier, context);
  return {
    promises,
    suspended,
    errors: errorsArray,
    setFinal: (final) => finalStore.set(final ?? false)
  };
};

// node_modules/@threlte/extras/dist/suspense/Suspense.svelte
var get_fallback_slot_changes = (dirty) => ({
  suspended: dirty & /*$suspended*/
  1,
  errors: dirty & /*$errors*/
  2
});
var get_fallback_slot_context = (ctx) => ({
  suspended: (
    /*$suspended*/
    ctx[0]
  ),
  errors: (
    /*$errors*/
    ctx[1]
  )
});
var get_error_slot_changes = (dirty) => ({
  errors: dirty & /*$errors*/
  2,
  suspended: dirty & /*$suspended*/
  1
});
var get_error_slot_context = (ctx) => ({
  errors: (
    /*$errors*/
    ctx[1]
  ),
  suspended: (
    /*$suspended*/
    ctx[0]
  )
});
var get_default_slot_changes11 = (dirty) => ({
  suspended: dirty & /*$suspended*/
  1,
  errors: dirty & /*$errors*/
  2
});
var get_default_slot_context11 = (ctx) => ({
  suspended: (
    /*$suspended*/
    ctx[0]
  ),
  errors: (
    /*$errors*/
    ctx[1]
  )
});
function create_default_slot_15(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context11
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $suspended, $errors*/
        131)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes11
            ),
            get_default_slot_context11
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_15.name,
    type: "slot",
    source: "(31:2) <T is={group}>",
    ctx
  });
  return block;
}
function create_default_slot14(ctx) {
  let t2;
  let current;
  t2 = new T({
    props: {
      is: (
        /*group*/
        ctx[4]
      ),
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const t_changes = {};
      if (dirty & /*$$scope, $suspended, $errors*/
      131) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot14.name,
    type: "slot",
    source: "(30:0) <HierarchicalObject>",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let current;
  const fallback_slot_template = (
    /*#slots*/
    ctx[6].fallback
  );
  const fallback_slot = create_slot(
    fallback_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_fallback_slot_context
  );
  const block = {
    c: function create() {
      if (fallback_slot)
        fallback_slot.c();
    },
    l: function claim(nodes) {
      if (fallback_slot)
        fallback_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (fallback_slot) {
        fallback_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (fallback_slot) {
        if (fallback_slot.p && (!current || dirty & /*$$scope, $suspended, $errors*/
        131)) {
          update_slot_base(
            fallback_slot,
            fallback_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              fallback_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_fallback_slot_changes
            ),
            get_fallback_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(fallback_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(fallback_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (fallback_slot)
        fallback_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(38:21) ",
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let current;
  const error_slot_template = (
    /*#slots*/
    ctx[6].error
  );
  const error_slot = create_slot(
    error_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_error_slot_context
  );
  const block = {
    c: function create() {
      if (error_slot)
        error_slot.c();
    },
    l: function claim(nodes) {
      if (error_slot)
        error_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (error_slot) {
        error_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (error_slot) {
        if (error_slot.p && (!current || dirty & /*$$scope, $errors, $suspended*/
        131)) {
          update_slot_base(
            error_slot,
            error_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              error_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_error_slot_changes
            ),
            get_error_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(error_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(error_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (error_slot)
        error_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(36:0) {#if $errors.length}",
    ctx
  });
  return block;
}
function create_fragment17(ctx) {
  let hierarchicalobject;
  let t2;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  hierarchicalobject = new HierarchicalObject_default({
    props: {
      $$slots: { default: [create_default_slot14] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const if_block_creators = [create_if_block6, create_if_block_12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$errors*/
      ctx2[1].length
    )
      return 0;
    if (
      /*$suspended*/
      ctx2[0]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      create_component(hierarchicalobject.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(hierarchicalobject.$$.fragment, nodes);
      t2 = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(hierarchicalobject, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const hierarchicalobject_changes = {};
      if (dirty & /*$$scope, $suspended, $errors*/
      131) {
        hierarchicalobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hierarchicalobject.$set(hierarchicalobject_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hierarchicalobject.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(hierarchicalobject.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hierarchicalobject, detaching);
      if (detaching)
        detach_dev(t2);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let $suspended;
  let $errors;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Suspense", slots, ["default", "error", "fallback"]);
  let { final = false } = $$props;
  const dispatch = createEventDispatcher();
  const { suspended, errors, setFinal } = createSuspenseContext({ final });
  validate_store(suspended, "suspended");
  component_subscribe($$self, suspended, (value) => $$invalidate(0, $suspended = value));
  validate_store(errors, "errors");
  component_subscribe($$self, errors, (value) => $$invalidate(1, $errors = value));
  const group = new Group();
  const parent = useParent();
  watch([parent, suspended, errors], ([parent2, suspended2, errors2]) => {
    if (!parent2)
      return;
    if (suspended2 || errors2.length) {
      parent2.remove(group);
      return;
    }
    parent2.add(group);
    return () => {
      parent2.remove(group);
    };
  });
  const writable_props = ["final"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Suspense> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("final" in $$props2)
      $$invalidate(5, final = $$props2.final);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    createSuspenseContext,
    HierarchicalObject: HierarchicalObject_default,
    T,
    useParent,
    watch,
    Group,
    final,
    dispatch,
    suspended,
    errors,
    setFinal,
    group,
    parent,
    $suspended,
    $errors
  });
  $$self.$inject_state = ($$props2) => {
    if ("final" in $$props2)
      $$invalidate(5, final = $$props2.final);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*final*/
    32) {
      $:
        setFinal(final);
    }
    if ($$self.$$.dirty & /*$suspended*/
    1) {
      $:
        if (!$suspended)
          dispatch("load");
    }
  };
  return [$suspended, $errors, suspended, errors, group, final, slots, $$scope];
}
var Suspense = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, { final: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Suspense",
      options,
      id: create_fragment17.name
    });
  }
  get final() {
    throw new Error("<Suspense>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set final(value) {
    throw new Error("<Suspense>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Suspense_default = Suspense;

// node_modules/@threlte/extras/dist/suspense/useSuspense.js
var useSuspense = () => {
  const ctx = getContext(suspenseContextIdentifier);
  const component = get_current_component();
  const suspend = (promise) => {
    ctx == null ? void 0 : ctx.suspend(component, promise);
    return promise;
  };
  onDestroy(() => {
    ctx == null ? void 0 : ctx.onComponentDestroy(component);
  });
  return suspend;
};

// node_modules/@threlte/extras/dist/suspense/onReveal.js
var onReveal = (callback) => {
  const ctx = getContext(suspenseContextIdentifier);
  const mounted = writable(false);
  onMount(() => {
    if (!ctx)
      callback();
    mounted.set(true);
  });
  if (!ctx)
    return;
  watch([ctx.suspended, mounted], ([suspended, mounted2]) => {
    if (mounted2 && !suspended)
      callback();
  });
};

// node_modules/@threlte/extras/dist/suspense/onSuspend.js
var onSuspend = (callback) => {
  const ctx = getContext(suspenseContextIdentifier);
  if (!ctx)
    return;
  const mounted = writable(false);
  onMount(() => {
    mounted.set(true);
  });
  watch([ctx.suspended, mounted], ([suspended, mounted2]) => {
    if (mounted2 && suspended)
      callback();
  });
};

// node_modules/@threlte/extras/dist/components/portals/usePortalContext.js
var createPortalContext = () => {
  const ctx = {
    portals: currentWritable(/* @__PURE__ */ new Map()),
    addPortal(object, id) {
      ctx.portals.update((portals) => {
        if (portals.has(id)) {
          console.warn(`Portal with id ${id} already exists. Skipping portal creation.`);
        } else {
          portals.set(id, object);
        }
        return portals;
      });
    },
    removePortal(id) {
      ctx.portals.update((portals) => {
        if (!portals.has(id)) {
          console.warn(`Portal with id ${id} does not exist. Skipping portal removal.`);
        } else {
          portals.delete(id);
        }
        return portals;
      });
    },
    getPortal(id) {
      return derived(ctx.portals, (portals) => portals.get(id));
    },
    hasPortal(id) {
      return ctx.portals.current.has(id);
    }
  };
  return ctx;
};
var usePortalContext = () => {
  return useThrelteUserContext("threlte-portals", createPortalContext());
};

// node_modules/@threlte/extras/dist/components/portals/Portal/Portal.svelte
function create_if_block7(ctx) {
  let hierarchicalobject;
  let current;
  hierarchicalobject = new HierarchicalObject_default({
    props: {
      onChildMount: (
        /*func*/
        ctx[6]
      ),
      onChildDestroy: (
        /*func_1*/
        ctx[7]
      ),
      $$slots: { default: [create_default_slot15] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(hierarchicalobject.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(hierarchicalobject.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(hierarchicalobject, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const hierarchicalobject_changes = {};
      if (dirty & /*portalTarget*/
      1)
        hierarchicalobject_changes.onChildMount = /*func*/
        ctx2[6];
      if (dirty & /*portalTarget*/
      1)
        hierarchicalobject_changes.onChildDestroy = /*func_1*/
        ctx2[7];
      if (dirty & /*$$scope*/
      256) {
        hierarchicalobject_changes.$$scope = { dirty, ctx: ctx2 };
      }
      hierarchicalobject.$set(hierarchicalobject_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(hierarchicalobject.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hierarchicalobject.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(hierarchicalobject, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(10:0) {#if portalTarget}",
    ctx
  });
  return block;
}
function create_default_slot15(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot15.name,
    type: "slot",
    source: "(11:2) <HierarchicalObject     onChildMount={(child) => {       portalTarget?.add(child)     }}     onChildDestroy={(child) => {       portalTarget?.remove(child)     }}   >",
    ctx
  });
  return block;
}
function create_fragment18(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*portalTarget*/
    ctx[0] && create_if_block7(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*portalTarget*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*portalTarget*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let portalTarget;
  let $portal;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Portal", slots, ["default"]);
  let { id = "default" } = $$props;
  let { object = void 0 } = $$props;
  const { getPortal } = usePortalContext();
  const portal = getPortal(id);
  validate_store(portal, "portal");
  component_subscribe($$self, portal, (value) => $$invalidate(4, $portal = value));
  const writable_props = ["id", "object"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Portal> was created with unknown prop '${key}'`);
  });
  const func2 = (child) => {
    portalTarget == null ? void 0 : portalTarget.add(child);
  };
  const func_1 = (child) => {
    portalTarget == null ? void 0 : portalTarget.remove(child);
  };
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(2, id = $$props2.id);
    if ("object" in $$props2)
      $$invalidate(3, object = $$props2.object);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    HierarchicalObject: HierarchicalObject_default,
    usePortalContext,
    id,
    object,
    getPortal,
    portal,
    portalTarget,
    $portal
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(2, id = $$props2.id);
    if ("object" in $$props2)
      $$invalidate(3, object = $$props2.object);
    if ("portalTarget" in $$props2)
      $$invalidate(0, portalTarget = $$props2.portalTarget);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*object, $portal*/
    24) {
      $:
        $$invalidate(0, portalTarget = object ?? $portal);
    }
  };
  return [portalTarget, portal, id, object, $portal, slots, func2, func_1, $$scope];
}
var Portal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { id: 2, object: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Portal",
      options,
      id: create_fragment18.name
    });
  }
  get id() {
    throw new Error("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get object() {
    throw new Error("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set object(value) {
    throw new Error("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Portal_default = Portal;

// node_modules/@threlte/extras/dist/components/portals/PortalTarget/PortalTarget.svelte
var { Error: Error_17 } = globals;
function create_fragment19(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let $parent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PortalTarget", slots, []);
  const parent = useParent();
  validate_store(parent, "parent");
  component_subscribe($$self, parent, (value) => $$invalidate(2, $parent = value));
  if (!$parent) {
    throw new Error("<PortalTarget> must be used within a <Canvas> component.");
  }
  let { id = "default" } = $$props;
  const { addPortal, removePortal } = usePortalContext();
  watch(parent, (parent2) => {
    if (!parent2)
      return;
    addPortal(parent2, id);
    return () => {
      removePortal(id);
    };
  });
  const writable_props = ["id"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PortalTarget> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
  };
  $$self.$capture_state = () => ({
    useParent,
    watch,
    usePortalContext,
    parent,
    id,
    addPortal,
    removePortal,
    $parent
  });
  $$self.$inject_state = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [parent, id];
}
var PortalTarget = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { id: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PortalTarget",
      options,
      id: create_fragment19.name
    });
  }
  get id() {
    throw new Error_17("<PortalTarget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error_17("<PortalTarget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PortalTarget_default = PortalTarget;

// node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js
function BespokeThenable() {
  var state = 0;
  var queue = [];
  var value;
  var scheduled = 0;
  var completeCalled = 0;
  function then(onResolve, onReject) {
    var nextThenable = BespokeThenable();
    function handleNext() {
      var cb = state > 0 ? onResolve : onReject;
      if (isFn(cb)) {
        try {
          var result = cb(value);
          if (result === nextThenable) {
            recursiveError();
          }
          var resultThen = getThenableThen(result);
          if (resultThen) {
            resultThen.call(result, nextThenable.resolve, nextThenable.reject);
          } else {
            nextThenable.resolve(result);
          }
        } catch (err) {
          nextThenable.reject(err);
        }
      } else {
        nextThenable[state > 0 ? "resolve" : "reject"](value);
      }
    }
    queue.push(handleNext);
    if (state) {
      scheduleQueueFlush();
    }
    return nextThenable;
  }
  var resolve = oneTime(function(val) {
    if (!completeCalled) {
      complete(1, val);
    }
  });
  var reject = oneTime(function(reason) {
    if (!completeCalled) {
      complete(-1, reason);
    }
  });
  function complete(st, val) {
    completeCalled++;
    var ignoreThrow = 0;
    try {
      if (val === thenableObj) {
        recursiveError();
      }
      var valThen = st > 0 && getThenableThen(val);
      if (valThen) {
        valThen.call(val, oneTime(function(v) {
          ignoreThrow++;
          complete(1, v);
        }), oneTime(function(v) {
          ignoreThrow++;
          complete(-1, v);
        }));
      } else {
        state = st;
        value = val;
        scheduleQueueFlush();
      }
    } catch (e) {
      if (!state && !ignoreThrow) {
        complete(-1, e);
      }
    }
  }
  function scheduleQueueFlush() {
    if (!scheduled) {
      setTimeout(flushQueue, 0);
      scheduled = 1;
    }
  }
  function flushQueue() {
    var q = queue;
    scheduled = 0;
    queue = [];
    q.forEach(callIt);
  }
  function callIt(fn) {
    fn();
  }
  function getThenableThen(val) {
    var valThen = val && (isFn(val) || typeof val === "object") && val.then;
    return isFn(valThen) && valThen;
  }
  function oneTime(fn) {
    var called = 0;
    return function() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      if (!called++) {
        fn.apply(this, args);
      }
    };
  }
  function recursiveError() {
    throw new TypeError("Chaining cycle detected");
  }
  var isFn = function(v) {
    return typeof v === "function";
  };
  var thenableObj = {
    then,
    resolve,
    reject
  };
  return thenableObj;
}
function NativePromiseThenable() {
  var resolve, reject;
  var promise = new Promise(function(res, rej) {
    resolve = res;
    reject = rej;
  });
  return {
    then: promise.then.bind(promise),
    resolve,
    reject
  };
}
BespokeThenable.all = NativePromiseThenable.all = function(items) {
  var resultCount = 0;
  var results = [];
  var out = DefaultThenable();
  if (items.length === 0) {
    out.resolve([]);
  } else {
    items.forEach(function(item, i) {
      var itemThenable = DefaultThenable();
      itemThenable.resolve(item);
      itemThenable.then(function(res) {
        resultCount++;
        results[i] = res;
        if (resultCount === items.length) {
          out.resolve(results);
        }
      }, out.reject);
    });
  }
  return out;
};
var DefaultThenable = typeof Promise === "function" ? NativePromiseThenable : BespokeThenable;
function workerBootstrap() {
  var modules = /* @__PURE__ */ Object.create(null);
  function registerModule(ref, callback) {
    var id = ref.id;
    var name = ref.name;
    var dependencies = ref.dependencies;
    if (dependencies === void 0)
      dependencies = [];
    var init2 = ref.init;
    if (init2 === void 0)
      init2 = function() {
      };
    var getTransferables = ref.getTransferables;
    if (getTransferables === void 0)
      getTransferables = null;
    if (modules[id]) {
      return;
    }
    try {
      dependencies = dependencies.map(function(dep) {
        if (dep && dep.isWorkerModule) {
          registerModule(dep, function(depResult) {
            if (depResult instanceof Error) {
              throw depResult;
            }
          });
          dep = modules[dep.id].value;
        }
        return dep;
      });
      init2 = rehydrate("<" + name + ">.init", init2);
      if (getTransferables) {
        getTransferables = rehydrate("<" + name + ">.getTransferables", getTransferables);
      }
      var value = null;
      if (typeof init2 === "function") {
        value = init2.apply(void 0, dependencies);
      } else {
        console.error("worker module init function failed to rehydrate");
      }
      modules[id] = {
        id,
        value,
        getTransferables
      };
      callback(value);
    } catch (err) {
      if (!(err && err.noLog)) {
        console.error(err);
      }
      callback(err);
    }
  }
  function callModule(ref, callback) {
    var ref$1;
    var id = ref.id;
    var args = ref.args;
    if (!modules[id] || typeof modules[id].value !== "function") {
      callback(new Error("Worker module " + id + ": not found or its 'init' did not return a function"));
    }
    try {
      var result = (ref$1 = modules[id]).value.apply(ref$1, args);
      if (result && typeof result.then === "function") {
        result.then(handleResult, function(rej) {
          return callback(rej instanceof Error ? rej : new Error("" + rej));
        });
      } else {
        handleResult(result);
      }
    } catch (err) {
      callback(err);
    }
    function handleResult(result2) {
      try {
        var tx = modules[id].getTransferables && modules[id].getTransferables(result2);
        if (!tx || !Array.isArray(tx) || !tx.length) {
          tx = void 0;
        }
        callback(result2, tx);
      } catch (err) {
        console.error(err);
        callback(err);
      }
    }
  }
  function rehydrate(name, str) {
    var result = void 0;
    self.troikaDefine = function(r) {
      return result = r;
    };
    var url = URL.createObjectURL(
      new Blob(
        ["/** " + name.replace(/\*/g, "") + " **/\n\ntroikaDefine(\n" + str + "\n)"],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(url);
    } catch (err) {
      console.error(err);
    }
    URL.revokeObjectURL(url);
    delete self.troikaDefine;
    return result;
  }
  self.addEventListener("message", function(e) {
    var ref = e.data;
    var messageId = ref.messageId;
    var action = ref.action;
    var data = ref.data;
    try {
      if (action === "registerModule") {
        registerModule(data, function(result) {
          if (result instanceof Error) {
            postMessage({
              messageId,
              success: false,
              error: result.message
            });
          } else {
            postMessage({
              messageId,
              success: true,
              result: { isCallable: typeof result === "function" }
            });
          }
        });
      }
      if (action === "callModule") {
        callModule(data, function(result, transferables) {
          if (result instanceof Error) {
            postMessage({
              messageId,
              success: false,
              error: result.message
            });
          } else {
            postMessage({
              messageId,
              success: true,
              result
            }, transferables || void 0);
          }
        });
      }
    } catch (err) {
      postMessage({
        messageId,
        success: false,
        error: err.stack
      });
    }
  });
}
function defineMainThreadModule(options) {
  var moduleFunc = function() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    return moduleFunc._getInitResult().then(function(initResult) {
      if (typeof initResult === "function") {
        return initResult.apply(void 0, args);
      } else {
        throw new Error("Worker module function was called but `init` did not return a callable function");
      }
    });
  };
  moduleFunc._getInitResult = function() {
    var dependencies = options.dependencies;
    var init2 = options.init;
    dependencies = Array.isArray(dependencies) ? dependencies.map(
      function(dep) {
        return dep && dep._getInitResult ? dep._getInitResult() : dep;
      }
    ) : [];
    var initThenable = DefaultThenable.all(dependencies).then(function(deps) {
      return init2.apply(null, deps);
    });
    moduleFunc._getInitResult = function() {
      return initThenable;
    };
    return initThenable;
  };
  return moduleFunc;
}
var supportsWorkers = function() {
  var supported = false;
  if (typeof window !== "undefined" && typeof window.document !== "undefined") {
    try {
      var worker = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      worker.terminate();
      supported = true;
    } catch (err) {
      if (typeof process !== "undefined" && false)
        ;
      else {
        console.log(
          "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + err.message + "]"
        );
      }
    }
  }
  supportsWorkers = function() {
    return supported;
  };
  return supported;
};
var _workerModuleId = 0;
var _messageId = 0;
var _allowInitAsString = false;
var workers = /* @__PURE__ */ Object.create(null);
var registeredModules = /* @__PURE__ */ Object.create(null);
var openRequests = /* @__PURE__ */ Object.create(null);
function defineWorkerModule(options) {
  if ((!options || typeof options.init !== "function") && !_allowInitAsString) {
    throw new Error("requires `options.init` function");
  }
  var dependencies = options.dependencies;
  var init2 = options.init;
  var getTransferables = options.getTransferables;
  var workerId = options.workerId;
  if (!supportsWorkers()) {
    return defineMainThreadModule(options);
  }
  if (workerId == null) {
    workerId = "#default";
  }
  var id = "workerModule" + ++_workerModuleId;
  var name = options.name || id;
  var registrationThenable = null;
  dependencies = dependencies && dependencies.map(function(dep) {
    if (typeof dep === "function" && !dep.workerModuleData) {
      _allowInitAsString = true;
      dep = defineWorkerModule({
        workerId,
        name: "<" + name + "> function dependency: " + dep.name,
        init: "function(){return (\n" + stringifyFunction(dep) + "\n)}"
      });
      _allowInitAsString = false;
    }
    if (dep && dep.workerModuleData) {
      dep = dep.workerModuleData;
    }
    return dep;
  });
  function moduleFunc() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    if (!registrationThenable) {
      registrationThenable = callWorker(workerId, "registerModule", moduleFunc.workerModuleData);
      var unregister = function() {
        registrationThenable = null;
        registeredModules[workerId].delete(unregister);
      };
      (registeredModules[workerId] || (registeredModules[workerId] = /* @__PURE__ */ new Set())).add(unregister);
    }
    return registrationThenable.then(function(ref) {
      var isCallable = ref.isCallable;
      if (isCallable) {
        return callWorker(workerId, "callModule", { id, args });
      } else {
        throw new Error("Worker module function was called but `init` did not return a callable function");
      }
    });
  }
  moduleFunc.workerModuleData = {
    isWorkerModule: true,
    id,
    name,
    dependencies,
    init: stringifyFunction(init2),
    getTransferables: getTransferables && stringifyFunction(getTransferables)
  };
  return moduleFunc;
}
function terminateWorker(workerId) {
  if (registeredModules[workerId]) {
    registeredModules[workerId].forEach(function(unregister) {
      unregister();
    });
  }
  if (workers[workerId]) {
    workers[workerId].terminate();
    delete workers[workerId];
  }
}
function stringifyFunction(fn) {
  var str = fn.toString();
  if (!/^function/.test(str) && /^\w+\s*\(/.test(str)) {
    str = "function " + str;
  }
  return str;
}
function getWorker(workerId) {
  var worker = workers[workerId];
  if (!worker) {
    var bootstrap = stringifyFunction(workerBootstrap);
    worker = workers[workerId] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + workerId.replace(/\*/g, "") + " **/\n\n;(" + bootstrap + ")()"],
          { type: "application/javascript" }
        )
      )
    );
    worker.onmessage = function(e) {
      var response = e.data;
      var msgId = response.messageId;
      var callback = openRequests[msgId];
      if (!callback) {
        throw new Error("WorkerModule response with empty or unknown messageId");
      }
      delete openRequests[msgId];
      callback(response);
    };
  }
  return worker;
}
function callWorker(workerId, action, data) {
  var thenable = DefaultThenable();
  var messageId = ++_messageId;
  openRequests[messageId] = function(response) {
    if (response.success) {
      thenable.resolve(response.result);
    } else {
      thenable.reject(new Error("Error in worker " + action + " call: " + response.error));
    }
  };
  getWorker(workerId).postMessage({
    messageId,
    action,
    data
  });
  return thenable;
}
var ThenableWorkerModule = defineWorkerModule({
  name: "Thenable",
  dependencies: [DefaultThenable],
  init: function(Thenable) {
    return Thenable;
  }
});

// node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs
function SDFGenerator() {
  var exports = function(exports2) {
    function pointOnQuadraticBezier(x0, y0, x1, y1, x2, y2, t2, pointOut) {
      var t22 = 1 - t2;
      pointOut.x = t22 * t22 * x0 + 2 * t22 * t2 * x1 + t2 * t2 * x2;
      pointOut.y = t22 * t22 * y0 + 2 * t22 * t2 * y1 + t2 * t2 * y2;
    }
    function pointOnCubicBezier(x0, y0, x1, y1, x2, y2, x3, y3, t2, pointOut) {
      var t22 = 1 - t2;
      pointOut.x = t22 * t22 * t22 * x0 + 3 * t22 * t22 * t2 * x1 + 3 * t22 * t2 * t2 * x2 + t2 * t2 * t2 * x3;
      pointOut.y = t22 * t22 * t22 * y0 + 3 * t22 * t22 * t2 * y1 + 3 * t22 * t2 * t2 * y2 + t2 * t2 * t2 * y3;
    }
    function forEachPathCommand(pathString, commandCallback) {
      var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;
      var match, firstX, firstY, prevX, prevY;
      while (match = segmentRE.exec(pathString)) {
        var args = match[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(v) {
          return parseFloat(v);
        });
        switch (match[1]) {
          case "M":
            prevX = firstX = args[0];
            prevY = firstY = args[1];
            break;
          case "L":
            if (args[0] !== prevX || args[1] !== prevY) {
              commandCallback("L", prevX, prevY, prevX = args[0], prevY = args[1]);
            }
            break;
          case "Q": {
            commandCallback("Q", prevX, prevY, prevX = args[2], prevY = args[3], args[0], args[1]);
            break;
          }
          case "C": {
            commandCallback("C", prevX, prevY, prevX = args[4], prevY = args[5], args[0], args[1], args[2], args[3]);
            break;
          }
          case "Z":
            if (prevX !== firstX || prevY !== firstY) {
              commandCallback("L", prevX, prevY, firstX, firstY);
            }
            break;
        }
      }
    }
    function pathToLineSegments(pathString, segmentCallback, curvePoints) {
      if (curvePoints === void 0)
        curvePoints = 16;
      var tempPoint = { x: 0, y: 0 };
      forEachPathCommand(pathString, function(command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {
        switch (command) {
          case "L":
            segmentCallback(startX, startY, endX, endY);
            break;
          case "Q": {
            var prevCurveX = startX;
            var prevCurveY = startY;
            for (var i = 1; i < curvePoints; i++) {
              pointOnQuadraticBezier(
                startX,
                startY,
                ctrl1X,
                ctrl1Y,
                endX,
                endY,
                i / (curvePoints - 1),
                tempPoint
              );
              segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);
              prevCurveX = tempPoint.x;
              prevCurveY = tempPoint.y;
            }
            break;
          }
          case "C": {
            var prevCurveX$1 = startX;
            var prevCurveY$1 = startY;
            for (var i$1 = 1; i$1 < curvePoints; i$1++) {
              pointOnCubicBezier(
                startX,
                startY,
                ctrl1X,
                ctrl1Y,
                ctrl2X,
                ctrl2Y,
                endX,
                endY,
                i$1 / (curvePoints - 1),
                tempPoint
              );
              segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);
              prevCurveX$1 = tempPoint.x;
              prevCurveY$1 = tempPoint.y;
            }
            break;
          }
        }
      });
    }
    var viewportQuadVertex = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}";
    var copyTexFragment = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}";
    var cache = /* @__PURE__ */ new WeakMap();
    var glContextParams = {
      premultipliedAlpha: false,
      preserveDrawingBuffer: true,
      antialias: false,
      depth: false
    };
    function withWebGLContext(glOrCanvas, callback) {
      var gl = glOrCanvas.getContext ? glOrCanvas.getContext("webgl", glContextParams) : glOrCanvas;
      var wrapper = cache.get(gl);
      if (!wrapper) {
        let getExtension = function(name) {
          var ext = extensions[name];
          if (!ext) {
            ext = extensions[name] = gl.getExtension(name);
            if (!ext) {
              throw new Error(name + " not supported");
            }
          }
          return ext;
        }, compileShader = function(src, type) {
          var shader = gl.createShader(type);
          gl.shaderSource(shader, src);
          gl.compileShader(shader);
          return shader;
        }, withProgram = function(name, vert, frag, func2) {
          if (!programs[name]) {
            var attributes = {};
            var uniforms = {};
            var program = gl.createProgram();
            gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));
            gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));
            gl.linkProgram(program);
            programs[name] = {
              program,
              transaction: function transaction(func3) {
                gl.useProgram(program);
                func3({
                  setUniform: function setUniform(type, name2) {
                    var values = [], len = arguments.length - 2;
                    while (len-- > 0)
                      values[len] = arguments[len + 2];
                    var uniformLoc = uniforms[name2] || (uniforms[name2] = gl.getUniformLocation(program, name2));
                    gl["uniform" + type].apply(gl, [uniformLoc].concat(values));
                  },
                  setAttribute: function setAttribute(name2, size, usage, instancingDivisor, data) {
                    var attr = attributes[name2];
                    if (!attr) {
                      attr = attributes[name2] = {
                        buf: gl.createBuffer(),
                        // TODO should we destroy our buffers?
                        loc: gl.getAttribLocation(program, name2),
                        data: null
                      };
                    }
                    gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);
                    gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);
                    gl.enableVertexAttribArray(attr.loc);
                    if (isWebGL2) {
                      gl.vertexAttribDivisor(attr.loc, instancingDivisor);
                    } else {
                      getExtension("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(attr.loc, instancingDivisor);
                    }
                    if (data !== attr.data) {
                      gl.bufferData(gl.ARRAY_BUFFER, data, usage);
                      attr.data = data;
                    }
                  }
                });
              }
            };
          }
          programs[name].transaction(func2);
        }, withTexture = function(name, func2) {
          textureUnit++;
          try {
            gl.activeTexture(gl.TEXTURE0 + textureUnit);
            var texture = textures[name];
            if (!texture) {
              texture = textures[name] = gl.createTexture();
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            }
            gl.bindTexture(gl.TEXTURE_2D, texture);
            func2(texture, textureUnit);
          } finally {
            textureUnit--;
          }
        }, withTextureFramebuffer = function(texture, textureUnit2, func2) {
          var framebuffer = gl.createFramebuffer();
          framebufferStack.push(framebuffer);
          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
          gl.activeTexture(gl.TEXTURE0 + textureUnit2);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          try {
            func2(framebuffer);
          } finally {
            gl.deleteFramebuffer(framebuffer);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);
          }
        }, handleContextLoss = function() {
          extensions = {};
          programs = {};
          textures = {};
          textureUnit = -1;
          framebufferStack.length = 0;
        };
        var isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext;
        var extensions = {};
        var programs = {};
        var textures = {};
        var textureUnit = -1;
        var framebufferStack = [];
        gl.canvas.addEventListener("webglcontextlost", function(e) {
          handleContextLoss();
          e.preventDefault();
        }, false);
        cache.set(gl, wrapper = {
          gl,
          isWebGL2,
          getExtension,
          withProgram,
          withTexture,
          withTextureFramebuffer,
          handleContextLoss
        });
      }
      callback(wrapper);
    }
    function renderImageData(glOrCanvas, imageData, x2, y, width, height, channels, framebuffer) {
      if (channels === void 0)
        channels = 15;
      if (framebuffer === void 0)
        framebuffer = null;
      withWebGLContext(glOrCanvas, function(ref) {
        var gl = ref.gl;
        var withProgram = ref.withProgram;
        var withTexture = ref.withTexture;
        withTexture("copy", function(tex, texUnit) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
          withProgram("copy", viewportQuadVertex, copyTexFragment, function(ref2) {
            var setUniform = ref2.setUniform;
            var setAttribute = ref2.setAttribute;
            setAttribute("aUV", 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));
            setUniform("1i", "image", texUnit);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);
            gl.disable(gl.BLEND);
            gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);
            gl.viewport(x2, y, width, height);
            gl.scissor(x2, y, width, height);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function resizeWebGLCanvasWithoutClearing2(canvas, newWidth, newHeight) {
      var width = canvas.width;
      var height = canvas.height;
      withWebGLContext(canvas, function(ref) {
        var gl = ref.gl;
        var data = new Uint8Array(width * height * 4);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);
        canvas.width = newWidth;
        canvas.height = newHeight;
        renderImageData(gl, data, 0, 0, width, height);
      });
    }
    var webglUtils = Object.freeze({
      __proto__: null,
      withWebGLContext,
      renderImageData,
      resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing2
    });
    function generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      var textureData = new Uint8Array(sdfWidth * sdfHeight);
      var viewBoxWidth = viewBox[2] - viewBox[0];
      var viewBoxHeight = viewBox[3] - viewBox[1];
      var segments = [];
      pathToLineSegments(path, function(x1, y1, x2, y2) {
        segments.push({
          x1,
          y1,
          x2,
          y2,
          minX: Math.min(x1, x2),
          minY: Math.min(y1, y2),
          maxX: Math.max(x1, x2),
          maxY: Math.max(y1, y2)
        });
      });
      segments.sort(function(a, b) {
        return a.maxX - b.maxX;
      });
      for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {
        for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {
          var signedDist = findNearestSignedDistance(
            viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth,
            viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight
          );
          var alpha = Math.pow(1 - Math.abs(signedDist) / maxDistance, sdfExponent) / 2;
          if (signedDist < 0) {
            alpha = 1 - alpha;
          }
          alpha = Math.max(0, Math.min(255, Math.round(alpha * 255)));
          textureData[sdfY * sdfWidth + sdfX] = alpha;
        }
      }
      return textureData;
      function findNearestSignedDistance(x2, y) {
        var closestDistSq = Infinity;
        var closestDist = Infinity;
        for (var i = segments.length; i--; ) {
          var seg = segments[i];
          if (seg.maxX + closestDist <= x2) {
            break;
          }
          if (x2 + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {
            var distSq = absSquareDistanceToLineSegment(x2, y, seg.x1, seg.y1, seg.x2, seg.y2);
            if (distSq < closestDistSq) {
              closestDistSq = distSq;
              closestDist = Math.sqrt(closestDistSq);
            }
          }
        }
        if (isPointInPoly(x2, y)) {
          closestDist = -closestDist;
        }
        return closestDist;
      }
      function isPointInPoly(x2, y) {
        var winding = 0;
        for (var i = segments.length; i--; ) {
          var seg = segments[i];
          if (seg.maxX <= x2) {
            break;
          }
          var intersects = seg.y1 > y !== seg.y2 > y && x2 < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1;
          if (intersects) {
            winding += seg.y1 < seg.y2 ? 1 : -1;
          }
        }
        return winding !== 0;
      }
    }
    function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x2, y, channel) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (x2 === void 0)
        x2 = 0;
      if (y === void 0)
        y = 0;
      if (channel === void 0)
        channel = 0;
      generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x2, y, channel);
    }
    function generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x2, y, channel) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (x2 === void 0)
        x2 = 0;
      if (y === void 0)
        y = 0;
      if (channel === void 0)
        channel = 0;
      var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);
      var rgbaData = new Uint8Array(data.length * 4);
      for (var i = 0; i < data.length; i++) {
        rgbaData[i * 4 + channel] = data[i];
      }
      renderImageData(glOrCanvas, rgbaData, x2, y, sdfWidth, sdfHeight, 1 << 3 - channel, framebuffer);
    }
    function absSquareDistanceToLineSegment(x2, y, lineX0, lineY0, lineX1, lineY1) {
      var ldx = lineX1 - lineX0;
      var ldy = lineY1 - lineY0;
      var lengthSq = ldx * ldx + ldy * ldy;
      var t2 = lengthSq ? Math.max(0, Math.min(1, ((x2 - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;
      var dx = x2 - (lineX0 + t2 * ldx);
      var dy = y - (lineY0 + t2 * ldy);
      return dx * dx + dy * dy;
    }
    var javascript = Object.freeze({
      __proto__: null,
      generate: generate$2,
      generateIntoCanvas: generateIntoCanvas$2,
      generateIntoFramebuffer: generateIntoFramebuffer$1
    });
    var mainVertex = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}";
    var mainFragment = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}";
    var postFragment = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}";
    var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);
    var implicitContext = null;
    var isTestingSupport = false;
    var NULL_OBJECT = {};
    var supportByCanvas = /* @__PURE__ */ new WeakMap();
    function validateSupport(glOrCanvas) {
      if (!isTestingSupport && !isSupported(glOrCanvas)) {
        throw new Error("WebGL generation not supported");
      }
    }
    function generate$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (glOrCanvas === void 0)
        glOrCanvas = null;
      if (!glOrCanvas) {
        glOrCanvas = implicitContext;
        if (!glOrCanvas) {
          var canvas = typeof OffscreenCanvas === "function" ? new OffscreenCanvas(1, 1) : typeof document !== "undefined" ? document.createElement("canvas") : null;
          if (!canvas) {
            throw new Error("OffscreenCanvas or DOM canvas not supported");
          }
          glOrCanvas = implicitContext = canvas.getContext("webgl", { depth: false });
        }
      }
      validateSupport(glOrCanvas);
      var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4);
      withWebGLContext(glOrCanvas, function(ref) {
        var gl = ref.gl;
        var withTexture = ref.withTexture;
        var withTextureFramebuffer = ref.withTextureFramebuffer;
        withTexture("readable", function(texture, textureUnit) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          withTextureFramebuffer(texture, textureUnit, function(framebuffer) {
            generateIntoFramebuffer(
              sdfWidth,
              sdfHeight,
              path,
              viewBox,
              maxDistance,
              sdfExponent,
              gl,
              framebuffer,
              0,
              0,
              0
              // red channel
            );
            gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);
          });
        });
      });
      var data = new Uint8Array(sdfWidth * sdfHeight);
      for (var i = 0, j = 0; i < rgbaData.length; i += 4) {
        data[j++] = rgbaData[i];
      }
      return data;
    }
    function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x2, y, channel) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (x2 === void 0)
        x2 = 0;
      if (y === void 0)
        y = 0;
      if (channel === void 0)
        channel = 0;
      generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x2, y, channel);
    }
    function generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x2, y, channel) {
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (x2 === void 0)
        x2 = 0;
      if (y === void 0)
        y = 0;
      if (channel === void 0)
        channel = 0;
      validateSupport(glOrCanvas);
      var lineSegmentCoords = [];
      pathToLineSegments(path, function(x1, y1, x22, y2) {
        lineSegmentCoords.push(x1, y1, x22, y2);
      });
      lineSegmentCoords = new Float32Array(lineSegmentCoords);
      withWebGLContext(glOrCanvas, function(ref) {
        var gl = ref.gl;
        var isWebGL2 = ref.isWebGL2;
        var getExtension = ref.getExtension;
        var withProgram = ref.withProgram;
        var withTexture = ref.withTexture;
        var withTextureFramebuffer = ref.withTextureFramebuffer;
        var handleContextLoss = ref.handleContextLoss;
        withTexture("rawDistances", function(intermediateTexture, intermediateTextureUnit) {
          if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {
            gl.texImage2D(
              gl.TEXTURE_2D,
              0,
              gl.RGBA,
              intermediateTexture._lastWidth = sdfWidth,
              intermediateTexture._lastHeight = sdfHeight,
              0,
              gl.RGBA,
              gl.UNSIGNED_BYTE,
              null
            );
          }
          withProgram("main", mainVertex, mainFragment, function(ref2) {
            var setAttribute = ref2.setAttribute;
            var setUniform = ref2.setUniform;
            var instancingExtension = !isWebGL2 && getExtension("ANGLE_instanced_arrays");
            var blendMinMaxExtension = !isWebGL2 && getExtension("EXT_blend_minmax");
            setAttribute("aUV", 2, gl.STATIC_DRAW, 0, viewportUVs);
            setAttribute("aLineSegment", 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);
            setUniform.apply(void 0, ["4f", "uGlyphBounds"].concat(viewBox));
            setUniform("1f", "uMaxDistance", maxDistance);
            setUniform("1f", "uExponent", sdfExponent);
            withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function(framebuffer2) {
              gl.enable(gl.BLEND);
              gl.colorMask(true, true, true, true);
              gl.viewport(0, 0, sdfWidth, sdfHeight);
              gl.scissor(0, 0, sdfWidth, sdfHeight);
              gl.blendFunc(gl.ONE, gl.ONE);
              gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);
              gl.clear(gl.COLOR_BUFFER_BIT);
              if (isWebGL2) {
                gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);
              } else {
                instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);
              }
            });
          });
          withProgram("post", viewportQuadVertex, postFragment, function(program) {
            program.setAttribute("aUV", 2, gl.STATIC_DRAW, 0, viewportUVs);
            program.setUniform("1i", "tex", intermediateTextureUnit);
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.disable(gl.BLEND);
            gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);
            gl.viewport(x2, y, sdfWidth, sdfHeight);
            gl.scissor(x2, y, sdfWidth, sdfHeight);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
          });
        });
        if (gl.isContextLost()) {
          handleContextLoss();
          throw new Error("webgl context lost");
        }
      });
    }
    function isSupported(glOrCanvas) {
      var key = !glOrCanvas || glOrCanvas === implicitContext ? NULL_OBJECT : glOrCanvas.canvas || glOrCanvas;
      var supported = supportByCanvas.get(key);
      if (supported === void 0) {
        isTestingSupport = true;
        var failReason = null;
        try {
          var expectedResult = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ];
          var testResult = generate$1(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            glOrCanvas
          );
          supported = testResult && expectedResult.length === testResult.length && testResult.every(function(val, i) {
            return val === expectedResult[i];
          });
          if (!supported) {
            failReason = "bad trial run results";
            console.info(expectedResult, testResult);
          }
        } catch (err) {
          supported = false;
          failReason = err.message;
        }
        if (failReason) {
          console.warn("WebGL SDF generation not supported:", failReason);
        }
        isTestingSupport = false;
        supportByCanvas.set(key, supported);
      }
      return supported;
    }
    var webgl = Object.freeze({
      __proto__: null,
      generate: generate$1,
      generateIntoCanvas: generateIntoCanvas$1,
      generateIntoFramebuffer,
      isSupported
    });
    function generate(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {
      if (maxDistance === void 0)
        maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;
      if (sdfExponent === void 0)
        sdfExponent = 1;
      try {
        return generate$1.apply(webgl, arguments);
      } catch (e) {
        console.info("WebGL SDF generation failed, falling back to JS", e);
        return generate$2.apply(javascript, arguments);
      }
    }
    function generateIntoCanvas(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x2, y, channel) {
      if (maxDistance === void 0)
        maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;
      if (sdfExponent === void 0)
        sdfExponent = 1;
      if (x2 === void 0)
        x2 = 0;
      if (y === void 0)
        y = 0;
      if (channel === void 0)
        channel = 0;
      try {
        return generateIntoCanvas$1.apply(webgl, arguments);
      } catch (e) {
        console.info("WebGL SDF generation failed, falling back to JS", e);
        return generateIntoCanvas$2.apply(javascript, arguments);
      }
    }
    exports2.forEachPathCommand = forEachPathCommand;
    exports2.generate = generate;
    exports2.generateIntoCanvas = generateIntoCanvas;
    exports2.javascript = javascript;
    exports2.pathToLineSegments = pathToLineSegments;
    exports2.webgl = webgl;
    exports2.webglUtils = webglUtils;
    Object.defineProperty(exports2, "__esModule", { value: true });
    return exports2;
  }({});
  return exports;
}

// node_modules/bidi-js/dist/bidi.mjs
function bidiFactory() {
  var bidi = function(exports) {
    var DATA = {
      "R": "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      "EN": "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      "ES": "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      "ET": "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      "AN": "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      "CS": "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      "B": "a,3,f+2,2v,690",
      "S": "9,2,k",
      "WS": "c,k,4f4,1vk+a,u,1j,335",
      "ON": "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      "BN": "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      "NSM": "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      "AL": "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      "LRO": "6ct",
      "RLO": "6cu",
      "LRE": "6cq",
      "RLE": "6cr",
      "PDF": "6cs",
      "LRI": "6ee",
      "RLI": "6ef",
      "FSI": "6eg",
      "PDI": "6eh"
    };
    var TYPES = {};
    var TYPES_TO_NAMES = {};
    TYPES.L = 1;
    TYPES_TO_NAMES[1] = "L";
    Object.keys(DATA).forEach(function(type, i) {
      TYPES[type] = 1 << i + 1;
      TYPES_TO_NAMES[TYPES[type]] = type;
    });
    Object.freeze(TYPES);
    var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;
    var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;
    var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;
    var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;
    var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;
    var map = null;
    function parseData() {
      if (!map) {
        map = /* @__PURE__ */ new Map();
        var loop = function(type2) {
          if (DATA.hasOwnProperty(type2)) {
            var lastCode = 0;
            DATA[type2].split(",").forEach(function(range) {
              var ref = range.split("+");
              var skip = ref[0];
              var step = ref[1];
              skip = parseInt(skip, 36);
              step = step ? parseInt(step, 36) : 0;
              map.set(lastCode += skip, TYPES[type2]);
              for (var i = 0; i < step; i++) {
                map.set(++lastCode, TYPES[type2]);
              }
            });
          }
        };
        for (var type in DATA)
          loop(type);
      }
    }
    function getBidiCharType(char) {
      parseData();
      return map.get(char.codePointAt(0)) || TYPES.L;
    }
    function getBidiCharTypeName(char) {
      return TYPES_TO_NAMES[getBidiCharType(char)];
    }
    var data$1 = {
      "pairs": "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      "canonical": "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function parseCharacterMap(encodedString, includeReverse) {
      var radix = 36;
      var lastCode = 0;
      var map2 = /* @__PURE__ */ new Map();
      var reverseMap = includeReverse && /* @__PURE__ */ new Map();
      var prevPair;
      encodedString.split(",").forEach(function visit(entry) {
        if (entry.indexOf("+") !== -1) {
          for (var i = +entry; i--; ) {
            visit(prevPair);
          }
        } else {
          prevPair = entry;
          var ref = entry.split(">");
          var a = ref[0];
          var b = ref[1];
          a = String.fromCodePoint(lastCode += parseInt(a, radix));
          b = String.fromCodePoint(lastCode += parseInt(b, radix));
          map2.set(a, b);
          includeReverse && reverseMap.set(b, a);
        }
      });
      return { map: map2, reverseMap };
    }
    var openToClose, closeToOpen, canonical;
    function parse$1() {
      if (!openToClose) {
        var ref = parseCharacterMap(data$1.pairs, true);
        var map2 = ref.map;
        var reverseMap = ref.reverseMap;
        openToClose = map2;
        closeToOpen = reverseMap;
        canonical = parseCharacterMap(data$1.canonical, false).map;
      }
    }
    function openingToClosingBracket(char) {
      parse$1();
      return openToClose.get(char) || null;
    }
    function closingToOpeningBracket(char) {
      parse$1();
      return closeToOpen.get(char) || null;
    }
    function getCanonicalBracket(char) {
      parse$1();
      return canonical.get(char) || null;
    }
    var TYPE_L = TYPES.L;
    var TYPE_R = TYPES.R;
    var TYPE_EN = TYPES.EN;
    var TYPE_ES = TYPES.ES;
    var TYPE_ET = TYPES.ET;
    var TYPE_AN = TYPES.AN;
    var TYPE_CS = TYPES.CS;
    var TYPE_B = TYPES.B;
    var TYPE_S = TYPES.S;
    var TYPE_ON = TYPES.ON;
    var TYPE_BN = TYPES.BN;
    var TYPE_NSM = TYPES.NSM;
    var TYPE_AL = TYPES.AL;
    var TYPE_LRO = TYPES.LRO;
    var TYPE_RLO = TYPES.RLO;
    var TYPE_LRE = TYPES.LRE;
    var TYPE_RLE = TYPES.RLE;
    var TYPE_PDF = TYPES.PDF;
    var TYPE_LRI = TYPES.LRI;
    var TYPE_RLI = TYPES.RLI;
    var TYPE_FSI = TYPES.FSI;
    var TYPE_PDI = TYPES.PDI;
    function getEmbeddingLevels(string, baseDirection) {
      var MAX_DEPTH = 125;
      var charTypes = new Uint32Array(string.length);
      for (var i = 0; i < string.length; i++) {
        charTypes[i] = getBidiCharType(string[i]);
      }
      var charTypeCounts = /* @__PURE__ */ new Map();
      function changeCharType(i2, type2) {
        var oldType = charTypes[i2];
        charTypes[i2] = type2;
        charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);
        if (oldType & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);
        }
        charTypeCounts.set(type2, (charTypeCounts.get(type2) || 0) + 1);
        if (type2 & NEUTRAL_ISOLATE_TYPES) {
          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
        }
      }
      var embedLevels = new Uint8Array(string.length);
      var isolationPairs = /* @__PURE__ */ new Map();
      var paragraphs = [];
      var paragraph = null;
      for (var i$1 = 0; i$1 < string.length; i$1++) {
        if (!paragraph) {
          paragraphs.push(paragraph = {
            start: i$1,
            end: string.length - 1,
            // 3.3.1 P2-P3: Determine the paragraph level
            level: baseDirection === "rtl" ? 1 : baseDirection === "ltr" ? 0 : determineAutoEmbedLevel(i$1, false)
          });
        }
        if (charTypes[i$1] & TYPE_B) {
          paragraph.end = i$1;
          paragraph = null;
        }
      }
      var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;
      var nextEven = function(n2) {
        return n2 + (n2 & 1 ? 1 : 2);
      };
      var nextOdd = function(n2) {
        return n2 + (n2 & 1 ? 2 : 1);
      };
      for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {
        paragraph = paragraphs[paraIdx];
        var statusStack = [{
          _level: paragraph.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }];
        var stackTop = void 0;
        var overflowIsolateCount = 0;
        var overflowEmbeddingCount = 0;
        var validIsolateCount = 0;
        charTypeCounts.clear();
        for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {
          var charType = charTypes[i$2];
          stackTop = statusStack[statusStack.length - 1];
          charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);
          if (charType & NEUTRAL_ISOLATE_TYPES) {
            charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);
          }
          if (charType & FORMATTING_TYPES) {
            if (charType & (TYPE_RLE | TYPE_LRE)) {
              embedLevels[i$2] = stackTop._level;
              var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);
              if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level,
                  _override: 0,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & (TYPE_RLO | TYPE_LRO)) {
              embedLevels[i$2] = stackTop._level;
              var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);
              if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {
                statusStack.push({
                  _level: level$1,
                  _override: charType & TYPE_RLO ? TYPE_R : TYPE_L,
                  _isolate: 0
                });
              } else if (!overflowIsolateCount) {
                overflowEmbeddingCount++;
              }
            } else if (charType & ISOLATE_INIT_TYPES) {
              if (charType & TYPE_FSI) {
                charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;
              }
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
              var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);
              if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {
                validIsolateCount++;
                statusStack.push({
                  _level: level$2,
                  _override: 0,
                  _isolate: 1,
                  _isolInitIndex: i$2
                });
              } else {
                overflowIsolateCount++;
              }
            } else if (charType & TYPE_PDI) {
              if (overflowIsolateCount > 0) {
                overflowIsolateCount--;
              } else if (validIsolateCount > 0) {
                overflowEmbeddingCount = 0;
                while (!statusStack[statusStack.length - 1]._isolate) {
                  statusStack.pop();
                }
                var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;
                if (isolInitIndex != null) {
                  isolationPairs.set(isolInitIndex, i$2);
                  isolationPairs.set(i$2, isolInitIndex);
                }
                statusStack.pop();
                validIsolateCount--;
              }
              stackTop = statusStack[statusStack.length - 1];
              embedLevels[i$2] = stackTop._level;
              if (stackTop._override) {
                changeCharType(i$2, stackTop._override);
              }
            } else if (charType & TYPE_PDF) {
              if (overflowIsolateCount === 0) {
                if (overflowEmbeddingCount > 0) {
                  overflowEmbeddingCount--;
                } else if (!stackTop._isolate && statusStack.length > 1) {
                  statusStack.pop();
                  stackTop = statusStack[statusStack.length - 1];
                }
              }
              embedLevels[i$2] = stackTop._level;
            } else if (charType & TYPE_B) {
              embedLevels[i$2] = paragraph.level;
            }
          } else {
            embedLevels[i$2] = stackTop._level;
            if (stackTop._override && charType !== TYPE_BN) {
              changeCharType(i$2, stackTop._override);
            }
          }
        }
        var levelRuns = [];
        var currentRun = null;
        for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {
          var charType$1 = charTypes[i$3];
          if (!(charType$1 & BN_LIKE_TYPES)) {
            var lvl = embedLevels[i$3];
            var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;
            var isPDI = charType$1 === TYPE_PDI;
            if (currentRun && lvl === currentRun._level) {
              currentRun._end = i$3;
              currentRun._endsWithIsolInit = isIsolInit;
            } else {
              levelRuns.push(currentRun = {
                _start: i$3,
                _end: i$3,
                _level: lvl,
                _startsWithPDI: isPDI,
                _endsWithIsolInit: isIsolInit
              });
            }
          }
        }
        var isolatingRunSeqs = [];
        for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {
          var run = levelRuns[runIdx];
          if (!run._startsWithPDI || run._startsWithPDI && !isolationPairs.has(run._start)) {
            var seqRuns = [currentRun = run];
            for (var pdiIndex = void 0; currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null; ) {
              for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {
                if (levelRuns[i$4]._start === pdiIndex) {
                  seqRuns.push(currentRun = levelRuns[i$4]);
                  break;
                }
              }
            }
            var seqIndices = [];
            for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {
              var run$1 = seqRuns[i$5];
              for (var j = run$1._start; j <= run$1._end; j++) {
                seqIndices.push(j);
              }
            }
            var firstLevel = embedLevels[seqIndices[0]];
            var prevLevel = paragraph.level;
            for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {
              if (!(charTypes[i$6] & BN_LIKE_TYPES)) {
                prevLevel = embedLevels[i$6];
                break;
              }
            }
            var lastIndex = seqIndices[seqIndices.length - 1];
            var lastLevel = embedLevels[lastIndex];
            var nextLevel = paragraph.level;
            if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {
              for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {
                if (!(charTypes[i$7] & BN_LIKE_TYPES)) {
                  nextLevel = embedLevels[i$7];
                  break;
                }
              }
            }
            isolatingRunSeqs.push({
              _seqIndices: seqIndices,
              _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,
              _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L
            });
          }
        }
        for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {
          var ref = isolatingRunSeqs[seqIdx];
          var seqIndices$1 = ref._seqIndices;
          var sosType = ref._sosType;
          var eosType = ref._eosType;
          if (charTypeCounts.get(TYPE_NSM)) {
            for (var si = 0; si < seqIndices$1.length; si++) {
              var i$8 = seqIndices$1[si];
              if (charTypes[i$8] & TYPE_NSM) {
                var prevType = sosType;
                for (var sj = si - 1; sj >= 0; sj--) {
                  if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) {
                    prevType = charTypes[seqIndices$1[sj]];
                    break;
                  }
                }
                changeCharType(i$8, prevType & (ISOLATE_INIT_TYPES | TYPE_PDI) ? TYPE_ON : prevType);
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {
              var i$9 = seqIndices$1[si$1];
              if (charTypes[i$9] & TYPE_EN) {
                for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {
                  var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];
                  if (prevCharType & STRONG_TYPES) {
                    if (prevCharType === TYPE_AL) {
                      changeCharType(i$9, TYPE_AN);
                    }
                    break;
                  }
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_AL)) {
            for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {
              var i$10 = seqIndices$1[si$2];
              if (charTypes[i$10] & TYPE_AL) {
                changeCharType(i$10, TYPE_R);
              }
            }
          }
          if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {
              var i$11 = seqIndices$1[si$3];
              if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {
                var prevType$1 = 0, nextType = 0;
                for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {
                  prevType$1 = charTypes[seqIndices$1[sj$2]];
                  if (!(prevType$1 & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {
                  nextType = charTypes[seqIndices$1[sj$3]];
                  if (!(nextType & BN_LIKE_TYPES)) {
                    break;
                  }
                }
                if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : prevType$1 & (TYPE_EN | TYPE_AN))) {
                  changeCharType(i$11, prevType$1);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {
              var i$12 = seqIndices$1[si$4];
              if (charTypes[i$12] & TYPE_EN) {
                for (var sj$4 = si$4 - 1; sj$4 >= 0 && charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES); sj$4--) {
                  changeCharType(seqIndices$1[sj$4], TYPE_EN);
                }
                for (var sj$5 = si$4 + 1; sj$5 < seqIndices$1.length && charTypes[seqIndices$1[sj$5]] & (TYPE_ET | BN_LIKE_TYPES); sj$5++) {
                  changeCharType(seqIndices$1[sj$5], TYPE_EN);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {
            for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {
              var i$13 = seqIndices$1[si$5];
              if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {
                changeCharType(i$13, TYPE_ON);
                for (var sj$6 = si$5 - 1; sj$6 >= 0 && charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES; sj$6--) {
                  changeCharType(seqIndices$1[sj$6], TYPE_ON);
                }
                for (var sj$7 = si$5 + 1; sj$7 < seqIndices$1.length && charTypes[seqIndices$1[sj$7]] & BN_LIKE_TYPES; sj$7++) {
                  changeCharType(seqIndices$1[sj$7], TYPE_ON);
                }
              }
            }
          }
          if (charTypeCounts.get(TYPE_EN)) {
            for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {
              var i$14 = seqIndices$1[si$6];
              var type = charTypes[i$14];
              if (type & TYPE_EN) {
                if (prevStrongType === TYPE_L) {
                  changeCharType(i$14, TYPE_L);
                }
              } else if (type & STRONG_TYPES) {
                prevStrongType = type;
              }
            }
          }
          if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {
            var R_TYPES_FOR_N_STEPS = TYPE_R | TYPE_EN | TYPE_AN;
            var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;
            var bracketPairs = [];
            {
              var openerStack = [];
              for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {
                if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {
                  var char = string[seqIndices$1[si$7]];
                  var oppositeBracket = void 0;
                  if (openingToClosingBracket(char) !== null) {
                    if (openerStack.length < 63) {
                      openerStack.push({ char, seqIndex: si$7 });
                    } else {
                      break;
                    }
                  } else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {
                    for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {
                      var stackChar = openerStack[stackIdx].char;
                      if (stackChar === oppositeBracket || stackChar === closingToOpeningBracket(getCanonicalBracket(char)) || openingToClosingBracket(getCanonicalBracket(stackChar)) === char) {
                        bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);
                        openerStack.length = stackIdx;
                        break;
                      }
                    }
                  }
                }
              }
              bracketPairs.sort(function(a, b) {
                return a[0] - b[0];
              });
            }
            for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {
              var ref$1 = bracketPairs[pairIdx];
              var openSeqIdx = ref$1[0];
              var closeSeqIdx = ref$1[1];
              var foundStrongType = false;
              var useStrongType = 0;
              for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {
                var i$15 = seqIndices$1[si$8];
                if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {
                  foundStrongType = true;
                  var lr = charTypes[i$15] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                  if (lr === getEmbedDirection(i$15)) {
                    useStrongType = lr;
                    break;
                  }
                }
              }
              if (foundStrongType && !useStrongType) {
                useStrongType = sosType;
                for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {
                  var i$16 = seqIndices$1[si$9];
                  if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {
                    var lr$1 = charTypes[i$16] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    if (lr$1 !== getEmbedDirection(i$16)) {
                      useStrongType = lr$1;
                    } else {
                      useStrongType = getEmbedDirection(i$16);
                    }
                    break;
                  }
                }
              }
              if (useStrongType) {
                charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;
                if (useStrongType !== getEmbedDirection(seqIndices$1[openSeqIdx])) {
                  for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {
                    if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$10]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
                if (useStrongType !== getEmbedDirection(seqIndices$1[closeSeqIdx])) {
                  for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {
                    if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {
                      if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {
                        charTypes[seqIndices$1[si$11]] = useStrongType;
                      }
                      break;
                    }
                  }
                }
              }
            }
            for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {
              if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {
                var niRunStart = si$12, niRunEnd = si$12;
                var prevType$2 = sosType;
                for (var si2 = si$12 - 1; si2 >= 0; si2--) {
                  if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {
                    niRunStart = si2;
                  } else {
                    prevType$2 = charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                var nextType$1 = eosType;
                for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {
                  if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {
                    niRunEnd = si2$1;
                  } else {
                    nextType$1 = charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;
                    break;
                  }
                }
                for (var sj$8 = niRunStart; sj$8 <= niRunEnd; sj$8++) {
                  charTypes[seqIndices$1[sj$8]] = prevType$2 === nextType$1 ? prevType$2 : getEmbedDirection(seqIndices$1[sj$8]);
                }
                si$12 = niRunEnd;
              }
            }
          }
        }
        for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {
          var level$3 = embedLevels[i$17];
          var type$1 = charTypes[i$17];
          if (level$3 & 1) {
            if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {
              embedLevels[i$17]++;
            }
          } else {
            if (type$1 & TYPE_R) {
              embedLevels[i$17]++;
            } else if (type$1 & (TYPE_AN | TYPE_EN)) {
              embedLevels[i$17] += 2;
            }
          }
          if (type$1 & BN_LIKE_TYPES) {
            embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];
          }
          if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {
            for (var j$1 = i$17; j$1 >= 0 && getBidiCharType(string[j$1]) & TRAILING_TYPES; j$1--) {
              embedLevels[j$1] = paragraph.level;
            }
          }
        }
      }
      return {
        levels: embedLevels,
        paragraphs
      };
      function determineAutoEmbedLevel(start, isFSI) {
        for (var i2 = start; i2 < string.length; i2++) {
          var charType2 = charTypes[i2];
          if (charType2 & (TYPE_R | TYPE_AL)) {
            return 1;
          }
          if (charType2 & (TYPE_B | TYPE_L) || isFSI && charType2 === TYPE_PDI) {
            return 0;
          }
          if (charType2 & ISOLATE_INIT_TYPES) {
            var pdi = indexOfMatchingPDI(i2);
            i2 = pdi === -1 ? string.length : pdi;
          }
        }
        return 0;
      }
      function indexOfMatchingPDI(isolateStart) {
        var isolationLevel = 1;
        for (var i2 = isolateStart + 1; i2 < string.length; i2++) {
          var charType2 = charTypes[i2];
          if (charType2 & TYPE_B) {
            break;
          }
          if (charType2 & TYPE_PDI) {
            if (--isolationLevel === 0) {
              return i2;
            }
          } else if (charType2 & ISOLATE_INIT_TYPES) {
            isolationLevel++;
          }
        }
        return -1;
      }
      function getEmbedDirection(i2) {
        return embedLevels[i2] & 1 ? TYPE_R : TYPE_L;
      }
    }
    var data = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1";
    var mirrorMap;
    function parse() {
      if (!mirrorMap) {
        var ref = parseCharacterMap(data, true);
        var map2 = ref.map;
        var reverseMap = ref.reverseMap;
        reverseMap.forEach(function(value, key) {
          map2.set(key, value);
        });
        mirrorMap = map2;
      }
    }
    function getMirroredCharacter(char) {
      parse();
      return mirrorMap.get(char) || null;
    }
    function getMirroredCharactersMap(string, embeddingLevels, start, end) {
      var strLen = string.length;
      start = Math.max(0, start == null ? 0 : +start);
      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);
      var map2 = /* @__PURE__ */ new Map();
      for (var i = start; i <= end; i++) {
        if (embeddingLevels[i] & 1) {
          var mirror = getMirroredCharacter(string[i]);
          if (mirror !== null) {
            map2.set(i, mirror);
          }
        }
      }
      return map2;
    }
    function getReorderSegments(string, embeddingLevelsResult, start, end) {
      var strLen = string.length;
      start = Math.max(0, start == null ? 0 : +start);
      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);
      var segments = [];
      embeddingLevelsResult.paragraphs.forEach(function(paragraph) {
        var lineStart = Math.max(start, paragraph.start);
        var lineEnd = Math.min(end, paragraph.end);
        if (lineStart < lineEnd) {
          var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);
          for (var i = lineEnd; i >= lineStart && getBidiCharType(string[i]) & TRAILING_TYPES; i--) {
            lineLevels[i] = paragraph.level;
          }
          var maxLevel = paragraph.level;
          var minOddLevel = Infinity;
          for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {
            var level = lineLevels[i$1];
            if (level > maxLevel) {
              maxLevel = level;
            }
            if (level < minOddLevel) {
              minOddLevel = level | 1;
            }
          }
          for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {
            for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {
              if (lineLevels[i$2] >= lvl) {
                var segStart = i$2;
                while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {
                  i$2++;
                }
                if (i$2 > segStart) {
                  segments.push([segStart + start, i$2 + start]);
                }
              }
            }
          }
        }
      });
      return segments;
    }
    function getReorderedString(string, embedLevelsResult, start, end) {
      var indices = getReorderedIndices(string, embedLevelsResult, start, end);
      var chars = [].concat(string);
      indices.forEach(function(charIndex, i) {
        chars[i] = (embedLevelsResult.levels[charIndex] & 1 ? getMirroredCharacter(string[charIndex]) : null) || string[charIndex];
      });
      return chars.join("");
    }
    function getReorderedIndices(string, embedLevelsResult, start, end) {
      var segments = getReorderSegments(string, embedLevelsResult, start, end);
      var indices = [];
      for (var i = 0; i < string.length; i++) {
        indices[i] = i;
      }
      segments.forEach(function(ref) {
        var start2 = ref[0];
        var end2 = ref[1];
        var slice = indices.slice(start2, end2 + 1);
        for (var i2 = slice.length; i2--; ) {
          indices[end2 - i2] = slice[i2];
        }
      });
      return indices;
    }
    exports.closingToOpeningBracket = closingToOpeningBracket;
    exports.getBidiCharType = getBidiCharType;
    exports.getBidiCharTypeName = getBidiCharTypeName;
    exports.getCanonicalBracket = getCanonicalBracket;
    exports.getEmbeddingLevels = getEmbeddingLevels;
    exports.getMirroredCharacter = getMirroredCharacter;
    exports.getMirroredCharactersMap = getMirroredCharactersMap;
    exports.getReorderSegments = getReorderSegments;
    exports.getReorderedIndices = getReorderedIndices;
    exports.getReorderedString = getReorderedString;
    exports.openingToClosingBracket = openingToClosingBracket;
    Object.defineProperty(exports, "__esModule", { value: true });
    return exports;
  }({});
  return bidi;
}
var bidi_default = bidiFactory;

// node_modules/troika-three-utils/dist/troika-three-utils.esm.js
var voidMainRegExp = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function expandShaderIncludes(source) {
  const pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function replace(match, include) {
    let chunk = ShaderChunk[include];
    return chunk ? expandShaderIncludes(chunk) : match;
  }
  return source.replace(pattern, replace);
}
var _lut = [];
for (let i = 0; i < 256; i++) {
  _lut[i] = (i < 16 ? "0" : "") + i.toString(16);
}
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toUpperCase();
}
var assign2 = Object.assign || function() {
  let target = arguments[0];
  for (let i = 1, len = arguments.length; i < len; i++) {
    let source = arguments[i];
    if (source) {
      for (let prop in source) {
        if (source.hasOwnProperty(prop)) {
          target[prop] = source[prop];
        }
      }
    }
  }
  return target;
};
var epoch = Date.now();
var CONSTRUCTOR_CACHE = /* @__PURE__ */ new WeakMap();
var SHADER_UPGRADE_CACHE = /* @__PURE__ */ new Map();
var materialInstanceId = 1e10;
function createDerivedMaterial(baseMaterial, options) {
  const optionsKey = getKeyForOptions(options);
  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);
  if (!ctorsByDerivation) {
    CONSTRUCTOR_CACHE.set(baseMaterial, ctorsByDerivation = /* @__PURE__ */ Object.create(null));
  }
  if (ctorsByDerivation[optionsKey]) {
    return new ctorsByDerivation[optionsKey]();
  }
  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;
  const onBeforeCompile = function(shaderInfo) {
    baseMaterial.onBeforeCompile.call(this, shaderInfo);
    const cacheKey = this.customProgramCacheKey() + "|" + shaderInfo.vertexShader + "|" + shaderInfo.fragmentShader;
    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];
    if (!upgradedShaders) {
      const upgraded = upgradeShaders(shaderInfo, options, optionsKey);
      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;
    }
    shaderInfo.vertexShader = upgradedShaders.vertexShader;
    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;
    assign2(shaderInfo.uniforms, this.uniforms);
    if (options.timeUniform) {
      shaderInfo.uniforms[options.timeUniform] = {
        get value() {
          return Date.now() - epoch;
        }
      };
    }
    if (this[privateBeforeCompileProp]) {
      this[privateBeforeCompileProp](shaderInfo);
    }
  };
  const DerivedMaterial = function DerivedMaterial2() {
    return derive(options.chained ? baseMaterial : baseMaterial.clone());
  };
  const derive = function(base) {
    const derived2 = Object.create(base, descriptor);
    Object.defineProperty(derived2, "baseMaterial", { value: baseMaterial });
    Object.defineProperty(derived2, "id", { value: materialInstanceId++ });
    derived2.uuid = generateUUID();
    derived2.uniforms = assign2({}, base.uniforms, options.uniforms);
    derived2.defines = assign2({}, base.defines, options.defines);
    derived2.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = "";
    derived2.extensions = assign2({}, base.extensions, options.extensions);
    derived2._listeners = void 0;
    return derived2;
  };
  const descriptor = {
    constructor: { value: DerivedMaterial },
    isDerivedMaterial: { value: true },
    customProgramCacheKey: {
      writable: true,
      configurable: true,
      value: function() {
        return baseMaterial.customProgramCacheKey() + "|" + optionsKey;
      }
    },
    onBeforeCompile: {
      get() {
        return onBeforeCompile;
      },
      set(fn) {
        this[privateBeforeCompileProp] = fn;
      }
    },
    copy: {
      writable: true,
      configurable: true,
      value: function(source) {
        baseMaterial.copy.call(this, source);
        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {
          assign2(this.extensions, source.extensions);
          assign2(this.defines, source.defines);
          assign2(this.uniforms, UniformsUtils.clone(source.uniforms));
        }
        return this;
      }
    },
    clone: {
      writable: true,
      configurable: true,
      value: function() {
        const newBase = new baseMaterial.constructor();
        return derive(newBase).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let depthMaterial = this._depthMaterial;
        if (!depthMaterial) {
          depthMaterial = this._depthMaterial = createDerivedMaterial(
            baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
            options
          );
          depthMaterial.defines.IS_DEPTH_MATERIAL = "";
          depthMaterial.uniforms = this.uniforms;
        }
        return depthMaterial;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: true,
      configurable: true,
      value: function() {
        let distanceMaterial = this._distanceMaterial;
        if (!distanceMaterial) {
          distanceMaterial = this._distanceMaterial = createDerivedMaterial(
            baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new MeshDistanceMaterial(),
            options
          );
          distanceMaterial.defines.IS_DISTANCE_MATERIAL = "";
          distanceMaterial.uniforms = this.uniforms;
        }
        return distanceMaterial;
      }
    },
    dispose: {
      writable: true,
      configurable: true,
      value() {
        const { _depthMaterial, _distanceMaterial } = this;
        if (_depthMaterial)
          _depthMaterial.dispose();
        if (_distanceMaterial)
          _distanceMaterial.dispose();
        baseMaterial.dispose.call(this);
      }
    }
  };
  ctorsByDerivation[optionsKey] = DerivedMaterial;
  return new DerivedMaterial();
}
function upgradeShaders({ vertexShader, fragmentShader }, options, key) {
  let {
    vertexDefs,
    vertexMainIntro,
    vertexMainOutro,
    vertexTransform,
    fragmentDefs,
    fragmentMainIntro,
    fragmentMainOutro,
    fragmentColorTransform,
    customRewriter,
    timeUniform
  } = options;
  vertexDefs = vertexDefs || "";
  vertexMainIntro = vertexMainIntro || "";
  vertexMainOutro = vertexMainOutro || "";
  fragmentDefs = fragmentDefs || "";
  fragmentMainIntro = fragmentMainIntro || "";
  fragmentMainOutro = fragmentMainOutro || "";
  if (vertexTransform || customRewriter) {
    vertexShader = expandShaderIncludes(vertexShader);
  }
  if (fragmentColorTransform || customRewriter) {
    fragmentShader = fragmentShader.replace(
      /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
      "\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n"
    );
    fragmentShader = expandShaderIncludes(fragmentShader);
  }
  if (customRewriter) {
    let res = customRewriter({ vertexShader, fragmentShader });
    vertexShader = res.vertexShader;
    fragmentShader = res.fragmentShader;
  }
  if (fragmentColorTransform) {
    let postChunks = [];
    fragmentShader = fragmentShader.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (match) => {
        postChunks.push(match);
        return "";
      }
    );
    fragmentMainOutro = `${fragmentColorTransform}
${postChunks.join("\n")}
${fragmentMainOutro}`;
  }
  if (timeUniform) {
    const code = `
uniform float ${timeUniform};
`;
    vertexDefs = code + vertexDefs;
    fragmentDefs = code + fragmentDefs;
  }
  if (vertexTransform) {
    vertexShader = `vec3 troika_position_${key};
vec3 troika_normal_${key};
vec2 troika_uv_${key};
${vertexShader}
`;
    vertexDefs = `${vertexDefs}
void troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${vertexTransform}
}
`;
    vertexMainIntro = `
troika_position_${key} = vec3(position);
troika_normal_${key} = vec3(normal);
troika_uv_${key} = vec2(uv);
troikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});
${vertexMainIntro}
`;
    vertexShader = vertexShader.replace(/\b(position|normal|uv)\b/g, (match, match1, index, fullStr) => {
      return /\battribute\s+vec[23]\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`;
    });
  }
  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);
  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);
  return {
    vertexShader,
    fragmentShader
  };
}
function injectIntoShaderCode(shaderCode, id, defs, intro, outro) {
  if (intro || outro || defs) {
    shaderCode = shaderCode.replace(
      voidMainRegExp,
      `
${defs}
void troikaOrigMain${id}() {`
    );
    shaderCode += `
void main() {
  ${intro}
  troikaOrigMain${id}();
  ${outro}
}`;
  }
  return shaderCode;
}
function optionsJsonReplacer(key, value) {
  return key === "uniforms" ? void 0 : typeof value === "function" ? value.toString() : value;
}
var _idCtr = 0;
var optionsHashesToIds = /* @__PURE__ */ new Map();
function getKeyForOptions(options) {
  const optionsHash = JSON.stringify(options, optionsJsonReplacer);
  let id = optionsHashesToIds.get(optionsHash);
  if (id == null) {
    optionsHashesToIds.set(optionsHash, id = ++_idCtr);
  }
  return id;
}
var defaultBaseMaterial = new MeshStandardMaterial({ color: 16777215, side: DoubleSide });

// node_modules/troika-three-text/dist/troika-three-text.esm.js
function createTypesetter(fontParser, bidi, config) {
  const {
    defaultFontURL
  } = config;
  const fonts = /* @__PURE__ */ Object.create(null);
  const INF = Infinity;
  const DEFAULT_IGNORABLE_CHARS = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/;
  const BREAK_AFTER_CHARS = /[\s\-\u007C\u00AD\u2010\u2012-\u2014\u2027\u2056\u2E17\u2E40]/;
  function doLoadFont(url, callback) {
    function tryLoad() {
      const onError = (err) => {
        console.error(`Failure loading font ${url}${url === defaultFontURL ? "" : "; trying fallback"}`, err);
        if (url !== defaultFontURL) {
          url = defaultFontURL;
          tryLoad();
        }
      };
      try {
        const request = new XMLHttpRequest();
        request.open("get", url, true);
        request.responseType = "arraybuffer";
        request.onload = function() {
          if (request.status >= 400) {
            onError(new Error(request.statusText));
          } else if (request.status > 0) {
            try {
              const fontObj = fontParser(request.response);
              callback(fontObj);
            } catch (e) {
              onError(e);
            }
          }
        };
        request.onerror = onError;
        request.send();
      } catch (err) {
        onError(err);
      }
    }
    tryLoad();
  }
  function loadFont(fontUrl, callback) {
    if (!fontUrl)
      fontUrl = defaultFontURL;
    let font = fonts[fontUrl];
    if (font) {
      if (font.pending) {
        font.pending.push(callback);
      } else {
        callback(font);
      }
    } else {
      fonts[fontUrl] = { pending: [callback] };
      doLoadFont(fontUrl, (fontObj) => {
        let callbacks = fonts[fontUrl].pending;
        fonts[fontUrl] = fontObj;
        callbacks.forEach((cb) => cb(fontObj));
      });
    }
  }
  function typeset({
    text = "",
    font = defaultFontURL,
    sdfGlyphSize = 64,
    fontSize = 1,
    letterSpacing = 0,
    lineHeight = "normal",
    maxWidth = INF,
    direction,
    textAlign = "left",
    textIndent = 0,
    whiteSpace = "normal",
    overflowWrap = "normal",
    anchorX = 0,
    anchorY = 0,
    includeCaretPositions = false,
    chunkedBoundsSize = 8192,
    colorRanges = null
  }, callback, metricsOnly = false) {
    const mainStart = now2();
    const timings = { fontLoad: 0, typesetting: 0 };
    if (text.indexOf("\r") > -1) {
      console.info("Typesetter: got text with \\r chars; normalizing to \\n");
      text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    }
    fontSize = +fontSize;
    letterSpacing = +letterSpacing;
    maxWidth = +maxWidth;
    lineHeight = lineHeight || "normal";
    textIndent = +textIndent;
    loadFont(font, (fontObj) => {
      const hasMaxWidth = isFinite(maxWidth);
      let glyphIds = null;
      let glyphPositions = null;
      let glyphData = null;
      let glyphColors = null;
      let caretPositions = null;
      let visibleBounds = null;
      let chunkedBounds = null;
      let maxLineWidth = 0;
      let renderableGlyphCount = 0;
      let canWrap = whiteSpace !== "nowrap";
      const { ascender, descender, unitsPerEm } = fontObj;
      timings.fontLoad = now2() - mainStart;
      const typesetStart = now2();
      const fontSizeMult = fontSize / unitsPerEm;
      if (lineHeight === "normal") {
        lineHeight = (ascender - descender) / unitsPerEm;
      }
      lineHeight = lineHeight * fontSize;
      const halfLeading = (lineHeight - (ascender - descender) * fontSizeMult) / 2;
      const topBaseline = -(ascender * fontSizeMult + halfLeading);
      const caretHeight = Math.min(lineHeight, (ascender - descender) * fontSizeMult);
      const caretBottomOffset = (ascender + descender) / 2 * fontSizeMult - caretHeight / 2;
      let lineXOffset = textIndent;
      let currentLine = new TextLine();
      const lines = [currentLine];
      fontObj.forEachGlyph(text, fontSize, letterSpacing, (glyphObj, glyphX, charIndex) => {
        const char = text.charAt(charIndex);
        const glyphWidth = glyphObj.advanceWidth * fontSizeMult;
        const curLineCount = currentLine.count;
        let nextLine;
        if (!("isEmpty" in glyphObj)) {
          glyphObj.isWhitespace = !!char && /\s/.test(char);
          glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);
          glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);
        }
        if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
          renderableGlyphCount++;
        }
        if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {
          if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {
            nextLine = new TextLine();
            lineXOffset = -glyphX;
          } else {
            for (let i = curLineCount; i--; ) {
              if (i === 0 && overflowWrap === "break-word") {
                nextLine = new TextLine();
                lineXOffset = -glyphX;
                break;
              } else if (currentLine.glyphAt(i).glyphObj.canBreakAfter) {
                nextLine = currentLine.splitAt(i + 1);
                const adjustX = nextLine.glyphAt(0).x;
                lineXOffset -= adjustX;
                for (let j = nextLine.count; j--; ) {
                  nextLine.glyphAt(j).x -= adjustX;
                }
                break;
              }
            }
          }
          if (nextLine) {
            currentLine.isSoftWrapped = true;
            currentLine = nextLine;
            lines.push(currentLine);
            maxLineWidth = maxWidth;
          }
        }
        let fly = currentLine.glyphAt(currentLine.count);
        fly.glyphObj = glyphObj;
        fly.x = glyphX + lineXOffset;
        fly.width = glyphWidth;
        fly.charIndex = charIndex;
        if (char === "\n") {
          currentLine = new TextLine();
          lines.push(currentLine);
          lineXOffset = -(glyphX + glyphWidth + letterSpacing * fontSize) + textIndent;
        }
      });
      lines.forEach((line) => {
        for (let i = line.count; i--; ) {
          let { glyphObj, x: x2, width } = line.glyphAt(i);
          if (!glyphObj.isWhitespace) {
            line.width = x2 + width;
            if (line.width > maxLineWidth) {
              maxLineWidth = line.width;
            }
            return;
          }
        }
      });
      let anchorXOffset = 0;
      let anchorYOffset = 0;
      if (anchorX) {
        if (typeof anchorX === "number") {
          anchorXOffset = -anchorX;
        } else if (typeof anchorX === "string") {
          anchorXOffset = -maxLineWidth * (anchorX === "left" ? 0 : anchorX === "center" ? 0.5 : anchorX === "right" ? 1 : parsePercent(anchorX));
        }
      }
      if (anchorY) {
        if (typeof anchorY === "number") {
          anchorYOffset = -anchorY;
        } else if (typeof anchorY === "string") {
          let height = lines.length * lineHeight;
          anchorYOffset = anchorY === "top" ? 0 : anchorY === "top-baseline" ? -topBaseline : anchorY === "middle" ? height / 2 : anchorY === "bottom" ? height : anchorY === "bottom-baseline" ? height - halfLeading + descender * fontSizeMult : parsePercent(anchorY) * height;
        }
      }
      if (!metricsOnly) {
        const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction);
        glyphIds = new Uint16Array(renderableGlyphCount);
        glyphPositions = new Float32Array(renderableGlyphCount * 2);
        glyphData = {};
        visibleBounds = [INF, INF, -INF, -INF];
        chunkedBounds = [];
        let lineYOffset = topBaseline;
        if (includeCaretPositions) {
          caretPositions = new Float32Array(text.length * 3);
        }
        if (colorRanges) {
          glyphColors = new Uint8Array(renderableGlyphCount * 3);
        }
        let renderableGlyphIndex = 0;
        let prevCharIndex = -1;
        let colorCharIndex = -1;
        let chunk;
        let currentColor;
        lines.forEach((line, lineIndex) => {
          let { count: lineGlyphCount, width: lineWidth } = line;
          if (lineGlyphCount > 0) {
            let trailingWhitespaceCount = 0;
            for (let i = lineGlyphCount; i-- && line.glyphAt(i).glyphObj.isWhitespace; ) {
              trailingWhitespaceCount++;
            }
            let lineXOffset2 = 0;
            let justifyAdjust = 0;
            if (textAlign === "center") {
              lineXOffset2 = (maxLineWidth - lineWidth) / 2;
            } else if (textAlign === "right") {
              lineXOffset2 = maxLineWidth - lineWidth;
            } else if (textAlign === "justify" && line.isSoftWrapped) {
              let whitespaceCount = 0;
              for (let i = lineGlyphCount - trailingWhitespaceCount; i--; ) {
                if (line.glyphAt(i).glyphObj.isWhitespace) {
                  whitespaceCount++;
                }
              }
              justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;
            }
            if (justifyAdjust || lineXOffset2) {
              let justifyOffset = 0;
              for (let i = 0; i < lineGlyphCount; i++) {
                let glyphInfo = line.glyphAt(i);
                const glyphObj2 = glyphInfo.glyphObj;
                glyphInfo.x += lineXOffset2 + justifyOffset;
                if (justifyAdjust !== 0 && glyphObj2.isWhitespace && i < lineGlyphCount - trailingWhitespaceCount) {
                  justifyOffset += justifyAdjust;
                  glyphInfo.width += justifyAdjust;
                }
              }
            }
            const flips = bidi.getReorderSegments(
              text,
              bidiLevelsResult,
              line.glyphAt(0).charIndex,
              line.glyphAt(line.count - 1).charIndex
            );
            for (let fi = 0; fi < flips.length; fi++) {
              const [start, end] = flips[fi];
              let left = Infinity, right = -Infinity;
              for (let i = 0; i < lineGlyphCount; i++) {
                if (line.glyphAt(i).charIndex >= start) {
                  let startInLine = i, endInLine = i;
                  for (; endInLine < lineGlyphCount; endInLine++) {
                    let info = line.glyphAt(endInLine);
                    if (info.charIndex > end) {
                      break;
                    }
                    if (endInLine < lineGlyphCount - trailingWhitespaceCount) {
                      left = Math.min(left, info.x);
                      right = Math.max(right, info.x + info.width);
                    }
                  }
                  for (let j = startInLine; j < endInLine; j++) {
                    const glyphInfo = line.glyphAt(j);
                    glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);
                  }
                  break;
                }
              }
            }
            let glyphObj;
            const setGlyphObj = (g2) => glyphObj = g2;
            for (let i = 0; i < lineGlyphCount; i++) {
              let glyphInfo = line.glyphAt(i);
              glyphObj = glyphInfo.glyphObj;
              const glyphId = glyphObj.index;
              const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1;
              if (rtl) {
                const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);
                if (mirrored) {
                  fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);
                }
              }
              if (includeCaretPositions) {
                const { charIndex } = glyphInfo;
                const caretLeft = glyphInfo.x + anchorXOffset;
                const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;
                caretPositions[charIndex * 3] = rtl ? caretRight : caretLeft;
                caretPositions[charIndex * 3 + 1] = rtl ? caretLeft : caretRight;
                caretPositions[charIndex * 3 + 2] = lineYOffset + caretBottomOffset + anchorYOffset;
                const ligCount = charIndex - prevCharIndex;
                if (ligCount > 1) {
                  fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
                }
                prevCharIndex = charIndex;
              }
              if (colorRanges) {
                const { charIndex } = glyphInfo;
                while (charIndex > colorCharIndex) {
                  colorCharIndex++;
                  if (colorRanges.hasOwnProperty(colorCharIndex)) {
                    currentColor = colorRanges[colorCharIndex];
                  }
                }
              }
              if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {
                const idx = renderableGlyphIndex++;
                if (!glyphData[glyphId]) {
                  glyphData[glyphId] = {
                    path: glyphObj.path,
                    pathBounds: [glyphObj.xMin, glyphObj.yMin, glyphObj.xMax, glyphObj.yMax]
                  };
                }
                const glyphX = glyphInfo.x + anchorXOffset;
                const glyphY = lineYOffset + anchorYOffset;
                glyphPositions[idx * 2] = glyphX;
                glyphPositions[idx * 2 + 1] = glyphY;
                const visX0 = glyphX + glyphObj.xMin * fontSizeMult;
                const visY0 = glyphY + glyphObj.yMin * fontSizeMult;
                const visX1 = glyphX + glyphObj.xMax * fontSizeMult;
                const visY1 = glyphY + glyphObj.yMax * fontSizeMult;
                if (visX0 < visibleBounds[0])
                  visibleBounds[0] = visX0;
                if (visY0 < visibleBounds[1])
                  visibleBounds[1] = visY0;
                if (visX1 > visibleBounds[2])
                  visibleBounds[2] = visX1;
                if (visY1 > visibleBounds[3])
                  visibleBounds[3] = visY1;
                if (idx % chunkedBoundsSize === 0) {
                  chunk = { start: idx, end: idx, rect: [INF, INF, -INF, -INF] };
                  chunkedBounds.push(chunk);
                }
                chunk.end++;
                const chunkRect = chunk.rect;
                if (visX0 < chunkRect[0])
                  chunkRect[0] = visX0;
                if (visY0 < chunkRect[1])
                  chunkRect[1] = visY0;
                if (visX1 > chunkRect[2])
                  chunkRect[2] = visX1;
                if (visY1 > chunkRect[3])
                  chunkRect[3] = visY1;
                glyphIds[idx] = glyphId;
                if (colorRanges) {
                  const start = idx * 3;
                  glyphColors[start] = currentColor >> 16 & 255;
                  glyphColors[start + 1] = currentColor >> 8 & 255;
                  glyphColors[start + 2] = currentColor & 255;
                }
              }
            }
          }
          lineYOffset -= lineHeight;
        });
        if (caretPositions) {
          const ligCount = text.length - prevCharIndex;
          if (ligCount > 1) {
            fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);
          }
        }
      }
      timings.typesetting = now2() - typesetStart;
      callback({
        glyphIds,
        //font indices for each glyph
        glyphPositions,
        //x,y of each glyph's origin in layout
        glyphData,
        //dict holding data about each glyph appearing in the text
        caretPositions,
        //startX,endX,bottomY caret positions for each char
        caretHeight,
        //height of cursor from bottom to top
        glyphColors,
        //color for each glyph, if color ranges supplied
        chunkedBounds,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize,
        //calculated em height
        unitsPerEm,
        //font units per em
        ascender: ascender * fontSizeMult,
        //font ascender
        descender: descender * fontSizeMult,
        //font descender
        lineHeight,
        //computed line height
        topBaseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          anchorXOffset,
          anchorYOffset - lines.length * lineHeight,
          anchorXOffset + maxLineWidth,
          anchorYOffset
        ],
        visibleBounds,
        //total bounds of visible text paths, may be larger or smaller than totalBounds
        timings
      });
    });
  }
  function measure(args, callback) {
    typeset(args, (result) => {
      const [x0, y0, x1, y1] = result.blockBounds;
      callback({
        width: x1 - x0,
        height: y1 - y0
      });
    }, { metricsOnly: true });
  }
  function parsePercent(str) {
    let match = str.match(/^([\d.]+)%$/);
    let pct = match ? parseFloat(match[1]) : NaN;
    return isNaN(pct) ? 0 : pct / 100;
  }
  function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {
    const ligStartX = caretPositions[ligStartIndex * 3];
    const ligEndX = caretPositions[ligStartIndex * 3 + 1];
    const ligY = caretPositions[ligStartIndex * 3 + 2];
    const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;
    for (let i = 0; i < ligCount; i++) {
      const startIndex = (ligStartIndex + i) * 3;
      caretPositions[startIndex] = ligStartX + guessedAdvanceX * i;
      caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i + 1);
      caretPositions[startIndex + 2] = ligY;
    }
  }
  function now2() {
    return (self.performance || Date).now();
  }
  function TextLine() {
    this.data = [];
  }
  const textLineProps = ["glyphObj", "x", "width", "charIndex"];
  TextLine.prototype = {
    width: 0,
    isSoftWrapped: false,
    get count() {
      return Math.ceil(this.data.length / textLineProps.length);
    },
    glyphAt(i) {
      let fly = TextLine.flyweight;
      fly.data = this.data;
      fly.index = i;
      return fly;
    },
    splitAt(i) {
      let newLine = new TextLine();
      newLine.data = this.data.splice(i * textLineProps.length);
      return newLine;
    }
  };
  TextLine.flyweight = textLineProps.reduce((obj, prop, i, all) => {
    Object.defineProperty(obj, prop, {
      get() {
        return this.data[this.index * textLineProps.length + i];
      },
      set(val) {
        this.data[this.index * textLineProps.length + i] = val;
      }
    });
    return obj;
  }, { data: null, index: 0 });
  return {
    typeset,
    measure,
    loadFont
  };
}
var now = () => (self.performance || Date).now();
var mainThreadGenerator = SDFGenerator();
var warned;
function generateSDF(width, height, path, viewBox, distance, exponent, canvas, x2, y, channel, useWebGL = true) {
  if (!useWebGL) {
    return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x2, y, channel);
  }
  return generateSDF_GL(width, height, path, viewBox, distance, exponent, canvas, x2, y, channel).then(
    null,
    (err) => {
      if (!warned) {
        console.warn(`WebGL SDF generation failed, falling back to JS`, err);
        warned = true;
      }
      return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x2, y, channel);
    }
  );
}
var generateSDF_GL = function() {
  const queue = [];
  const chunkTimeBudget = 5;
  let timer = 0;
  function nextChunk() {
    const start = now();
    while (queue.length && now() - start < chunkTimeBudget) {
      queue.shift()();
    }
    timer = queue.length ? setTimeout(nextChunk, 0) : 0;
  }
  return (...args) => {
    const thenable = DefaultThenable();
    queue.push(() => {
      const start = now();
      try {
        mainThreadGenerator.webgl.generateIntoCanvas(...args);
        thenable.resolve({ timing: now() - start });
      } catch (err) {
        thenable.reject(err);
      }
    });
    if (!timer) {
      timer = setTimeout(nextChunk, 0);
    }
    return thenable;
  };
}();
var generateSDF_JS_Worker = function() {
  const threadCount = 4;
  const idleTimeout = 2e3;
  const threads = {};
  let callNum = 0;
  return function(width, height, path, viewBox, distance, exponent, canvas, x2, y, channel) {
    const workerId = "TroikaTextSDFGenerator_JS_" + callNum++ % threadCount;
    let thread = threads[workerId];
    if (!thread) {
      thread = threads[workerId] = {
        workerModule: defineWorkerModule({
          name: workerId,
          workerId,
          dependencies: [
            SDFGenerator,
            now
          ],
          init(_createSDFGenerator, now2) {
            const generate = _createSDFGenerator().javascript.generate;
            return function(...args) {
              const start = now2();
              const textureData = generate(...args);
              return {
                textureData,
                timing: now2() - start
              };
            };
          },
          getTransferables(result) {
            return [result.textureData.buffer];
          }
        }),
        requests: 0,
        idleTimer: null
      };
    }
    thread.requests++;
    clearTimeout(thread.idleTimer);
    return thread.workerModule(width, height, path, viewBox, distance, exponent).then(({ textureData, timing }) => {
      const start = now();
      const imageData = new Uint8Array(textureData.length * 4);
      for (let i = 0; i < textureData.length; i++) {
        imageData[i * 4 + channel] = textureData[i];
      }
      mainThreadGenerator.webglUtils.renderImageData(canvas, imageData, x2, y, width, height, 1 << 3 - channel);
      timing += now() - start;
      if (--thread.requests === 0) {
        thread.idleTimer = setTimeout(() => {
          terminateWorker(workerId);
        }, idleTimeout);
      }
      return { timing };
    });
  };
}();
function warmUpSDFCanvas(canvas) {
  if (!canvas._warm) {
    mainThreadGenerator.webgl.isSupported(canvas);
    canvas._warm = true;
  }
}
var resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;
function typrFactory() {
  return "undefined" == typeof window && (self.window = self), function(r) {
    var e = { parse: function(r2) {
      var t3 = e._bin, a2 = new Uint8Array(r2);
      if ("ttcf" == t3.readASCII(a2, 0, 4)) {
        var n2 = 4;
        t3.readUshort(a2, n2), n2 += 2, t3.readUshort(a2, n2), n2 += 2;
        var o = t3.readUint(a2, n2);
        n2 += 4;
        for (var s = [], i = 0; i < o; i++) {
          var h = t3.readUint(a2, n2);
          n2 += 4, s.push(e._readFont(a2, h));
        }
        return s;
      }
      return [e._readFont(a2, 0)];
    }, _readFont: function(r2, t3) {
      var a2 = e._bin, n2 = t3;
      a2.readFixed(r2, t3), t3 += 4;
      var o = a2.readUshort(r2, t3);
      t3 += 2, a2.readUshort(r2, t3), t3 += 2, a2.readUshort(r2, t3), t3 += 2, a2.readUshort(r2, t3), t3 += 2;
      for (var s = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], i = { _data: r2, _offset: n2 }, h = {}, f = 0; f < o; f++) {
        var d = a2.readASCII(r2, t3, 4);
        t3 += 4, a2.readUint(r2, t3), t3 += 4;
        var l = a2.readUint(r2, t3);
        t3 += 4;
        var u = a2.readUint(r2, t3);
        t3 += 4, h[d] = { offset: l, length: u };
      }
      for (f = 0; f < s.length; f++) {
        var v = s[f];
        h[v] && (i[v.trim()] = e[v.trim()].parse(r2, h[v].offset, h[v].length, i));
      }
      return i;
    }, _tabOffset: function(r2, t3, a2) {
      for (var n2 = e._bin, o = n2.readUshort(r2, a2 + 4), s = a2 + 12, i = 0; i < o; i++) {
        var h = n2.readASCII(r2, s, 4);
        s += 4, n2.readUint(r2, s), s += 4;
        var f = n2.readUint(r2, s);
        if (s += 4, n2.readUint(r2, s), s += 4, h == t3)
          return f;
      }
      return 0;
    } };
    e._bin = { readFixed: function(r2, e2) {
      return (r2[e2] << 8 | r2[e2 + 1]) + (r2[e2 + 2] << 8 | r2[e2 + 3]) / 65540;
    }, readF2dot14: function(r2, t3) {
      return e._bin.readShort(r2, t3) / 16384;
    }, readInt: function(r2, t3) {
      return e._bin._view(r2).getInt32(t3);
    }, readInt8: function(r2, t3) {
      return e._bin._view(r2).getInt8(t3);
    }, readShort: function(r2, t3) {
      return e._bin._view(r2).getInt16(t3);
    }, readUshort: function(r2, t3) {
      return e._bin._view(r2).getUint16(t3);
    }, readUshorts: function(r2, t3, a2) {
      for (var n2 = [], o = 0; o < a2; o++)
        n2.push(e._bin.readUshort(r2, t3 + 2 * o));
      return n2;
    }, readUint: function(r2, t3) {
      return e._bin._view(r2).getUint32(t3);
    }, readUint64: function(r2, t3) {
      return 4294967296 * e._bin.readUint(r2, t3) + e._bin.readUint(r2, t3 + 4);
    }, readASCII: function(r2, e2, t3) {
      for (var a2 = "", n2 = 0; n2 < t3; n2++)
        a2 += String.fromCharCode(r2[e2 + n2]);
      return a2;
    }, readUnicode: function(r2, e2, t3) {
      for (var a2 = "", n2 = 0; n2 < t3; n2++) {
        var o = r2[e2++] << 8 | r2[e2++];
        a2 += String.fromCharCode(o);
      }
      return a2;
    }, _tdec: "undefined" != typeof window && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(r2, t3, a2) {
      var n2 = e._bin._tdec;
      return n2 && 0 == t3 && a2 == r2.length ? n2.decode(r2) : e._bin.readASCII(r2, t3, a2);
    }, readBytes: function(r2, e2, t3) {
      for (var a2 = [], n2 = 0; n2 < t3; n2++)
        a2.push(r2[e2 + n2]);
      return a2;
    }, readASCIIArray: function(r2, e2, t3) {
      for (var a2 = [], n2 = 0; n2 < t3; n2++)
        a2.push(String.fromCharCode(r2[e2 + n2]));
      return a2;
    }, _view: function(r2) {
      return r2._dataView || (r2._dataView = r2.buffer ? new DataView(r2.buffer, r2.byteOffset, r2.byteLength) : new DataView(new Uint8Array(r2).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(r2, t3, a2, n2, o) {
      var s = e._bin, i = {}, h = t3;
      s.readFixed(r2, t3), t3 += 4;
      var f = s.readUshort(r2, t3);
      t3 += 2;
      var d = s.readUshort(r2, t3);
      t3 += 2;
      var l = s.readUshort(r2, t3);
      return t3 += 2, i.scriptList = e._lctf.readScriptList(r2, h + f), i.featureList = e._lctf.readFeatureList(r2, h + d), i.lookupList = e._lctf.readLookupList(r2, h + l, o), i;
    }, e._lctf.readLookupList = function(r2, t3, a2) {
      var n2 = e._bin, o = t3, s = [], i = n2.readUshort(r2, t3);
      t3 += 2;
      for (var h = 0; h < i; h++) {
        var f = n2.readUshort(r2, t3);
        t3 += 2;
        var d = e._lctf.readLookupTable(r2, o + f, a2);
        s.push(d);
      }
      return s;
    }, e._lctf.readLookupTable = function(r2, t3, a2) {
      var n2 = e._bin, o = t3, s = { tabs: [] };
      s.ltype = n2.readUshort(r2, t3), t3 += 2, s.flag = n2.readUshort(r2, t3), t3 += 2;
      var i = n2.readUshort(r2, t3);
      t3 += 2;
      for (var h = s.ltype, f = 0; f < i; f++) {
        var d = n2.readUshort(r2, t3);
        t3 += 2;
        var l = a2(r2, h, o + d, s);
        s.tabs.push(l);
      }
      return s;
    }, e._lctf.numOfOnes = function(r2) {
      for (var e2 = 0, t3 = 0; t3 < 32; t3++)
        0 != (r2 >>> t3 & 1) && e2++;
      return e2;
    }, e._lctf.readClassDef = function(r2, t3) {
      var a2 = e._bin, n2 = [], o = a2.readUshort(r2, t3);
      if (t3 += 2, 1 == o) {
        var s = a2.readUshort(r2, t3);
        t3 += 2;
        var i = a2.readUshort(r2, t3);
        t3 += 2;
        for (var h = 0; h < i; h++)
          n2.push(s + h), n2.push(s + h), n2.push(a2.readUshort(r2, t3)), t3 += 2;
      }
      if (2 == o) {
        var f = a2.readUshort(r2, t3);
        t3 += 2;
        for (h = 0; h < f; h++)
          n2.push(a2.readUshort(r2, t3)), t3 += 2, n2.push(a2.readUshort(r2, t3)), t3 += 2, n2.push(a2.readUshort(r2, t3)), t3 += 2;
      }
      return n2;
    }, e._lctf.getInterval = function(r2, e2) {
      for (var t3 = 0; t3 < r2.length; t3 += 3) {
        var a2 = r2[t3], n2 = r2[t3 + 1];
        if (r2[t3 + 2], a2 <= e2 && e2 <= n2)
          return t3;
      }
      return -1;
    }, e._lctf.readCoverage = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      n2.fmt = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      return t3 += 2, 1 == n2.fmt && (n2.tab = a2.readUshorts(r2, t3, o)), 2 == n2.fmt && (n2.tab = a2.readUshorts(r2, t3, 3 * o)), n2;
    }, e._lctf.coverageIndex = function(r2, t3) {
      var a2 = r2.tab;
      if (1 == r2.fmt)
        return a2.indexOf(t3);
      if (2 == r2.fmt) {
        var n2 = e._lctf.getInterval(a2, t3);
        if (-1 != n2)
          return a2[n2 + 2] + (t3 - a2[n2]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = [], s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readASCII(r2, t3, 4);
        t3 += 4;
        var f = a2.readUshort(r2, t3);
        t3 += 2;
        var d = e._lctf.readFeatureTable(r2, n2 + f);
        d.tag = h.trim(), o.push(d);
      }
      return o;
    }, e._lctf.readFeatureTable = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = {}, s = a2.readUshort(r2, t3);
      t3 += 2, s > 0 && (o.featureParams = n2 + s);
      var i = a2.readUshort(r2, t3);
      t3 += 2, o.tab = [];
      for (var h = 0; h < i; h++)
        o.tab.push(a2.readUshort(r2, t3 + 2 * h));
      return o;
    }, e._lctf.readScriptList = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = {}, s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readASCII(r2, t3, 4);
        t3 += 4;
        var f = a2.readUshort(r2, t3);
        t3 += 2, o[h.trim()] = e._lctf.readScriptTable(r2, n2 + f);
      }
      return o;
    }, e._lctf.readScriptTable = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = {}, s = a2.readUshort(r2, t3);
      t3 += 2, o.default = e._lctf.readLangSysTable(r2, n2 + s);
      var i = a2.readUshort(r2, t3);
      t3 += 2;
      for (var h = 0; h < i; h++) {
        var f = a2.readASCII(r2, t3, 4);
        t3 += 4;
        var d = a2.readUshort(r2, t3);
        t3 += 2, o[f.trim()] = e._lctf.readLangSysTable(r2, n2 + d);
      }
      return o;
    }, e._lctf.readLangSysTable = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      a2.readUshort(r2, t3), t3 += 2, n2.reqFeature = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      return t3 += 2, n2.features = a2.readUshorts(r2, t3, o), n2;
    }, e.CFF = {}, e.CFF.parse = function(r2, t3, a2) {
      var n2 = e._bin;
      (r2 = new Uint8Array(r2.buffer, t3, a2))[t3 = 0], r2[++t3], r2[++t3], r2[++t3], t3++;
      var o = [];
      t3 = e.CFF.readIndex(r2, t3, o);
      for (var s = [], i = 0; i < o.length - 1; i++)
        s.push(n2.readASCII(r2, t3 + o[i], o[i + 1] - o[i]));
      t3 += o[o.length - 1];
      var h = [];
      t3 = e.CFF.readIndex(r2, t3, h);
      var f = [];
      for (i = 0; i < h.length - 1; i++)
        f.push(e.CFF.readDict(r2, t3 + h[i], t3 + h[i + 1]));
      t3 += h[h.length - 1];
      var d = f[0], l = [];
      t3 = e.CFF.readIndex(r2, t3, l);
      var u = [];
      for (i = 0; i < l.length - 1; i++)
        u.push(n2.readASCII(r2, t3 + l[i], l[i + 1] - l[i]));
      if (t3 += l[l.length - 1], e.CFF.readSubrs(r2, t3, d), d.CharStrings) {
        t3 = d.CharStrings;
        l = [];
        t3 = e.CFF.readIndex(r2, t3, l);
        var v = [];
        for (i = 0; i < l.length - 1; i++)
          v.push(n2.readBytes(r2, t3 + l[i], l[i + 1] - l[i]));
        d.CharStrings = v;
      }
      if (d.ROS) {
        t3 = d.FDArray;
        var c = [];
        t3 = e.CFF.readIndex(r2, t3, c), d.FDArray = [];
        for (i = 0; i < c.length - 1; i++) {
          var p2 = e.CFF.readDict(r2, t3 + c[i], t3 + c[i + 1]);
          e.CFF._readFDict(r2, p2, u), d.FDArray.push(p2);
        }
        t3 += c[c.length - 1], t3 = d.FDSelect, d.FDSelect = [];
        var U = r2[t3];
        if (t3++, 3 != U)
          throw U;
        var g2 = n2.readUshort(r2, t3);
        t3 += 2;
        for (i = 0; i < g2 + 1; i++)
          d.FDSelect.push(n2.readUshort(r2, t3), r2[t3 + 2]), t3 += 3;
      }
      return d.Encoding && (d.Encoding = e.CFF.readEncoding(r2, d.Encoding, d.CharStrings.length)), d.charset && (d.charset = e.CFF.readCharset(r2, d.charset, d.CharStrings.length)), e.CFF._readFDict(r2, d, u), d;
    }, e.CFF._readFDict = function(r2, t3, a2) {
      var n2;
      for (var o in t3.Private && (n2 = t3.Private[1], t3.Private = e.CFF.readDict(r2, n2, n2 + t3.Private[0]), t3.Private.Subrs && e.CFF.readSubrs(r2, n2 + t3.Private.Subrs, t3.Private)), t3)
        -1 != ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(o) && (t3[o] = a2[t3[o] - 426 + 35]);
    }, e.CFF.readSubrs = function(r2, t3, a2) {
      var n2 = e._bin, o = [];
      t3 = e.CFF.readIndex(r2, t3, o);
      var s, i = o.length;
      s = i < 1240 ? 107 : i < 33900 ? 1131 : 32768, a2.Bias = s, a2.Subrs = [];
      for (var h = 0; h < o.length - 1; h++)
        a2.Subrs.push(n2.readBytes(r2, t3 + o[h], o[h + 1] - o[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(r2, e2) {
      for (var t3 = 0; t3 < r2.charset.length; t3++)
        if (r2.charset[t3] == e2)
          return t3;
      return -1;
    }, e.CFF.glyphBySE = function(r2, t3) {
      return t3 < 0 || t3 > 255 ? -1 : e.CFF.glyphByUnicode(r2, e.CFF.tableSE[t3]);
    }, e.CFF.readEncoding = function(r2, t3, a2) {
      e._bin;
      var n2 = [".notdef"], o = r2[t3];
      if (t3++, 0 != o)
        throw "error: unknown encoding format: " + o;
      var s = r2[t3];
      t3++;
      for (var i = 0; i < s; i++)
        n2.push(r2[t3 + i]);
      return n2;
    }, e.CFF.readCharset = function(r2, t3, a2) {
      var n2 = e._bin, o = [".notdef"], s = r2[t3];
      if (t3++, 0 == s)
        for (var i = 0; i < a2; i++) {
          var h = n2.readUshort(r2, t3);
          t3 += 2, o.push(h);
        }
      else {
        if (1 != s && 2 != s)
          throw "error: format: " + s;
        for (; o.length < a2; ) {
          h = n2.readUshort(r2, t3);
          t3 += 2;
          var f = 0;
          1 == s ? (f = r2[t3], t3++) : (f = n2.readUshort(r2, t3), t3 += 2);
          for (i = 0; i <= f; i++)
            o.push(h), h++;
        }
      }
      return o;
    }, e.CFF.readIndex = function(r2, t3, a2) {
      var n2 = e._bin, o = n2.readUshort(r2, t3) + 1, s = r2[t3 += 2];
      if (t3++, 1 == s)
        for (var i = 0; i < o; i++)
          a2.push(r2[t3 + i]);
      else if (2 == s)
        for (i = 0; i < o; i++)
          a2.push(n2.readUshort(r2, t3 + 2 * i));
      else if (3 == s)
        for (i = 0; i < o; i++)
          a2.push(16777215 & n2.readUint(r2, t3 + 3 * i - 1));
      else if (1 != o)
        throw "unsupported offset size: " + s + ", count: " + o;
      return (t3 += o * s) - 1;
    }, e.CFF.getCharString = function(r2, t3, a2) {
      var n2 = e._bin, o = r2[t3], s = r2[t3 + 1];
      r2[t3 + 2], r2[t3 + 3], r2[t3 + 4];
      var i = 1, h = null, f = null;
      o <= 20 && (h = o, i = 1), 12 == o && (h = 100 * o + s, i = 2), 21 <= o && o <= 27 && (h = o, i = 1), 28 == o && (f = n2.readShort(r2, t3 + 1), i = 3), 29 <= o && o <= 31 && (h = o, i = 1), 32 <= o && o <= 246 && (f = o - 139, i = 1), 247 <= o && o <= 250 && (f = 256 * (o - 247) + s + 108, i = 2), 251 <= o && o <= 254 && (f = 256 * -(o - 251) - s - 108, i = 2), 255 == o && (f = n2.readInt(r2, t3 + 1) / 65535, i = 5), a2.val = null != f ? f : "o" + h, a2.size = i;
    }, e.CFF.readCharString = function(r2, t3, a2) {
      for (var n2 = t3 + a2, o = e._bin, s = []; t3 < n2; ) {
        var i = r2[t3], h = r2[t3 + 1];
        r2[t3 + 2], r2[t3 + 3], r2[t3 + 4];
        var f = 1, d = null, l = null;
        i <= 20 && (d = i, f = 1), 12 == i && (d = 100 * i + h, f = 2), 19 != i && 20 != i || (d = i, f = 2), 21 <= i && i <= 27 && (d = i, f = 1), 28 == i && (l = o.readShort(r2, t3 + 1), f = 3), 29 <= i && i <= 31 && (d = i, f = 1), 32 <= i && i <= 246 && (l = i - 139, f = 1), 247 <= i && i <= 250 && (l = 256 * (i - 247) + h + 108, f = 2), 251 <= i && i <= 254 && (l = 256 * -(i - 251) - h - 108, f = 2), 255 == i && (l = o.readInt(r2, t3 + 1) / 65535, f = 5), s.push(null != l ? l : "o" + d), t3 += f;
      }
      return s;
    }, e.CFF.readDict = function(r2, t3, a2) {
      for (var n2 = e._bin, o = {}, s = []; t3 < a2; ) {
        var i = r2[t3], h = r2[t3 + 1];
        r2[t3 + 2], r2[t3 + 3], r2[t3 + 4];
        var f = 1, d = null, l = null;
        if (28 == i && (l = n2.readShort(r2, t3 + 1), f = 3), 29 == i && (l = n2.readInt(r2, t3 + 1), f = 5), 32 <= i && i <= 246 && (l = i - 139, f = 1), 247 <= i && i <= 250 && (l = 256 * (i - 247) + h + 108, f = 2), 251 <= i && i <= 254 && (l = 256 * -(i - 251) - h - 108, f = 2), 255 == i)
          throw l = n2.readInt(r2, t3 + 1) / 65535, f = 5, "unknown number";
        if (30 == i) {
          var u = [];
          for (f = 1; ; ) {
            var v = r2[t3 + f];
            f++;
            var c = v >> 4, p2 = 15 & v;
            if (15 != c && u.push(c), 15 != p2 && u.push(p2), 15 == p2)
              break;
          }
          for (var U = "", g2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], S = 0; S < u.length; S++)
            U += g2[u[S]];
          l = parseFloat(U);
        }
        if (i <= 21) {
          if (d = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][i], f = 1, 12 == i)
            d = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], f = 2;
        }
        null != d ? (o[d] = 1 == s.length ? s[0] : s, s = []) : s.push(l), t3 += f;
      }
      return o;
    }, e.cmap = {}, e.cmap.parse = function(r2, t3, a2) {
      r2 = new Uint8Array(r2.buffer, t3, a2), t3 = 0;
      var n2 = e._bin, o = {};
      n2.readUshort(r2, t3), t3 += 2;
      var s = n2.readUshort(r2, t3);
      t3 += 2;
      var i = [];
      o.tables = [];
      for (var h = 0; h < s; h++) {
        var f = n2.readUshort(r2, t3);
        t3 += 2;
        var d = n2.readUshort(r2, t3);
        t3 += 2;
        var l = n2.readUint(r2, t3);
        t3 += 4;
        var u = "p" + f + "e" + d, v = i.indexOf(l);
        if (-1 == v) {
          var c;
          v = o.tables.length, i.push(l);
          var p2 = n2.readUshort(r2, l);
          0 == p2 ? c = e.cmap.parse0(r2, l) : 4 == p2 ? c = e.cmap.parse4(r2, l) : 6 == p2 ? c = e.cmap.parse6(r2, l) : 12 == p2 ? c = e.cmap.parse12(r2, l) : console.debug("unknown format: " + p2, f, d, l), o.tables.push(c);
        }
        if (null != o[u])
          throw "multiple tables for one platform+encoding";
        o[u] = v;
      }
      return o;
    }, e.cmap.parse0 = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      n2.format = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      t3 += 2, a2.readUshort(r2, t3), t3 += 2, n2.map = [];
      for (var s = 0; s < o - 6; s++)
        n2.map.push(r2[t3 + s]);
      return n2;
    }, e.cmap.parse4 = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = {};
      o.format = a2.readUshort(r2, t3), t3 += 2;
      var s = a2.readUshort(r2, t3);
      t3 += 2, a2.readUshort(r2, t3), t3 += 2;
      var i = a2.readUshort(r2, t3);
      t3 += 2;
      var h = i / 2;
      o.searchRange = a2.readUshort(r2, t3), t3 += 2, o.entrySelector = a2.readUshort(r2, t3), t3 += 2, o.rangeShift = a2.readUshort(r2, t3), t3 += 2, o.endCount = a2.readUshorts(r2, t3, h), t3 += 2 * h, t3 += 2, o.startCount = a2.readUshorts(r2, t3, h), t3 += 2 * h, o.idDelta = [];
      for (var f = 0; f < h; f++)
        o.idDelta.push(a2.readShort(r2, t3)), t3 += 2;
      for (o.idRangeOffset = a2.readUshorts(r2, t3, h), t3 += 2 * h, o.glyphIdArray = []; t3 < n2 + s; )
        o.glyphIdArray.push(a2.readUshort(r2, t3)), t3 += 2;
      return o;
    }, e.cmap.parse6 = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      n2.format = a2.readUshort(r2, t3), t3 += 2, a2.readUshort(r2, t3), t3 += 2, a2.readUshort(r2, t3), t3 += 2, n2.firstCode = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      t3 += 2, n2.glyphIdArray = [];
      for (var s = 0; s < o; s++)
        n2.glyphIdArray.push(a2.readUshort(r2, t3)), t3 += 2;
      return n2;
    }, e.cmap.parse12 = function(r2, t3) {
      var a2 = e._bin, n2 = {};
      n2.format = a2.readUshort(r2, t3), t3 += 2, t3 += 2, a2.readUint(r2, t3), t3 += 4, a2.readUint(r2, t3), t3 += 4;
      var o = a2.readUint(r2, t3);
      t3 += 4, n2.groups = [];
      for (var s = 0; s < o; s++) {
        var i = t3 + 12 * s, h = a2.readUint(r2, i + 0), f = a2.readUint(r2, i + 4), d = a2.readUint(r2, i + 8);
        n2.groups.push([h, f, d]);
      }
      return n2;
    }, e.glyf = {}, e.glyf.parse = function(r2, e2, t3, a2) {
      for (var n2 = [], o = 0; o < a2.maxp.numGlyphs; o++)
        n2.push(null);
      return n2;
    }, e.glyf._parseGlyf = function(r2, t3) {
      var a2 = e._bin, n2 = r2._data, o = e._tabOffset(n2, "glyf", r2._offset) + r2.loca[t3];
      if (r2.loca[t3] == r2.loca[t3 + 1])
        return null;
      var s = {};
      if (s.noc = a2.readShort(n2, o), o += 2, s.xMin = a2.readShort(n2, o), o += 2, s.yMin = a2.readShort(n2, o), o += 2, s.xMax = a2.readShort(n2, o), o += 2, s.yMax = a2.readShort(n2, o), o += 2, s.xMin >= s.xMax || s.yMin >= s.yMax)
        return null;
      if (s.noc > 0) {
        s.endPts = [];
        for (var i = 0; i < s.noc; i++)
          s.endPts.push(a2.readUshort(n2, o)), o += 2;
        var h = a2.readUshort(n2, o);
        if (o += 2, n2.length - o < h)
          return null;
        s.instructions = a2.readBytes(n2, o, h), o += h;
        var f = s.endPts[s.noc - 1] + 1;
        s.flags = [];
        for (i = 0; i < f; i++) {
          var d = n2[o];
          if (o++, s.flags.push(d), 0 != (8 & d)) {
            var l = n2[o];
            o++;
            for (var u = 0; u < l; u++)
              s.flags.push(d), i++;
          }
        }
        s.xs = [];
        for (i = 0; i < f; i++) {
          var v = 0 != (2 & s.flags[i]), c = 0 != (16 & s.flags[i]);
          v ? (s.xs.push(c ? n2[o] : -n2[o]), o++) : c ? s.xs.push(0) : (s.xs.push(a2.readShort(n2, o)), o += 2);
        }
        s.ys = [];
        for (i = 0; i < f; i++) {
          v = 0 != (4 & s.flags[i]), c = 0 != (32 & s.flags[i]);
          v ? (s.ys.push(c ? n2[o] : -n2[o]), o++) : c ? s.ys.push(0) : (s.ys.push(a2.readShort(n2, o)), o += 2);
        }
        var p2 = 0, U = 0;
        for (i = 0; i < f; i++)
          p2 += s.xs[i], U += s.ys[i], s.xs[i] = p2, s.ys[i] = U;
      } else {
        var g2;
        s.parts = [];
        do {
          g2 = a2.readUshort(n2, o), o += 2;
          var S = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (s.parts.push(S), S.glyphIndex = a2.readUshort(n2, o), o += 2, 1 & g2) {
            var m = a2.readShort(n2, o);
            o += 2;
            var b = a2.readShort(n2, o);
            o += 2;
          } else {
            m = a2.readInt8(n2, o);
            o++;
            b = a2.readInt8(n2, o);
            o++;
          }
          2 & g2 ? (S.m.tx = m, S.m.ty = b) : (S.p1 = m, S.p2 = b), 8 & g2 ? (S.m.a = S.m.d = a2.readF2dot14(n2, o), o += 2) : 64 & g2 ? (S.m.a = a2.readF2dot14(n2, o), o += 2, S.m.d = a2.readF2dot14(n2, o), o += 2) : 128 & g2 && (S.m.a = a2.readF2dot14(n2, o), o += 2, S.m.b = a2.readF2dot14(n2, o), o += 2, S.m.c = a2.readF2dot14(n2, o), o += 2, S.m.d = a2.readF2dot14(n2, o), o += 2);
        } while (32 & g2);
        if (256 & g2) {
          var y = a2.readUshort(n2, o);
          o += 2, s.instr = [];
          for (i = 0; i < y; i++)
            s.instr.push(n2[o]), o++;
        }
      }
      return s;
    }, e.GPOS = {}, e.GPOS.parse = function(r2, t3, a2, n2) {
      return e._lctf.parse(r2, t3, a2, n2, e.GPOS.subt);
    }, e.GPOS.subt = function(r2, t3, a2, n2) {
      var o = e._bin, s = a2, i = {};
      if (i.fmt = o.readUshort(r2, a2), a2 += 2, 1 == t3 || 2 == t3 || 3 == t3 || 7 == t3 || 8 == t3 && i.fmt <= 2) {
        var h = o.readUshort(r2, a2);
        a2 += 2, i.coverage = e._lctf.readCoverage(r2, h + s);
      }
      if (1 == t3 && 1 == i.fmt) {
        var f = o.readUshort(r2, a2);
        a2 += 2;
        var d = e._lctf.numOfOnes(f);
        0 != f && (i.pos = e.GPOS.readValueRecord(r2, a2, f));
      } else if (2 == t3 && i.fmt >= 1 && i.fmt <= 2) {
        f = o.readUshort(r2, a2);
        a2 += 2;
        var l = o.readUshort(r2, a2);
        a2 += 2;
        d = e._lctf.numOfOnes(f);
        var u = e._lctf.numOfOnes(l);
        if (1 == i.fmt) {
          i.pairsets = [];
          var v = o.readUshort(r2, a2);
          a2 += 2;
          for (var c = 0; c < v; c++) {
            var p2 = s + o.readUshort(r2, a2);
            a2 += 2;
            var U = o.readUshort(r2, p2);
            p2 += 2;
            for (var g2 = [], S = 0; S < U; S++) {
              var m = o.readUshort(r2, p2);
              p2 += 2, 0 != f && (x2 = e.GPOS.readValueRecord(r2, p2, f), p2 += 2 * d), 0 != l && (P = e.GPOS.readValueRecord(r2, p2, l), p2 += 2 * u), g2.push({ gid2: m, val1: x2, val2: P });
            }
            i.pairsets.push(g2);
          }
        }
        if (2 == i.fmt) {
          var b = o.readUshort(r2, a2);
          a2 += 2;
          var y = o.readUshort(r2, a2);
          a2 += 2;
          var F = o.readUshort(r2, a2);
          a2 += 2;
          var _ = o.readUshort(r2, a2);
          a2 += 2, i.classDef1 = e._lctf.readClassDef(r2, s + b), i.classDef2 = e._lctf.readClassDef(r2, s + y), i.matrix = [];
          for (c = 0; c < F; c++) {
            var C2 = [];
            for (S = 0; S < _; S++) {
              var x2 = null, P = null;
              0 != f && (x2 = e.GPOS.readValueRecord(r2, a2, f), a2 += 2 * d), 0 != l && (P = e.GPOS.readValueRecord(r2, a2, l), a2 += 2 * u), C2.push({ val1: x2, val2: P });
            }
            i.matrix.push(C2);
          }
        }
      } else {
        if (9 == t3 && 1 == i.fmt) {
          var I2 = o.readUshort(r2, a2);
          a2 += 2;
          var w = o.readUint(r2, a2);
          if (a2 += 4, 9 == n2.ltype)
            n2.ltype = I2;
          else if (n2.ltype != I2)
            throw "invalid extension substitution";
          return e.GPOS.subt(r2, n2.ltype, s + w);
        }
        console.debug("unsupported GPOS table LookupType", t3, "format", i.fmt);
      }
      return i;
    }, e.GPOS.readValueRecord = function(r2, t3, a2) {
      var n2 = e._bin, o = [];
      return o.push(1 & a2 ? n2.readShort(r2, t3) : 0), t3 += 1 & a2 ? 2 : 0, o.push(2 & a2 ? n2.readShort(r2, t3) : 0), t3 += 2 & a2 ? 2 : 0, o.push(4 & a2 ? n2.readShort(r2, t3) : 0), t3 += 4 & a2 ? 2 : 0, o.push(8 & a2 ? n2.readShort(r2, t3) : 0), t3 += 8 & a2 ? 2 : 0, o;
    }, e.GSUB = {}, e.GSUB.parse = function(r2, t3, a2, n2) {
      return e._lctf.parse(r2, t3, a2, n2, e.GSUB.subt);
    }, e.GSUB.subt = function(r2, t3, a2, n2) {
      var o = e._bin, s = a2, i = {};
      if (i.fmt = o.readUshort(r2, a2), a2 += 2, 1 != t3 && 4 != t3 && 5 != t3 && 6 != t3)
        return null;
      if (1 == t3 || 4 == t3 || 5 == t3 && i.fmt <= 2 || 6 == t3 && i.fmt <= 2) {
        var h = o.readUshort(r2, a2);
        a2 += 2, i.coverage = e._lctf.readCoverage(r2, s + h);
      }
      if (1 == t3 && i.fmt >= 1 && i.fmt <= 2) {
        if (1 == i.fmt)
          i.delta = o.readShort(r2, a2), a2 += 2;
        else if (2 == i.fmt) {
          var f = o.readUshort(r2, a2);
          a2 += 2, i.newg = o.readUshorts(r2, a2, f), a2 += 2 * i.newg.length;
        }
      } else if (4 == t3) {
        i.vals = [];
        f = o.readUshort(r2, a2);
        a2 += 2;
        for (var d = 0; d < f; d++) {
          var l = o.readUshort(r2, a2);
          a2 += 2, i.vals.push(e.GSUB.readLigatureSet(r2, s + l));
        }
      } else if (5 == t3 && 2 == i.fmt) {
        if (2 == i.fmt) {
          var u = o.readUshort(r2, a2);
          a2 += 2, i.cDef = e._lctf.readClassDef(r2, s + u), i.scset = [];
          var v = o.readUshort(r2, a2);
          a2 += 2;
          for (d = 0; d < v; d++) {
            var c = o.readUshort(r2, a2);
            a2 += 2, i.scset.push(0 == c ? null : e.GSUB.readSubClassSet(r2, s + c));
          }
        }
      } else if (6 == t3 && 3 == i.fmt) {
        if (3 == i.fmt) {
          for (d = 0; d < 3; d++) {
            f = o.readUshort(r2, a2);
            a2 += 2;
            for (var p2 = [], U = 0; U < f; U++)
              p2.push(e._lctf.readCoverage(r2, s + o.readUshort(r2, a2 + 2 * U)));
            a2 += 2 * f, 0 == d && (i.backCvg = p2), 1 == d && (i.inptCvg = p2), 2 == d && (i.ahedCvg = p2);
          }
          f = o.readUshort(r2, a2);
          a2 += 2, i.lookupRec = e.GSUB.readSubstLookupRecords(r2, a2, f);
        }
      } else {
        if (7 == t3 && 1 == i.fmt) {
          var g2 = o.readUshort(r2, a2);
          a2 += 2;
          var S = o.readUint(r2, a2);
          if (a2 += 4, 9 == n2.ltype)
            n2.ltype = g2;
          else if (n2.ltype != g2)
            throw "invalid extension substitution";
          return e.GSUB.subt(r2, n2.ltype, s + S);
        }
        console.debug("unsupported GSUB table LookupType", t3, "format", i.fmt);
      }
      return i;
    }, e.GSUB.readSubClassSet = function(r2, t3) {
      var a2 = e._bin.readUshort, n2 = t3, o = [], s = a2(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2(r2, t3);
        t3 += 2, o.push(e.GSUB.readSubClassRule(r2, n2 + h));
      }
      return o;
    }, e.GSUB.readSubClassRule = function(r2, t3) {
      var a2 = e._bin.readUshort, n2 = {}, o = a2(r2, t3), s = a2(r2, t3 += 2);
      t3 += 2, n2.input = [];
      for (var i = 0; i < o - 1; i++)
        n2.input.push(a2(r2, t3)), t3 += 2;
      return n2.substLookupRecords = e.GSUB.readSubstLookupRecords(r2, t3, s), n2;
    }, e.GSUB.readSubstLookupRecords = function(r2, t3, a2) {
      for (var n2 = e._bin.readUshort, o = [], s = 0; s < a2; s++)
        o.push(n2(r2, t3), n2(r2, t3 + 2)), t3 += 4;
      return o;
    }, e.GSUB.readChainSubClassSet = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = [], s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readUshort(r2, t3);
        t3 += 2, o.push(e.GSUB.readChainSubClassRule(r2, n2 + h));
      }
      return o;
    }, e.GSUB.readChainSubClassRule = function(r2, t3) {
      for (var a2 = e._bin, n2 = {}, o = ["backtrack", "input", "lookahead"], s = 0; s < o.length; s++) {
        var i = a2.readUshort(r2, t3);
        t3 += 2, 1 == s && i--, n2[o[s]] = a2.readUshorts(r2, t3, i), t3 += 2 * n2[o[s]].length;
      }
      i = a2.readUshort(r2, t3);
      return t3 += 2, n2.subst = a2.readUshorts(r2, t3, 2 * i), t3 += 2 * n2.subst.length, n2;
    }, e.GSUB.readLigatureSet = function(r2, t3) {
      var a2 = e._bin, n2 = t3, o = [], s = a2.readUshort(r2, t3);
      t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = a2.readUshort(r2, t3);
        t3 += 2, o.push(e.GSUB.readLigature(r2, n2 + h));
      }
      return o;
    }, e.GSUB.readLigature = function(r2, t3) {
      var a2 = e._bin, n2 = { chain: [] };
      n2.nglyph = a2.readUshort(r2, t3), t3 += 2;
      var o = a2.readUshort(r2, t3);
      t3 += 2;
      for (var s = 0; s < o - 1; s++)
        n2.chain.push(a2.readUshort(r2, t3)), t3 += 2;
      return n2;
    }, e.head = {}, e.head.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {};
      return n2.readFixed(r2, t3), t3 += 4, o.fontRevision = n2.readFixed(r2, t3), t3 += 4, n2.readUint(r2, t3), t3 += 4, n2.readUint(r2, t3), t3 += 4, o.flags = n2.readUshort(r2, t3), t3 += 2, o.unitsPerEm = n2.readUshort(r2, t3), t3 += 2, o.created = n2.readUint64(r2, t3), t3 += 8, o.modified = n2.readUint64(r2, t3), t3 += 8, o.xMin = n2.readShort(r2, t3), t3 += 2, o.yMin = n2.readShort(r2, t3), t3 += 2, o.xMax = n2.readShort(r2, t3), t3 += 2, o.yMax = n2.readShort(r2, t3), t3 += 2, o.macStyle = n2.readUshort(r2, t3), t3 += 2, o.lowestRecPPEM = n2.readUshort(r2, t3), t3 += 2, o.fontDirectionHint = n2.readShort(r2, t3), t3 += 2, o.indexToLocFormat = n2.readShort(r2, t3), t3 += 2, o.glyphDataFormat = n2.readShort(r2, t3), t3 += 2, o;
    }, e.hhea = {}, e.hhea.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {};
      return n2.readFixed(r2, t3), t3 += 4, o.ascender = n2.readShort(r2, t3), t3 += 2, o.descender = n2.readShort(r2, t3), t3 += 2, o.lineGap = n2.readShort(r2, t3), t3 += 2, o.advanceWidthMax = n2.readUshort(r2, t3), t3 += 2, o.minLeftSideBearing = n2.readShort(r2, t3), t3 += 2, o.minRightSideBearing = n2.readShort(r2, t3), t3 += 2, o.xMaxExtent = n2.readShort(r2, t3), t3 += 2, o.caretSlopeRise = n2.readShort(r2, t3), t3 += 2, o.caretSlopeRun = n2.readShort(r2, t3), t3 += 2, o.caretOffset = n2.readShort(r2, t3), t3 += 2, t3 += 8, o.metricDataFormat = n2.readShort(r2, t3), t3 += 2, o.numberOfHMetrics = n2.readUshort(r2, t3), t3 += 2, o;
    }, e.hmtx = {}, e.hmtx.parse = function(r2, t3, a2, n2) {
      for (var o = e._bin, s = { aWidth: [], lsBearing: [] }, i = 0, h = 0, f = 0; f < n2.maxp.numGlyphs; f++)
        f < n2.hhea.numberOfHMetrics && (i = o.readUshort(r2, t3), t3 += 2, h = o.readShort(r2, t3), t3 += 2), s.aWidth.push(i), s.lsBearing.push(h);
      return s;
    }, e.kern = {}, e.kern.parse = function(r2, t3, a2, n2) {
      var o = e._bin, s = o.readUshort(r2, t3);
      if (t3 += 2, 1 == s)
        return e.kern.parseV1(r2, t3 - 2, a2, n2);
      var i = o.readUshort(r2, t3);
      t3 += 2;
      for (var h = { glyph1: [], rval: [] }, f = 0; f < i; f++) {
        t3 += 2;
        a2 = o.readUshort(r2, t3);
        t3 += 2;
        var d = o.readUshort(r2, t3);
        t3 += 2;
        var l = d >>> 8;
        if (0 != (l &= 15))
          throw "unknown kern table format: " + l;
        t3 = e.kern.readFormat0(r2, t3, h);
      }
      return h;
    }, e.kern.parseV1 = function(r2, t3, a2, n2) {
      var o = e._bin;
      o.readFixed(r2, t3), t3 += 4;
      var s = o.readUint(r2, t3);
      t3 += 4;
      for (var i = { glyph1: [], rval: [] }, h = 0; h < s; h++) {
        o.readUint(r2, t3), t3 += 4;
        var f = o.readUshort(r2, t3);
        t3 += 2, o.readUshort(r2, t3), t3 += 2;
        var d = f >>> 8;
        if (0 != (d &= 15))
          throw "unknown kern table format: " + d;
        t3 = e.kern.readFormat0(r2, t3, i);
      }
      return i;
    }, e.kern.readFormat0 = function(r2, t3, a2) {
      var n2 = e._bin, o = -1, s = n2.readUshort(r2, t3);
      t3 += 2, n2.readUshort(r2, t3), t3 += 2, n2.readUshort(r2, t3), t3 += 2, n2.readUshort(r2, t3), t3 += 2;
      for (var i = 0; i < s; i++) {
        var h = n2.readUshort(r2, t3);
        t3 += 2;
        var f = n2.readUshort(r2, t3);
        t3 += 2;
        var d = n2.readShort(r2, t3);
        t3 += 2, h != o && (a2.glyph1.push(h), a2.rval.push({ glyph2: [], vals: [] }));
        var l = a2.rval[a2.rval.length - 1];
        l.glyph2.push(f), l.vals.push(d), o = h;
      }
      return t3;
    }, e.loca = {}, e.loca.parse = function(r2, t3, a2, n2) {
      var o = e._bin, s = [], i = n2.head.indexToLocFormat, h = n2.maxp.numGlyphs + 1;
      if (0 == i)
        for (var f = 0; f < h; f++)
          s.push(o.readUshort(r2, t3 + (f << 1)) << 1);
      if (1 == i)
        for (f = 0; f < h; f++)
          s.push(o.readUint(r2, t3 + (f << 2)));
      return s;
    }, e.maxp = {}, e.maxp.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {}, s = n2.readUint(r2, t3);
      return t3 += 4, o.numGlyphs = n2.readUshort(r2, t3), t3 += 2, 65536 == s && (o.maxPoints = n2.readUshort(r2, t3), t3 += 2, o.maxContours = n2.readUshort(r2, t3), t3 += 2, o.maxCompositePoints = n2.readUshort(r2, t3), t3 += 2, o.maxCompositeContours = n2.readUshort(r2, t3), t3 += 2, o.maxZones = n2.readUshort(r2, t3), t3 += 2, o.maxTwilightPoints = n2.readUshort(r2, t3), t3 += 2, o.maxStorage = n2.readUshort(r2, t3), t3 += 2, o.maxFunctionDefs = n2.readUshort(r2, t3), t3 += 2, o.maxInstructionDefs = n2.readUshort(r2, t3), t3 += 2, o.maxStackElements = n2.readUshort(r2, t3), t3 += 2, o.maxSizeOfInstructions = n2.readUshort(r2, t3), t3 += 2, o.maxComponentElements = n2.readUshort(r2, t3), t3 += 2, o.maxComponentDepth = n2.readUshort(r2, t3), t3 += 2), o;
    }, e.name = {}, e.name.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {};
      n2.readUshort(r2, t3), t3 += 2;
      var s = n2.readUshort(r2, t3);
      t3 += 2, n2.readUshort(r2, t3);
      for (var i, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], f = t3 += 2, d = 0; d < s; d++) {
        var l = n2.readUshort(r2, t3);
        t3 += 2;
        var u = n2.readUshort(r2, t3);
        t3 += 2;
        var v = n2.readUshort(r2, t3);
        t3 += 2;
        var c = n2.readUshort(r2, t3);
        t3 += 2;
        var p2 = n2.readUshort(r2, t3);
        t3 += 2;
        var U = n2.readUshort(r2, t3);
        t3 += 2;
        var g2, S = h[c], m = f + 12 * s + U;
        if (0 == l)
          g2 = n2.readUnicode(r2, m, p2 / 2);
        else if (3 == l && 0 == u)
          g2 = n2.readUnicode(r2, m, p2 / 2);
        else if (0 == u)
          g2 = n2.readASCII(r2, m, p2);
        else if (1 == u)
          g2 = n2.readUnicode(r2, m, p2 / 2);
        else if (3 == u)
          g2 = n2.readUnicode(r2, m, p2 / 2);
        else {
          if (1 != l)
            throw "unknown encoding " + u + ", platformID: " + l;
          g2 = n2.readASCII(r2, m, p2), console.debug("reading unknown MAC encoding " + u + " as ASCII");
        }
        var b = "p" + l + "," + v.toString(16);
        null == o[b] && (o[b] = {}), o[b][void 0 !== S ? S : c] = g2, o[b]._lang = v;
      }
      for (var y in o)
        if (null != o[y].postScriptName && 1033 == o[y]._lang)
          return o[y];
      for (var y in o)
        if (null != o[y].postScriptName && 0 == o[y]._lang)
          return o[y];
      for (var y in o)
        if (null != o[y].postScriptName && 3084 == o[y]._lang)
          return o[y];
      for (var y in o)
        if (null != o[y].postScriptName)
          return o[y];
      for (var y in o) {
        i = y;
        break;
      }
      return console.debug("returning name table with languageID " + o[i]._lang), o[i];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(r2, t3, a2) {
      var n2 = e._bin.readUshort(r2, t3);
      t3 += 2;
      var o = {};
      if (0 == n2)
        e["OS/2"].version0(r2, t3, o);
      else if (1 == n2)
        e["OS/2"].version1(r2, t3, o);
      else if (2 == n2 || 3 == n2 || 4 == n2)
        e["OS/2"].version2(r2, t3, o);
      else {
        if (5 != n2)
          throw "unknown OS/2 table version: " + n2;
        e["OS/2"].version5(r2, t3, o);
      }
      return o;
    }, e["OS/2"].version0 = function(r2, t3, a2) {
      var n2 = e._bin;
      return a2.xAvgCharWidth = n2.readShort(r2, t3), t3 += 2, a2.usWeightClass = n2.readUshort(r2, t3), t3 += 2, a2.usWidthClass = n2.readUshort(r2, t3), t3 += 2, a2.fsType = n2.readUshort(r2, t3), t3 += 2, a2.ySubscriptXSize = n2.readShort(r2, t3), t3 += 2, a2.ySubscriptYSize = n2.readShort(r2, t3), t3 += 2, a2.ySubscriptXOffset = n2.readShort(r2, t3), t3 += 2, a2.ySubscriptYOffset = n2.readShort(r2, t3), t3 += 2, a2.ySuperscriptXSize = n2.readShort(r2, t3), t3 += 2, a2.ySuperscriptYSize = n2.readShort(r2, t3), t3 += 2, a2.ySuperscriptXOffset = n2.readShort(r2, t3), t3 += 2, a2.ySuperscriptYOffset = n2.readShort(r2, t3), t3 += 2, a2.yStrikeoutSize = n2.readShort(r2, t3), t3 += 2, a2.yStrikeoutPosition = n2.readShort(r2, t3), t3 += 2, a2.sFamilyClass = n2.readShort(r2, t3), t3 += 2, a2.panose = n2.readBytes(r2, t3, 10), t3 += 10, a2.ulUnicodeRange1 = n2.readUint(r2, t3), t3 += 4, a2.ulUnicodeRange2 = n2.readUint(r2, t3), t3 += 4, a2.ulUnicodeRange3 = n2.readUint(r2, t3), t3 += 4, a2.ulUnicodeRange4 = n2.readUint(r2, t3), t3 += 4, a2.achVendID = [n2.readInt8(r2, t3), n2.readInt8(r2, t3 + 1), n2.readInt8(r2, t3 + 2), n2.readInt8(r2, t3 + 3)], t3 += 4, a2.fsSelection = n2.readUshort(r2, t3), t3 += 2, a2.usFirstCharIndex = n2.readUshort(r2, t3), t3 += 2, a2.usLastCharIndex = n2.readUshort(r2, t3), t3 += 2, a2.sTypoAscender = n2.readShort(r2, t3), t3 += 2, a2.sTypoDescender = n2.readShort(r2, t3), t3 += 2, a2.sTypoLineGap = n2.readShort(r2, t3), t3 += 2, a2.usWinAscent = n2.readUshort(r2, t3), t3 += 2, a2.usWinDescent = n2.readUshort(r2, t3), t3 += 2;
    }, e["OS/2"].version1 = function(r2, t3, a2) {
      var n2 = e._bin;
      return t3 = e["OS/2"].version0(r2, t3, a2), a2.ulCodePageRange1 = n2.readUint(r2, t3), t3 += 4, a2.ulCodePageRange2 = n2.readUint(r2, t3), t3 += 4;
    }, e["OS/2"].version2 = function(r2, t3, a2) {
      var n2 = e._bin;
      return t3 = e["OS/2"].version1(r2, t3, a2), a2.sxHeight = n2.readShort(r2, t3), t3 += 2, a2.sCapHeight = n2.readShort(r2, t3), t3 += 2, a2.usDefault = n2.readUshort(r2, t3), t3 += 2, a2.usBreak = n2.readUshort(r2, t3), t3 += 2, a2.usMaxContext = n2.readUshort(r2, t3), t3 += 2;
    }, e["OS/2"].version5 = function(r2, t3, a2) {
      var n2 = e._bin;
      return t3 = e["OS/2"].version2(r2, t3, a2), a2.usLowerOpticalPointSize = n2.readUshort(r2, t3), t3 += 2, a2.usUpperOpticalPointSize = n2.readUshort(r2, t3), t3 += 2;
    }, e.post = {}, e.post.parse = function(r2, t3, a2) {
      var n2 = e._bin, o = {};
      return o.version = n2.readFixed(r2, t3), t3 += 4, o.italicAngle = n2.readFixed(r2, t3), t3 += 4, o.underlinePosition = n2.readShort(r2, t3), t3 += 2, o.underlineThickness = n2.readShort(r2, t3), t3 += 2, o;
    }, null == e && (e = {}), null == e.U && (e.U = {}), e.U.codeToGlyph = function(r2, e2) {
      var t3 = r2.cmap, a2 = -1;
      if (null != t3.p0e4 ? a2 = t3.p0e4 : null != t3.p3e1 ? a2 = t3.p3e1 : null != t3.p1e0 ? a2 = t3.p1e0 : null != t3.p0e3 && (a2 = t3.p0e3), -1 == a2)
        throw "no familiar platform and encoding!";
      var n2 = t3.tables[a2];
      if (0 == n2.format)
        return e2 >= n2.map.length ? 0 : n2.map[e2];
      if (4 == n2.format) {
        for (var o = -1, s = 0; s < n2.endCount.length; s++)
          if (e2 <= n2.endCount[s]) {
            o = s;
            break;
          }
        if (-1 == o)
          return 0;
        if (n2.startCount[o] > e2)
          return 0;
        return 65535 & (0 != n2.idRangeOffset[o] ? n2.glyphIdArray[e2 - n2.startCount[o] + (n2.idRangeOffset[o] >> 1) - (n2.idRangeOffset.length - o)] : e2 + n2.idDelta[o]);
      }
      if (12 == n2.format) {
        if (e2 > n2.groups[n2.groups.length - 1][1])
          return 0;
        for (s = 0; s < n2.groups.length; s++) {
          var i = n2.groups[s];
          if (i[0] <= e2 && e2 <= i[1])
            return i[2] + (e2 - i[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + n2.format;
    }, e.U.glyphToPath = function(r2, t3) {
      var a2 = { cmds: [], crds: [] };
      if (r2.SVG && r2.SVG.entries[t3]) {
        var n2 = r2.SVG.entries[t3];
        return null == n2 ? a2 : ("string" == typeof n2 && (n2 = e.SVG.toPath(n2), r2.SVG.entries[t3] = n2), n2);
      }
      if (r2.CFF) {
        var o = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: false, width: r2.CFF.Private ? r2.CFF.Private.defaultWidthX : 0, open: false }, s = r2.CFF, i = r2.CFF.Private;
        if (s.ROS) {
          for (var h = 0; s.FDSelect[h + 2] <= t3; )
            h += 2;
          i = s.FDArray[s.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(r2.CFF.CharStrings[t3], o, s, i, a2);
      } else
        r2.glyf && e.U._drawGlyf(t3, r2, a2);
      return a2;
    }, e.U._drawGlyf = function(r2, t3, a2) {
      var n2 = t3.glyf[r2];
      null == n2 && (n2 = t3.glyf[r2] = e.glyf._parseGlyf(t3, r2)), null != n2 && (n2.noc > -1 ? e.U._simpleGlyph(n2, a2) : e.U._compoGlyph(n2, t3, a2));
    }, e.U._simpleGlyph = function(r2, t3) {
      for (var a2 = 0; a2 < r2.noc; a2++) {
        for (var n2 = 0 == a2 ? 0 : r2.endPts[a2 - 1] + 1, o = r2.endPts[a2], s = n2; s <= o; s++) {
          var i = s == n2 ? o : s - 1, h = s == o ? n2 : s + 1, f = 1 & r2.flags[s], d = 1 & r2.flags[i], l = 1 & r2.flags[h], u = r2.xs[s], v = r2.ys[s];
          if (s == n2)
            if (f) {
              if (!d) {
                e.U.P.moveTo(t3, u, v);
                continue;
              }
              e.U.P.moveTo(t3, r2.xs[i], r2.ys[i]);
            } else
              d ? e.U.P.moveTo(t3, r2.xs[i], r2.ys[i]) : e.U.P.moveTo(t3, (r2.xs[i] + u) / 2, (r2.ys[i] + v) / 2);
          f ? d && e.U.P.lineTo(t3, u, v) : l ? e.U.P.qcurveTo(t3, u, v, r2.xs[h], r2.ys[h]) : e.U.P.qcurveTo(t3, u, v, (u + r2.xs[h]) / 2, (v + r2.ys[h]) / 2);
        }
        e.U.P.closePath(t3);
      }
    }, e.U._compoGlyph = function(r2, t3, a2) {
      for (var n2 = 0; n2 < r2.parts.length; n2++) {
        var o = { cmds: [], crds: [] }, s = r2.parts[n2];
        e.U._drawGlyf(s.glyphIndex, t3, o);
        for (var i = s.m, h = 0; h < o.crds.length; h += 2) {
          var f = o.crds[h], d = o.crds[h + 1];
          a2.crds.push(f * i.a + d * i.b + i.tx), a2.crds.push(f * i.c + d * i.d + i.ty);
        }
        for (h = 0; h < o.cmds.length; h++)
          a2.cmds.push(o.cmds[h]);
      }
    }, e.U._getGlyphClass = function(r2, t3) {
      var a2 = e._lctf.getInterval(t3, r2);
      return -1 == a2 ? 0 : t3[a2 + 2];
    }, e.U.getPairAdjustment = function(r2, t3, a2) {
      var n2 = 0, o = false;
      if (r2.GPOS)
        for (var s = r2.GPOS, i = s.lookupList, h = s.featureList, f = [], d = 0; d < h.length; d++) {
          var l = h[d];
          if ("kern" == l.tag) {
            o = true;
            for (var u = 0; u < l.tab.length; u++)
              if (!f[l.tab[u]]) {
                f[l.tab[u]] = true;
                for (var v = i[l.tab[u]], c = 0; c < v.tabs.length; c++)
                  if (null != v.tabs[c]) {
                    var p2, U = v.tabs[c];
                    if (!U.coverage || -1 != (p2 = e._lctf.coverageIndex(U.coverage, t3))) {
                      if (1 == v.ltype)
                        ;
                      else if (2 == v.ltype) {
                        var g2;
                        if (1 == U.fmt) {
                          var S = U.pairsets[p2];
                          for (d = 0; d < S.length; d++)
                            S[d].gid2 == a2 && (g2 = S[d]);
                        } else if (2 == U.fmt) {
                          var m = e.U._getGlyphClass(t3, U.classDef1), b = e.U._getGlyphClass(a2, U.classDef2);
                          g2 = U.matrix[m][b];
                        }
                        g2 && g2.val1 && g2.val1[2] && (n2 += g2.val1[2]), g2 && g2.val2 && g2.val2[0] && (n2 += g2.val2[0]);
                      }
                    }
                  }
              }
          }
        }
      if (r2.kern && !o) {
        var y = r2.kern.glyph1.indexOf(t3);
        if (-1 != y) {
          var F = r2.kern.rval[y].glyph2.indexOf(a2);
          -1 != F && (n2 += r2.kern.rval[y].vals[F]);
        }
      }
      return n2;
    }, e.U._applySubs = function(r2, t3, a2, n2) {
      for (var o = r2.length - t3 - 1, s = 0; s < a2.tabs.length; s++)
        if (null != a2.tabs[s]) {
          var i, h = a2.tabs[s];
          if (!h.coverage || -1 != (i = e._lctf.coverageIndex(h.coverage, r2[t3]))) {
            if (1 == a2.ltype)
              r2[t3], 1 == h.fmt ? r2[t3] = r2[t3] + h.delta : r2[t3] = h.newg[i];
            else if (4 == a2.ltype)
              for (var f = h.vals[i], d = 0; d < f.length; d++) {
                var l = f[d], u = l.chain.length;
                if (!(u > o)) {
                  for (var v = true, c = 0, p2 = 0; p2 < u; p2++) {
                    for (; -1 == r2[t3 + c + (1 + p2)]; )
                      c++;
                    l.chain[p2] != r2[t3 + c + (1 + p2)] && (v = false);
                  }
                  if (v) {
                    r2[t3] = l.nglyph;
                    for (p2 = 0; p2 < u + c; p2++)
                      r2[t3 + p2 + 1] = -1;
                    break;
                  }
                }
              }
            else if (5 == a2.ltype && 2 == h.fmt)
              for (var U = e._lctf.getInterval(h.cDef, r2[t3]), g2 = h.cDef[U + 2], S = h.scset[g2], m = 0; m < S.length; m++) {
                var b = S[m], y = b.input;
                if (!(y.length > o)) {
                  for (v = true, p2 = 0; p2 < y.length; p2++) {
                    var F = e._lctf.getInterval(h.cDef, r2[t3 + 1 + p2]);
                    if (-1 == U && h.cDef[F + 2] != y[p2]) {
                      v = false;
                      break;
                    }
                  }
                  if (v) {
                    var _ = b.substLookupRecords;
                    for (d = 0; d < _.length; d += 2)
                      _[d], _[d + 1];
                  }
                }
              }
            else if (6 == a2.ltype && 3 == h.fmt) {
              if (!e.U._glsCovered(r2, h.backCvg, t3 - h.backCvg.length))
                continue;
              if (!e.U._glsCovered(r2, h.inptCvg, t3))
                continue;
              if (!e.U._glsCovered(r2, h.ahedCvg, t3 + h.inptCvg.length))
                continue;
              var C2 = h.lookupRec;
              for (m = 0; m < C2.length; m += 2) {
                U = C2[m];
                var x2 = n2[C2[m + 1]];
                e.U._applySubs(r2, t3 + U, x2, n2);
              }
            }
          }
        }
    }, e.U._glsCovered = function(r2, t3, a2) {
      for (var n2 = 0; n2 < t3.length; n2++) {
        if (-1 == e._lctf.coverageIndex(t3[n2], r2[a2 + n2]))
          return false;
      }
      return true;
    }, e.U.glyphsToPath = function(r2, t3, a2) {
      for (var n2 = { cmds: [], crds: [] }, o = 0, s = 0; s < t3.length; s++) {
        var i = t3[s];
        if (-1 != i) {
          for (var h = s < t3.length - 1 && -1 != t3[s + 1] ? t3[s + 1] : 0, f = e.U.glyphToPath(r2, i), d = 0; d < f.crds.length; d += 2)
            n2.crds.push(f.crds[d] + o), n2.crds.push(f.crds[d + 1]);
          a2 && n2.cmds.push(a2);
          for (d = 0; d < f.cmds.length; d++)
            n2.cmds.push(f.cmds[d]);
          a2 && n2.cmds.push("X"), o += r2.hmtx.aWidth[i], s < t3.length - 1 && (o += e.U.getPairAdjustment(r2, i, h));
        }
      }
      return n2;
    }, e.U.P = {}, e.U.P.moveTo = function(r2, e2, t3) {
      r2.cmds.push("M"), r2.crds.push(e2, t3);
    }, e.U.P.lineTo = function(r2, e2, t3) {
      r2.cmds.push("L"), r2.crds.push(e2, t3);
    }, e.U.P.curveTo = function(r2, e2, t3, a2, n2, o, s) {
      r2.cmds.push("C"), r2.crds.push(e2, t3, a2, n2, o, s);
    }, e.U.P.qcurveTo = function(r2, e2, t3, a2, n2) {
      r2.cmds.push("Q"), r2.crds.push(e2, t3, a2, n2);
    }, e.U.P.closePath = function(r2) {
      r2.cmds.push("Z");
    }, e.U._drawCFF = function(r2, t3, a2, n2, o) {
      for (var s = t3.stack, i = t3.nStems, h = t3.haveWidth, f = t3.width, d = t3.open, l = 0, u = t3.x, v = t3.y, c = 0, p2 = 0, U = 0, g2 = 0, S = 0, m = 0, b = 0, y = 0, F = 0, _ = 0, C2 = { val: 0, size: 0 }; l < r2.length; ) {
        e.CFF.getCharString(r2, l, C2);
        var x2 = C2.val;
        if (l += C2.size, "o1" == x2 || "o18" == x2)
          s.length % 2 != 0 && !h && (f = s.shift() + n2.nominalWidthX), i += s.length >> 1, s.length = 0, h = true;
        else if ("o3" == x2 || "o23" == x2) {
          s.length % 2 != 0 && !h && (f = s.shift() + n2.nominalWidthX), i += s.length >> 1, s.length = 0, h = true;
        } else if ("o4" == x2)
          s.length > 1 && !h && (f = s.shift() + n2.nominalWidthX, h = true), d && e.U.P.closePath(o), v += s.pop(), e.U.P.moveTo(o, u, v), d = true;
        else if ("o5" == x2)
          for (; s.length > 0; )
            u += s.shift(), v += s.shift(), e.U.P.lineTo(o, u, v);
        else if ("o6" == x2 || "o7" == x2)
          for (var P = s.length, I2 = "o6" == x2, w = 0; w < P; w++) {
            var O = s.shift();
            I2 ? u += O : v += O, I2 = !I2, e.U.P.lineTo(o, u, v);
          }
        else if ("o8" == x2 || "o24" == x2) {
          P = s.length;
          for (var T2 = 0; T2 + 6 <= P; )
            c = u + s.shift(), p2 = v + s.shift(), U = c + s.shift(), g2 = p2 + s.shift(), u = U + s.shift(), v = g2 + s.shift(), e.U.P.curveTo(o, c, p2, U, g2, u, v), T2 += 6;
          "o24" == x2 && (u += s.shift(), v += s.shift(), e.U.P.lineTo(o, u, v));
        } else {
          if ("o11" == x2)
            break;
          if ("o1234" == x2 || "o1235" == x2 || "o1236" == x2 || "o1237" == x2)
            "o1234" == x2 && (p2 = v, U = (c = u + s.shift()) + s.shift(), _ = g2 = p2 + s.shift(), m = g2, y = v, u = (b = (S = (F = U + s.shift()) + s.shift()) + s.shift()) + s.shift(), e.U.P.curveTo(o, c, p2, U, g2, F, _), e.U.P.curveTo(o, S, m, b, y, u, v)), "o1235" == x2 && (c = u + s.shift(), p2 = v + s.shift(), U = c + s.shift(), g2 = p2 + s.shift(), F = U + s.shift(), _ = g2 + s.shift(), S = F + s.shift(), m = _ + s.shift(), b = S + s.shift(), y = m + s.shift(), u = b + s.shift(), v = y + s.shift(), s.shift(), e.U.P.curveTo(o, c, p2, U, g2, F, _), e.U.P.curveTo(o, S, m, b, y, u, v)), "o1236" == x2 && (c = u + s.shift(), p2 = v + s.shift(), U = c + s.shift(), _ = g2 = p2 + s.shift(), m = g2, b = (S = (F = U + s.shift()) + s.shift()) + s.shift(), y = m + s.shift(), u = b + s.shift(), e.U.P.curveTo(o, c, p2, U, g2, F, _), e.U.P.curveTo(o, S, m, b, y, u, v)), "o1237" == x2 && (c = u + s.shift(), p2 = v + s.shift(), U = c + s.shift(), g2 = p2 + s.shift(), F = U + s.shift(), _ = g2 + s.shift(), S = F + s.shift(), m = _ + s.shift(), b = S + s.shift(), y = m + s.shift(), Math.abs(b - u) > Math.abs(y - v) ? u = b + s.shift() : v = y + s.shift(), e.U.P.curveTo(o, c, p2, U, g2, F, _), e.U.P.curveTo(o, S, m, b, y, u, v));
          else if ("o14" == x2) {
            if (s.length > 0 && !h && (f = s.shift() + a2.nominalWidthX, h = true), 4 == s.length) {
              var k = s.shift(), G = s.shift(), D = s.shift(), B2 = s.shift(), L = e.CFF.glyphBySE(a2, D), R = e.CFF.glyphBySE(a2, B2);
              e.U._drawCFF(a2.CharStrings[L], t3, a2, n2, o), t3.x = k, t3.y = G, e.U._drawCFF(a2.CharStrings[R], t3, a2, n2, o);
            }
            d && (e.U.P.closePath(o), d = false);
          } else if ("o19" == x2 || "o20" == x2) {
            s.length % 2 != 0 && !h && (f = s.shift() + n2.nominalWidthX), i += s.length >> 1, s.length = 0, h = true, l += i + 7 >> 3;
          } else if ("o21" == x2)
            s.length > 2 && !h && (f = s.shift() + n2.nominalWidthX, h = true), v += s.pop(), u += s.pop(), d && e.U.P.closePath(o), e.U.P.moveTo(o, u, v), d = true;
          else if ("o22" == x2)
            s.length > 1 && !h && (f = s.shift() + n2.nominalWidthX, h = true), u += s.pop(), d && e.U.P.closePath(o), e.U.P.moveTo(o, u, v), d = true;
          else if ("o25" == x2) {
            for (; s.length > 6; )
              u += s.shift(), v += s.shift(), e.U.P.lineTo(o, u, v);
            c = u + s.shift(), p2 = v + s.shift(), U = c + s.shift(), g2 = p2 + s.shift(), u = U + s.shift(), v = g2 + s.shift(), e.U.P.curveTo(o, c, p2, U, g2, u, v);
          } else if ("o26" == x2)
            for (s.length % 2 && (u += s.shift()); s.length > 0; )
              c = u, p2 = v + s.shift(), u = U = c + s.shift(), v = (g2 = p2 + s.shift()) + s.shift(), e.U.P.curveTo(o, c, p2, U, g2, u, v);
          else if ("o27" == x2)
            for (s.length % 2 && (v += s.shift()); s.length > 0; )
              p2 = v, U = (c = u + s.shift()) + s.shift(), g2 = p2 + s.shift(), u = U + s.shift(), v = g2, e.U.P.curveTo(o, c, p2, U, g2, u, v);
          else if ("o10" == x2 || "o29" == x2) {
            var A2 = "o10" == x2 ? n2 : a2;
            if (0 == s.length)
              console.debug("error: empty stack");
            else {
              var W = s.pop(), M = A2.Subrs[W + A2.Bias];
              t3.x = u, t3.y = v, t3.nStems = i, t3.haveWidth = h, t3.width = f, t3.open = d, e.U._drawCFF(M, t3, a2, n2, o), u = t3.x, v = t3.y, i = t3.nStems, h = t3.haveWidth, f = t3.width, d = t3.open;
            }
          } else if ("o30" == x2 || "o31" == x2) {
            var V = s.length, N = (T2 = 0, "o31" == x2);
            for (T2 += V - (P = -3 & V); T2 < P; )
              N ? (p2 = v, U = (c = u + s.shift()) + s.shift(), v = (g2 = p2 + s.shift()) + s.shift(), P - T2 == 5 ? (u = U + s.shift(), T2++) : u = U, N = false) : (c = u, p2 = v + s.shift(), U = c + s.shift(), g2 = p2 + s.shift(), u = U + s.shift(), P - T2 == 5 ? (v = g2 + s.shift(), T2++) : v = g2, N = true), e.U.P.curveTo(o, c, p2, U, g2, u, v), T2 += 4;
          } else {
            if ("o" == (x2 + "").charAt(0))
              throw console.debug("Unknown operation: " + x2, r2), x2;
            s.push(x2);
          }
        }
      }
      t3.x = u, t3.y = v, t3.nStems = i, t3.haveWidth = h, t3.width = f, t3.open = d;
    };
    var t2 = e, a = { Typr: t2 };
    return r.Typr = t2, r.default = a, Object.defineProperty(r, "__esModule", { value: true }), r;
  }({}).Typr;
}
function woff2otfFactory() {
  return function(r) {
    var e = Uint8Array, n2 = Uint16Array, t2 = Uint32Array, a = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), i = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), o = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), f = function(r2, e2) {
      for (var a2 = new n2(31), i2 = 0; i2 < 31; ++i2)
        a2[i2] = e2 += 1 << r2[i2 - 1];
      var o2 = new t2(a2[30]);
      for (i2 = 1; i2 < 30; ++i2)
        for (var f2 = a2[i2]; f2 < a2[i2 + 1]; ++f2)
          o2[f2] = f2 - a2[i2] << 5 | i2;
      return [a2, o2];
    }, u = f(a, 2), v = u[0], s = u[1];
    v[28] = 258, s[258] = 28;
    for (var l = f(i, 0)[0], c = new n2(32768), g2 = 0; g2 < 32768; ++g2) {
      var h = (43690 & g2) >>> 1 | (21845 & g2) << 1;
      h = (61680 & (h = (52428 & h) >>> 2 | (13107 & h) << 2)) >>> 4 | (3855 & h) << 4, c[g2] = ((65280 & h) >>> 8 | (255 & h) << 8) >>> 1;
    }
    var w = function(r2, e2, t3) {
      for (var a2 = r2.length, i2 = 0, o2 = new n2(e2); i2 < a2; ++i2)
        ++o2[r2[i2] - 1];
      var f2, u2 = new n2(e2);
      for (i2 = 0; i2 < e2; ++i2)
        u2[i2] = u2[i2 - 1] + o2[i2 - 1] << 1;
      if (t3) {
        f2 = new n2(1 << e2);
        var v4 = 15 - e2;
        for (i2 = 0; i2 < a2; ++i2)
          if (r2[i2])
            for (var s2 = i2 << 4 | r2[i2], l2 = e2 - r2[i2], g3 = u2[r2[i2] - 1]++ << l2, h2 = g3 | (1 << l2) - 1; g3 <= h2; ++g3)
              f2[c[g3] >>> v4] = s2;
      } else
        for (f2 = new n2(a2), i2 = 0; i2 < a2; ++i2)
          r2[i2] && (f2[i2] = c[u2[r2[i2] - 1]++] >>> 15 - r2[i2]);
      return f2;
    }, d = new e(288);
    for (g2 = 0; g2 < 144; ++g2)
      d[g2] = 8;
    for (g2 = 144; g2 < 256; ++g2)
      d[g2] = 9;
    for (g2 = 256; g2 < 280; ++g2)
      d[g2] = 7;
    for (g2 = 280; g2 < 288; ++g2)
      d[g2] = 8;
    var m = new e(32);
    for (g2 = 0; g2 < 32; ++g2)
      m[g2] = 5;
    var b = w(d, 9, 1), p2 = w(m, 5, 1), y = function(r2) {
      for (var e2 = r2[0], n3 = 1; n3 < r2.length; ++n3)
        r2[n3] > e2 && (e2 = r2[n3]);
      return e2;
    }, L = function(r2, e2, n3) {
      var t3 = e2 / 8 | 0;
      return (r2[t3] | r2[t3 + 1] << 8) >> (7 & e2) & n3;
    }, U = function(r2, e2) {
      var n3 = e2 / 8 | 0;
      return (r2[n3] | r2[n3 + 1] << 8 | r2[n3 + 2] << 16) >> (7 & e2);
    }, k = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], T2 = function(r2, e2, n3) {
      var t3 = new Error(e2 || k[r2]);
      if (t3.code = r2, Error.captureStackTrace && Error.captureStackTrace(t3, T2), !n3)
        throw t3;
      return t3;
    }, O = function(r2, f2, u2) {
      var s2 = r2.length;
      if (!s2 || u2 && !u2.l && s2 < 5)
        return f2 || new e(0);
      var c2 = !f2 || u2, g3 = !u2 || u2.i;
      u2 || (u2 = {}), f2 || (f2 = new e(3 * s2));
      var h2, d2 = function(r3) {
        var n3 = f2.length;
        if (r3 > n3) {
          var t3 = new e(Math.max(2 * n3, r3));
          t3.set(f2), f2 = t3;
        }
      }, m2 = u2.f || 0, k2 = u2.p || 0, O2 = u2.b || 0, A3 = u2.l, x3 = u2.d, E = u2.m, D = u2.n, M = 8 * s2;
      do {
        if (!A3) {
          u2.f = m2 = L(r2, k2, 1);
          var S = L(r2, k2 + 1, 3);
          if (k2 += 3, !S) {
            var V = r2[(I2 = ((h2 = k2) / 8 | 0) + (7 & h2 && 1) + 4) - 4] | r2[I2 - 3] << 8, _ = I2 + V;
            if (_ > s2) {
              g3 && T2(0);
              break;
            }
            c2 && d2(O2 + V), f2.set(r2.subarray(I2, _), O2), u2.b = O2 += V, u2.p = k2 = 8 * _;
            continue;
          }
          if (1 == S)
            A3 = b, x3 = p2, E = 9, D = 5;
          else if (2 == S) {
            var j = L(r2, k2, 31) + 257, z = L(r2, k2 + 10, 15) + 4, C2 = j + L(r2, k2 + 5, 31) + 1;
            k2 += 14;
            for (var F = new e(C2), P = new e(19), q = 0; q < z; ++q)
              P[o[q]] = L(r2, k2 + 3 * q, 7);
            k2 += 3 * z;
            var B2 = y(P), G = (1 << B2) - 1, H = w(P, B2, 1);
            for (q = 0; q < C2; ) {
              var I2, J = H[L(r2, k2, G)];
              if (k2 += 15 & J, (I2 = J >>> 4) < 16)
                F[q++] = I2;
              else {
                var K = 0, N = 0;
                for (16 == I2 ? (N = 3 + L(r2, k2, 3), k2 += 2, K = F[q - 1]) : 17 == I2 ? (N = 3 + L(r2, k2, 7), k2 += 3) : 18 == I2 && (N = 11 + L(r2, k2, 127), k2 += 7); N--; )
                  F[q++] = K;
              }
            }
            var Q2 = F.subarray(0, j), R = F.subarray(j);
            E = y(Q2), D = y(R), A3 = w(Q2, E, 1), x3 = w(R, D, 1);
          } else
            T2(1);
          if (k2 > M) {
            g3 && T2(0);
            break;
          }
        }
        c2 && d2(O2 + 131072);
        for (var W = (1 << E) - 1, X = (1 << D) - 1, Y = k2; ; Y = k2) {
          var Z = (K = A3[U(r2, k2) & W]) >>> 4;
          if ((k2 += 15 & K) > M) {
            g3 && T2(0);
            break;
          }
          if (K || T2(2), Z < 256)
            f2[O2++] = Z;
          else {
            if (256 == Z) {
              Y = k2, A3 = null;
              break;
            }
            var $ = Z - 254;
            if (Z > 264) {
              var rr = a[q = Z - 257];
              $ = L(r2, k2, (1 << rr) - 1) + v[q], k2 += rr;
            }
            var er = x3[U(r2, k2) & X], nr = er >>> 4;
            er || T2(3), k2 += 15 & er;
            R = l[nr];
            if (nr > 3) {
              rr = i[nr];
              R += U(r2, k2) & (1 << rr) - 1, k2 += rr;
            }
            if (k2 > M) {
              g3 && T2(0);
              break;
            }
            c2 && d2(O2 + 131072);
            for (var tr = O2 + $; O2 < tr; O2 += 4)
              f2[O2] = f2[O2 - R], f2[O2 + 1] = f2[O2 + 1 - R], f2[O2 + 2] = f2[O2 + 2 - R], f2[O2 + 3] = f2[O2 + 3 - R];
            O2 = tr;
          }
        }
        u2.l = A3, u2.p = Y, u2.b = O2, A3 && (m2 = 1, u2.m = E, u2.d = x3, u2.n = D);
      } while (!m2);
      return O2 == f2.length ? f2 : function(r3, a2, i2) {
        (null == a2 || a2 < 0) && (a2 = 0), (null == i2 || i2 > r3.length) && (i2 = r3.length);
        var o2 = new (r3 instanceof n2 ? n2 : r3 instanceof t2 ? t2 : e)(i2 - a2);
        return o2.set(r3.subarray(a2, i2)), o2;
      }(f2, 0, O2);
    }, A2 = new e(0);
    var x2 = "undefined" != typeof TextDecoder && new TextDecoder();
    try {
      x2.decode(A2, { stream: true }), 1;
    } catch (r2) {
    }
    return r.convert_streams = function(r2) {
      var e2 = new DataView(r2), n3 = 0;
      function t3() {
        var r3 = e2.getUint16(n3);
        return n3 += 2, r3;
      }
      function a2() {
        var r3 = e2.getUint32(n3);
        return n3 += 4, r3;
      }
      function i2(r3) {
        m2.setUint16(b2, r3), b2 += 2;
      }
      function o2(r3) {
        m2.setUint32(b2, r3), b2 += 4;
      }
      for (var f2 = { signature: a2(), flavor: a2(), length: a2(), numTables: t3(), reserved: t3(), totalSfntSize: a2(), majorVersion: t3(), minorVersion: t3(), metaOffset: a2(), metaLength: a2(), metaOrigLength: a2(), privOffset: a2(), privLength: a2() }, u2 = 0; Math.pow(2, u2) <= f2.numTables; )
        u2++;
      u2--;
      for (var v4 = 16 * Math.pow(2, u2), s2 = 16 * f2.numTables - v4, l2 = 12, c2 = [], g3 = 0; g3 < f2.numTables; g3++)
        c2.push({ tag: a2(), offset: a2(), compLength: a2(), origLength: a2(), origChecksum: a2() }), l2 += 16;
      var h2, w2 = new Uint8Array(12 + 16 * c2.length + c2.reduce(function(r3, e3) {
        return r3 + e3.origLength + 4;
      }, 0)), d2 = w2.buffer, m2 = new DataView(d2), b2 = 0;
      return o2(f2.flavor), i2(f2.numTables), i2(v4), i2(u2), i2(s2), c2.forEach(function(r3) {
        o2(r3.tag), o2(r3.origChecksum), o2(l2), o2(r3.origLength), r3.outOffset = l2, (l2 += r3.origLength) % 4 != 0 && (l2 += 4 - l2 % 4);
      }), c2.forEach(function(e3) {
        var n4, t4 = r2.slice(e3.offset, e3.offset + e3.compLength);
        if (e3.compLength != e3.origLength) {
          var a3 = new Uint8Array(e3.origLength);
          n4 = new Uint8Array(t4, 2), O(n4, a3);
        } else
          a3 = new Uint8Array(t4);
        w2.set(a3, e3.outOffset);
        var i3 = 0;
        (l2 = e3.outOffset + e3.origLength) % 4 != 0 && (i3 = 4 - l2 % 4), w2.set(new Uint8Array(i3).buffer, e3.outOffset + e3.origLength), h2 = l2 + i3;
      }), d2.slice(0, h2);
    }, Object.defineProperty(r, "__esModule", { value: true }), r;
  }({}).convert_streams;
}
function parserFactory(Typr, woff2otf) {
  const cmdArgLengths = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  };
  const joiningTypeRawData = { "C": "18g,ca,368,1kz", "D": "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", "R": "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", "L": "x9u,jff,a,fd,jv", "T": "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" };
  const JT_LEFT = 1, JT_RIGHT = 2, JT_DUAL = 4, JT_TRANSPARENT = 8, JT_JOIN_CAUSING = 16, JT_NON_JOINING = 32;
  let joiningTypeMap;
  function getCharJoiningType(ch) {
    if (!joiningTypeMap) {
      const m = {
        R: JT_RIGHT,
        L: JT_LEFT,
        D: JT_DUAL,
        C: JT_JOIN_CAUSING,
        U: JT_NON_JOINING,
        T: JT_TRANSPARENT
      };
      joiningTypeMap = /* @__PURE__ */ new Map();
      for (let type in joiningTypeRawData) {
        let lastCode = 0;
        joiningTypeRawData[type].split(",").forEach((range) => {
          let [skip, step] = range.split("+");
          skip = parseInt(skip, 36);
          step = step ? parseInt(step, 36) : 0;
          joiningTypeMap.set(lastCode += skip, m[type]);
          for (let i = step; i--; ) {
            joiningTypeMap.set(++lastCode, m[type]);
          }
        });
      }
    }
    return joiningTypeMap.get(ch) || JT_NON_JOINING;
  }
  const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;
  const formsToFeatures = [null, "isol", "init", "fina", "medi"];
  function detectJoiningForms(str) {
    const joiningForms = new Uint8Array(str.length);
    let prevJoiningType = JT_NON_JOINING;
    let prevForm = ISOL;
    let prevIndex = -1;
    for (let i = 0; i < str.length; i++) {
      const code = str.codePointAt(i);
      let joiningType = getCharJoiningType(code) | 0;
      let form = ISOL;
      if (joiningType & JT_TRANSPARENT) {
        continue;
      }
      if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {
        if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {
          form = FINA;
          if (prevForm === ISOL || prevForm === FINA) {
            joiningForms[prevIndex]++;
          }
        } else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {
          if (prevForm === INIT || prevForm === MEDI) {
            joiningForms[prevIndex]--;
          }
        }
      } else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {
        if (prevForm === INIT || prevForm === MEDI) {
          joiningForms[prevIndex]--;
        }
      }
      prevForm = joiningForms[i] = form;
      prevJoiningType = joiningType;
      prevIndex = i;
      if (code > 65535)
        i++;
    }
    return joiningForms;
  }
  function stringToGlyphs(font, str) {
    const glyphIds = [];
    for (let i = 0; i < str.length; i++) {
      const cc = str.codePointAt(i);
      if (cc > 65535)
        i++;
      glyphIds.push(Typr.U.codeToGlyph(font, cc));
    }
    const gsub = font["GSUB"];
    if (gsub) {
      const { lookupList, featureList } = gsub;
      let joiningForms;
      const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/;
      const usedLookups = [];
      featureList.forEach((feature) => {
        if (supportedFeatures.test(feature.tag)) {
          for (let ti = 0; ti < feature.tab.length; ti++) {
            if (usedLookups[feature.tab[ti]])
              continue;
            usedLookups[feature.tab[ti]] = true;
            const tab = lookupList[feature.tab[ti]];
            const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);
            if (isJoiningFeature && !joiningForms) {
              joiningForms = detectJoiningForms(str);
            }
            for (let ci = 0; ci < glyphIds.length; ci++) {
              if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {
                Typr.U._applySubs(glyphIds, ci, tab, lookupList);
              }
            }
          }
        }
      });
    }
    return glyphIds;
  }
  function wrapFontObj(typrFont) {
    const glyphMap = /* @__PURE__ */ Object.create(null);
    const fontObj = {
      unitsPerEm: typrFont.head.unitsPerEm,
      ascender: typrFont.hhea.ascender,
      descender: typrFont.hhea.descender,
      forEachGlyph(text, fontSize, letterSpacing, callback) {
        let glyphX = 0;
        const fontScale = 1 / fontObj.unitsPerEm * fontSize;
        const glyphIndices = stringToGlyphs(typrFont, text);
        let charIndex = 0;
        let prevGlyphIndex = -1;
        glyphIndices.forEach((glyphIndex, i) => {
          if (glyphIndex !== -1) {
            let glyphObj = glyphMap[glyphIndex];
            if (!glyphObj) {
              const { cmds, crds } = Typr.U.glyphToPath(typrFont, glyphIndex);
              let path = "";
              let crdsIdx = 0;
              for (let i2 = 0, len = cmds.length; i2 < len; i2++) {
                const numArgs = cmdArgLengths[cmds[i2]];
                path += cmds[i2];
                for (let j = 1; j <= numArgs; j++) {
                  path += (j > 1 ? "," : "") + crds[crdsIdx++];
                }
              }
              let xMin, yMin, xMax, yMax;
              if (crds.length) {
                xMin = yMin = Infinity;
                xMax = yMax = -Infinity;
                for (let i2 = 0, len = crds.length; i2 < len; i2 += 2) {
                  let x2 = crds[i2];
                  let y = crds[i2 + 1];
                  if (x2 < xMin)
                    xMin = x2;
                  if (y < yMin)
                    yMin = y;
                  if (x2 > xMax)
                    xMax = x2;
                  if (y > yMax)
                    yMax = y;
                }
              } else {
                xMin = xMax = yMin = yMax = 0;
              }
              glyphObj = glyphMap[glyphIndex] = {
                index: glyphIndex,
                advanceWidth: typrFont.hmtx.aWidth[glyphIndex],
                xMin,
                yMin,
                xMax,
                yMax,
                path,
                pathCommandCount: cmds.length
                // forEachPathCommand(callback) {
                //   let argsIndex = 0
                //   const argsArray = []
                //   for (let i = 0, len = cmds.length; i < len; i++) {
                //     const numArgs = cmdArgLengths[cmds[i]]
                //     argsArray.length = 1 + numArgs
                //     argsArray[0] = cmds[i]
                //     for (let j = 1; j <= numArgs; j++) {
                //       argsArray[j] = crds[argsIndex++]
                //     }
                //     callback.apply(null, argsArray)
                //   }
                // }
              };
            }
            if (prevGlyphIndex !== -1) {
              glyphX += Typr.U.getPairAdjustment(typrFont, prevGlyphIndex, glyphIndex) * fontScale;
            }
            callback.call(null, glyphObj, glyphX, charIndex);
            if (glyphObj.advanceWidth) {
              glyphX += glyphObj.advanceWidth * fontScale;
            }
            if (letterSpacing) {
              glyphX += letterSpacing * fontSize;
            }
            prevGlyphIndex = glyphIndex;
          }
          charIndex += text.codePointAt(charIndex) > 65535 ? 2 : 1;
        });
        return glyphX;
      }
    };
    return fontObj;
  }
  return function parse(buffer) {
    const peek = new Uint8Array(buffer, 0, 4);
    const tag = Typr._bin.readASCII(peek, 0, 4);
    if (tag === "wOFF") {
      buffer = woff2otf(buffer);
    } else if (tag === "wOF2") {
      throw new Error("woff2 fonts not supported");
    }
    return wrapFontObj(Typr.parse(buffer)[0]);
  };
}
var workerModule = defineWorkerModule({
  name: "Typr Font Parser",
  dependencies: [typrFactory, woff2otfFactory, parserFactory],
  init(typrFactory2, woff2otfFactory2, parserFactory2) {
    const Typr = typrFactory2();
    const woff2otf = woff2otfFactory2();
    return parserFactory2(Typr, woff2otf);
  }
});
var CONFIG = {
  defaultFontURL: "https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff",
  //Roboto Regular
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
};
var tempColor = new Color();
var hasRequested = false;
function now$1() {
  return (self.performance || Date).now();
}
var atlases = /* @__PURE__ */ Object.create(null);
function getTextRenderInfo(args, callback) {
  hasRequested = true;
  args = assign3({}, args);
  const totalStart = now$1();
  args.font = toAbsoluteURL(args.font || CONFIG.defaultFontURL);
  args.text = "" + args.text;
  args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;
  if (args.colorRanges != null) {
    let colors = {};
    for (let key in args.colorRanges) {
      if (args.colorRanges.hasOwnProperty(key)) {
        let val = args.colorRanges[key];
        if (typeof val !== "number") {
          val = tempColor.set(val).getHex();
        }
        colors[key] = val;
      }
    }
    args.colorRanges = colors;
  }
  Object.freeze(args);
  const { textureWidth, sdfExponent } = CONFIG;
  const { sdfGlyphSize } = args;
  const glyphsPerRow = textureWidth / sdfGlyphSize * 4;
  let atlas = atlases[sdfGlyphSize];
  if (!atlas) {
    const canvas = document.createElement("canvas");
    canvas.width = textureWidth;
    canvas.height = sdfGlyphSize * 256 / glyphsPerRow;
    atlas = atlases[sdfGlyphSize] = {
      glyphCount: 0,
      sdfGlyphSize,
      sdfCanvas: canvas,
      sdfTexture: new Texture(
        canvas,
        void 0,
        void 0,
        void 0,
        LinearFilter,
        LinearFilter
      ),
      contextLost: false,
      glyphsByFont: /* @__PURE__ */ new Map()
    };
    atlas.sdfTexture.generateMipmaps = false;
    initContextLossHandling(atlas);
  }
  const { sdfTexture, sdfCanvas } = atlas;
  let fontGlyphs = atlas.glyphsByFont.get(args.font);
  if (!fontGlyphs) {
    atlas.glyphsByFont.set(args.font, fontGlyphs = /* @__PURE__ */ new Map());
  }
  typesetInWorker(args).then((result) => {
    const { glyphIds, glyphPositions, fontSize, unitsPerEm, timings } = result;
    const neededSDFs = [];
    const glyphBounds = new Float32Array(glyphIds.length * 4);
    const fontSizeMult = fontSize / unitsPerEm;
    let boundsIdx = 0;
    let positionsIdx = 0;
    const quadsStart = now$1();
    glyphIds.forEach((glyphId, i) => {
      let glyphInfo = fontGlyphs.get(glyphId);
      if (!glyphInfo) {
        const { path, pathBounds } = result.glyphData[glyphId];
        const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1]) / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);
        const atlasIndex = atlas.glyphCount++;
        const sdfViewBox2 = [
          pathBounds[0] - fontUnitsMargin,
          pathBounds[1] - fontUnitsMargin,
          pathBounds[2] + fontUnitsMargin,
          pathBounds[3] + fontUnitsMargin
        ];
        fontGlyphs.set(glyphId, glyphInfo = { path, atlasIndex, sdfViewBox: sdfViewBox2 });
        neededSDFs.push(glyphInfo);
      }
      const { sdfViewBox } = glyphInfo;
      const posX = glyphPositions[positionsIdx++];
      const posY = glyphPositions[positionsIdx++];
      glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;
      glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;
      glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;
      glyphIds[i] = glyphInfo.atlasIndex;
    });
    timings.quads = (timings.quads || 0) + (now$1() - quadsStart);
    const sdfStart = now$1();
    timings.sdf = {};
    const currentHeight = sdfCanvas.height;
    const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);
    const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));
    if (neededHeight > currentHeight) {
      console.info(`Increasing SDF texture size ${currentHeight}->${neededHeight}`);
      resizeWebGLCanvasWithoutClearing(sdfCanvas, textureWidth, neededHeight);
      sdfTexture.dispose();
    }
    DefaultThenable.all(neededSDFs.map(
      (glyphInfo) => generateGlyphSDF(glyphInfo, atlas, args.gpuAccelerateSDF).then(({ timing }) => {
        timings.sdf[glyphInfo.atlasIndex] = timing;
      })
    )).then(() => {
      if (neededSDFs.length && !atlas.contextLost) {
        safariPre15Workaround(atlas);
        sdfTexture.needsUpdate = true;
      }
      timings.sdfTotal = now$1() - sdfStart;
      timings.total = now$1() - totalStart;
      callback(Object.freeze({
        parameters: args,
        sdfTexture,
        sdfGlyphSize,
        sdfExponent,
        glyphBounds,
        glyphAtlasIndices: glyphIds,
        glyphColors: result.glyphColors,
        caretPositions: result.caretPositions,
        caretHeight: result.caretHeight,
        chunkedBounds: result.chunkedBounds,
        ascender: result.ascender,
        descender: result.descender,
        lineHeight: result.lineHeight,
        topBaseline: result.topBaseline,
        blockBounds: result.blockBounds,
        visibleBounds: result.visibleBounds,
        timings: result.timings,
        get totalBounds() {
          console.log("totalBounds deprecated, use blockBounds instead");
          return result.blockBounds;
        },
        get totalBlockSize() {
          console.log("totalBlockSize deprecated, use blockBounds instead");
          const [x0, y0, x1, y1] = result.blockBounds;
          return [x1 - x0, y1 - y0];
        }
      }));
    });
  });
  DefaultThenable.all([]).then(() => {
    if (!atlas.contextLost) {
      warmUpSDFCanvas(sdfCanvas);
    }
  });
}
function generateGlyphSDF({ path, atlasIndex, sdfViewBox }, { sdfGlyphSize, sdfCanvas, contextLost }, useGPU) {
  if (contextLost) {
    return Promise.resolve({ timing: -1 });
  }
  const { textureWidth, sdfExponent } = CONFIG;
  const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);
  const squareIndex = Math.floor(atlasIndex / 4);
  const x2 = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;
  const y = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;
  const channel = atlasIndex % 4;
  return generateSDF(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x2, y, channel, useGPU);
}
function initContextLossHandling(atlas) {
  const canvas = atlas.sdfCanvas;
  canvas.addEventListener("webglcontextlost", (event) => {
    console.log("Context Lost", event);
    event.preventDefault();
    atlas.contextLost = true;
  });
  canvas.addEventListener("webglcontextrestored", (event) => {
    console.log("Context Restored", event);
    atlas.contextLost = false;
    const promises = [];
    atlas.glyphsByFont.forEach((glyphMap) => {
      glyphMap.forEach((glyph) => {
        promises.push(generateGlyphSDF(glyph, atlas, true));
      });
    });
    DefaultThenable.all(promises).then(() => {
      safariPre15Workaround(atlas);
      atlas.sdfTexture.needsUpdate = true;
    });
  });
}
function assign3(toObj, fromObj) {
  for (let key in fromObj) {
    if (fromObj.hasOwnProperty(key)) {
      toObj[key] = fromObj[key];
    }
  }
  return toObj;
}
var linkEl;
function toAbsoluteURL(path) {
  if (!linkEl) {
    linkEl = typeof document === "undefined" ? {} : document.createElement("a");
  }
  linkEl.href = path;
  return linkEl.href;
}
function safariPre15Workaround(atlas) {
  if (typeof createImageBitmap !== "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas, sdfTexture } = atlas;
    const { width, height } = sdfCanvas;
    const gl = atlas.sdfCanvas.getContext("webgl");
    let pixels = sdfTexture.image.data;
    if (!pixels || pixels.length !== width * height * 4) {
      pixels = new Uint8Array(width * height * 4);
      sdfTexture.image = { width, height, data: pixels };
      sdfTexture.flipY = false;
      sdfTexture.isDataTexture = true;
    }
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
  }
}
var typesetterWorkerModule = defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    CONFIG,
    workerModule,
    createTypesetter,
    bidi_default
  ],
  init(config, fontParser, createTypesetter2, bidiFactory2) {
    const { defaultFontURL } = config;
    return createTypesetter2(fontParser, bidiFactory2(), { defaultFontURL });
  }
});
var typesetInWorker = defineWorkerModule({
  name: "Typesetter",
  dependencies: [
    typesetterWorkerModule,
    ThenableWorkerModule
  ],
  init(typesetter, Thenable) {
    return function(args) {
      const thenable = new Thenable();
      typesetter.typeset(args, thenable.resolve);
      return thenable;
    };
  },
  getTransferables(result) {
    const transferables = [
      result.glyphPositions.buffer,
      result.glyphIds.buffer
    ];
    if (result.caretPositions) {
      transferables.push(result.caretPositions.buffer);
    }
    if (result.glyphColors) {
      transferables.push(result.glyphColors.buffer);
    }
    return transferables;
  }
});
var GlyphsGeometry = (() => {
  const templateGeometries = {};
  function getTemplateGeometry(detail) {
    let geom = templateGeometries[detail];
    if (!geom) {
      const front = new PlaneBufferGeometry(1, 1, detail, detail);
      const back = front.clone();
      const frontAttrs = front.attributes;
      const backAttrs = back.attributes;
      const combined = new BufferGeometry();
      const vertCount = frontAttrs.uv.count;
      for (let i = 0; i < vertCount; i++) {
        backAttrs.position.array[i * 3] *= -1;
        backAttrs.normal.array[i * 3 + 2] *= -1;
      }
      ["position", "normal", "uv"].forEach((name) => {
        combined.setAttribute(
          name,
          new Float32BufferAttribute(
            [...frontAttrs[name].array, ...backAttrs[name].array],
            frontAttrs[name].itemSize
          )
        );
      });
      combined.setIndex([...front.index.array, ...back.index.array.map((n2) => n2 + vertCount)]);
      combined.translate(0.5, 0.5, 0);
      geom = templateGeometries[detail] = combined;
    }
    return geom;
  }
  const glyphBoundsAttrName = "aTroikaGlyphBounds";
  const glyphIndexAttrName = "aTroikaGlyphIndex";
  const glyphColorAttrName = "aTroikaGlyphColor";
  class GlyphsGeometry2 extends InstancedBufferGeometry {
    constructor() {
      super();
      this.detail = 1;
      this.curveRadius = 0;
      this.groups = [
        { start: 0, count: Infinity, materialIndex: 0 },
        { start: 0, count: Infinity, materialIndex: 1 }
      ];
      this.boundingSphere = new Sphere();
      this.boundingBox = new Box3();
    }
    computeBoundingSphere() {
    }
    computeBoundingBox() {
    }
    // Since our base geometry contains triangles for both front and back sides, we can emulate
    // the "side" by restricting the draw range.
    setSide(side) {
      const verts = this.getIndex().count;
      this.setDrawRange(side === BackSide ? verts / 2 : 0, side === DoubleSide ? verts : verts / 2);
    }
    set detail(detail) {
      if (detail !== this._detail) {
        this._detail = detail;
        if (typeof detail !== "number" || detail < 1) {
          detail = 1;
        }
        let tpl = getTemplateGeometry(detail);
        ["position", "normal", "uv"].forEach((attr) => {
          this.attributes[attr] = tpl.attributes[attr].clone();
        });
        this.setIndex(tpl.getIndex().clone());
      }
    }
    get detail() {
      return this._detail;
    }
    set curveRadius(r) {
      if (r !== this._curveRadius) {
        this._curveRadius = r;
        this._updateBounds();
      }
    }
    get curveRadius() {
      return this._curveRadius;
    }
    /**
     * Update the geometry for a new set of glyphs.
     * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
     *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
     * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
     *        the SDF atlas texture.
     * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
     * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
     *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
     *        used with `applyClipRect` to choose an optimized `instanceCount`.
     * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
     */
    updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {
      updateBufferAttr(this, glyphBoundsAttrName, glyphBounds, 4);
      updateBufferAttr(this, glyphIndexAttrName, glyphAtlasIndices, 1);
      updateBufferAttr(this, glyphColorAttrName, glyphColors, 3);
      this._blockBounds = blockBounds;
      this._chunkedBounds = chunkedBounds;
      setInstanceCount(this, glyphAtlasIndices.length);
      this._updateBounds();
    }
    _updateBounds() {
      const bounds = this._blockBounds;
      if (bounds) {
        const { curveRadius, boundingBox: bbox } = this;
        if (curveRadius) {
          const { PI, floor, min, max, sin, cos } = Math;
          const halfPi = PI / 2;
          const twoPi = PI * 2;
          const absR = Math.abs(curveRadius);
          const leftAngle = bounds[0] / absR;
          const rightAngle = bounds[2] / absR;
          const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi) ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);
          const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi) ? absR : max(sin(leftAngle) * absR, sin(rightAngle) * absR);
          const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi) ? absR * 2 : max(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);
          bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);
          bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);
        } else {
          bbox.min.set(bounds[0], bounds[1], 0);
          bbox.max.set(bounds[2], bounds[3], 0);
        }
        bbox.getBoundingSphere(this.boundingSphere);
      }
    }
    /**
     * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
     * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
     * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
     * be clipped anyway.
     *
     * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
     * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
     * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
     * but at the expense of much larger attribute buffers (see classdoc above.)
     *
     * @param {Vector4} clipRect
     */
    applyClipRect(clipRect) {
      let count = this.getAttribute(glyphIndexAttrName).count;
      let chunks = this._chunkedBounds;
      if (chunks) {
        for (let i = chunks.length; i--; ) {
          count = chunks[i].end;
          let rect = chunks[i].rect;
          if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {
            break;
          }
        }
      }
      setInstanceCount(this, count);
    }
  }
  if (!GlyphsGeometry2.prototype.setAttribute) {
    GlyphsGeometry2.prototype.setAttribute = function(name, attribute) {
      this.attributes[name] = attribute;
      return this;
    };
  }
  function updateBufferAttr(geom, attrName, newArray, itemSize) {
    const attr = geom.getAttribute(attrName);
    if (newArray) {
      if (attr && attr.array.length === newArray.length) {
        attr.array.set(newArray);
        attr.needsUpdate = true;
      } else {
        geom.setAttribute(attrName, new InstancedBufferAttribute(newArray, itemSize));
        delete geom._maxInstanceCount;
        geom.dispose();
      }
    } else if (attr) {
      geom.deleteAttribute(attrName);
    }
  }
  function setInstanceCount(geom, count) {
    geom[geom.hasOwnProperty("instanceCount") ? "instanceCount" : "maxInstancedCount"] = count;
  }
  return GlyphsGeometry2;
})();
var VERTEX_DEFS = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`;
var VERTEX_TRANSFORM = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);

${""}
float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`;
var FRAGMENT_DEFS = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  ${""}
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  ${""}
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  ${""}

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`;
var FRAGMENT_TRANSFORM = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function createTextDerivedMaterial(baseMaterial) {
  const textMaterial = createDerivedMaterial(baseMaterial, {
    chained: true,
    extensions: {
      derivatives: true
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new Vector2() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Vector4(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Vector4(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new Vector2() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Color() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Matrix3() },
      uTroikaUseGlyphColors: { value: true },
      uTroikaSDFDebug: { value: false }
    },
    vertexDefs: VERTEX_DEFS,
    vertexTransform: VERTEX_TRANSFORM,
    fragmentDefs: FRAGMENT_DEFS,
    fragmentColorTransform: FRAGMENT_TRANSFORM,
    customRewriter({ vertexShader, fragmentShader }) {
      let uDiffuseRE = /\buniform\s+vec3\s+diffuse\b/;
      if (uDiffuseRE.test(fragmentShader)) {
        fragmentShader = fragmentShader.replace(uDiffuseRE, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor");
        if (!uDiffuseRE.test(vertexShader)) {
          vertexShader = vertexShader.replace(
            voidMainRegExp,
            "uniform vec3 diffuse;\n$&\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\n"
          );
        }
      }
      return { vertexShader, fragmentShader };
    }
  });
  textMaterial.transparent = true;
  Object.defineProperties(textMaterial, {
    isTroikaTextMaterial: { value: true },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  });
  return textMaterial;
}
var Text = (() => {
  const defaultMaterial = new MeshBasicMaterial({
    color: 16777215,
    side: DoubleSide,
    transparent: true
  });
  const defaultStrokeColor = 8421504;
  const tempMat4 = new Matrix4();
  const tempVec3a = new Vector3();
  const tempVec3b = new Vector3();
  const tempArray = [];
  const origin = new Vector3();
  const defaultOrient = "+x+y";
  function first(o) {
    return Array.isArray(o) ? o[0] : o;
  }
  let getFlatRaycastMesh = () => {
    const mesh = new Mesh(
      new PlaneBufferGeometry(1, 1),
      defaultMaterial
    );
    getFlatRaycastMesh = () => mesh;
    return mesh;
  };
  let getCurvedRaycastMesh = () => {
    const mesh = new Mesh(
      new PlaneBufferGeometry(1, 1, 32, 1),
      defaultMaterial
    );
    getCurvedRaycastMesh = () => mesh;
    return mesh;
  };
  const syncStartEvent = { type: "syncstart" };
  const syncCompleteEvent = { type: "synccomplete" };
  const SYNCABLE_PROPS = [
    "font",
    "fontSize",
    "letterSpacing",
    "lineHeight",
    "maxWidth",
    "overflowWrap",
    "text",
    "direction",
    "textAlign",
    "textIndent",
    "whiteSpace",
    "anchorX",
    "anchorY",
    "colorRanges",
    "sdfGlyphSize"
  ];
  const COPYABLE_PROPS = SYNCABLE_PROPS.concat(
    "material",
    "color",
    "depthOffset",
    "clipRect",
    "curveRadius",
    "orientation",
    "glyphGeometryDetail"
  );
  class Text2 extends Mesh {
    constructor() {
      const geometry = new GlyphsGeometry();
      super(geometry, null);
      this.text = "";
      this.anchorX = 0;
      this.anchorY = 0;
      this.curveRadius = 0;
      this.direction = "auto";
      this.font = null;
      this.fontSize = 0.1;
      this.letterSpacing = 0;
      this.lineHeight = "normal";
      this.maxWidth = Infinity;
      this.overflowWrap = "normal";
      this.textAlign = "left";
      this.textIndent = 0;
      this.whiteSpace = "normal";
      this.material = null;
      this.color = null;
      this.colorRanges = null;
      this.outlineWidth = 0;
      this.outlineColor = 0;
      this.outlineOpacity = 1;
      this.outlineBlur = 0;
      this.outlineOffsetX = 0;
      this.outlineOffsetY = 0;
      this.strokeWidth = 0;
      this.strokeColor = defaultStrokeColor;
      this.strokeOpacity = 1;
      this.fillOpacity = 1;
      this.depthOffset = 0;
      this.clipRect = null;
      this.orientation = defaultOrient;
      this.glyphGeometryDetail = 1;
      this.sdfGlyphSize = null;
      this.gpuAccelerateSDF = true;
      this.debugSDF = false;
    }
    /**
     * Updates the text rendering according to the current text-related configuration properties.
     * This is an async process, so you can pass in a callback function to be executed when it
     * finishes.
     * @param {function} [callback]
     */
    sync(callback) {
      if (this._needsSync) {
        this._needsSync = false;
        if (this._isSyncing) {
          (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);
        } else {
          this._isSyncing = true;
          this.dispatchEvent(syncStartEvent);
          getTextRenderInfo({
            text: this.text,
            font: this.font,
            fontSize: this.fontSize || 0.1,
            letterSpacing: this.letterSpacing || 0,
            lineHeight: this.lineHeight || "normal",
            maxWidth: this.maxWidth,
            direction: this.direction || "auto",
            textAlign: this.textAlign,
            textIndent: this.textIndent,
            whiteSpace: this.whiteSpace,
            overflowWrap: this.overflowWrap,
            anchorX: this.anchorX,
            anchorY: this.anchorY,
            colorRanges: this.colorRanges,
            includeCaretPositions: true,
            //TODO parameterize
            sdfGlyphSize: this.sdfGlyphSize,
            gpuAccelerateSDF: this.gpuAccelerateSDF
          }, (textRenderInfo) => {
            this._isSyncing = false;
            this._textRenderInfo = textRenderInfo;
            this.geometry.updateGlyphs(
              textRenderInfo.glyphBounds,
              textRenderInfo.glyphAtlasIndices,
              textRenderInfo.blockBounds,
              textRenderInfo.chunkedBounds,
              textRenderInfo.glyphColors
            );
            const queued = this._queuedSyncs;
            if (queued) {
              this._queuedSyncs = null;
              this._needsSync = true;
              this.sync(() => {
                queued.forEach((fn) => fn && fn());
              });
            }
            this.dispatchEvent(syncCompleteEvent);
            if (callback) {
              callback();
            }
          });
        }
      }
    }
    /**
     * Initiate a sync if needed - note it won't complete until next frame at the
     * earliest so if possible it's a good idea to call sync() manually as soon as
     * all the properties have been set.
     * @override
     */
    onBeforeRender(renderer, scene, camera, geometry, material, group) {
      this.sync();
      if (material.isTroikaTextMaterial) {
        this._prepareForRender(material);
      }
      material._hadOwnSide = material.hasOwnProperty("side");
      this.geometry.setSide(material._actualSide = material.side);
      material.side = FrontSide;
    }
    onAfterRender(renderer, scene, camera, geometry, material, group) {
      if (material._hadOwnSide) {
        material.side = material._actualSide;
      } else {
        delete material.side;
      }
    }
    /**
     * Shortcut to dispose the geometry specific to this instance.
     * Note: we don't also dispose the derived material here because if anything else is
     * sharing the same base material it will result in a pause next frame as the program
     * is recompiled. Instead users can dispose the base material manually, like normal,
     * and we'll also dispose the derived material at that time.
     */
    dispose() {
      this.geometry.dispose();
    }
    /**
     * @property {TroikaTextRenderInfo|null} textRenderInfo
     * @readonly
     * The current processed rendering data for this TextMesh, returned by the TextBuilder after
     * a `sync()` call. This will be `null` initially, and may be stale for a short period until
     * the asynchrous `sync()` process completes.
     */
    get textRenderInfo() {
      return this._textRenderInfo || null;
    }
    // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
    get material() {
      let derivedMaterial = this._derivedMaterial;
      const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());
      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {
        derivedMaterial = this._derivedMaterial = createTextDerivedMaterial(baseMaterial);
        baseMaterial.addEventListener("dispose", function onDispose() {
          baseMaterial.removeEventListener("dispose", onDispose);
          derivedMaterial.dispose();
        });
      }
      if (this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
        let outlineMaterial = derivedMaterial._outlineMtl;
        if (!outlineMaterial) {
          outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {
            id: { value: derivedMaterial.id + 0.1 }
          });
          outlineMaterial.isTextOutlineMaterial = true;
          outlineMaterial.depthWrite = false;
          outlineMaterial.map = null;
          derivedMaterial.addEventListener("dispose", function onDispose() {
            derivedMaterial.removeEventListener("dispose", onDispose);
            outlineMaterial.dispose();
          });
        }
        return [
          outlineMaterial,
          derivedMaterial
        ];
      } else {
        return derivedMaterial;
      }
    }
    set material(baseMaterial) {
      if (baseMaterial && baseMaterial.isTroikaTextMaterial) {
        this._derivedMaterial = baseMaterial;
        this._baseMaterial = baseMaterial.baseMaterial;
      } else {
        this._baseMaterial = baseMaterial;
      }
    }
    get glyphGeometryDetail() {
      return this.geometry.detail;
    }
    set glyphGeometryDetail(detail) {
      this.geometry.detail = detail;
    }
    get curveRadius() {
      return this.geometry.curveRadius;
    }
    set curveRadius(r) {
      this.geometry.curveRadius = r;
    }
    // Create and update material for shadows upon request:
    get customDepthMaterial() {
      return first(this.material).getDepthMaterial();
    }
    get customDistanceMaterial() {
      return first(this.material).getDistanceMaterial();
    }
    _prepareForRender(material) {
      const isOutline = material.isTextOutlineMaterial;
      const uniforms = material.uniforms;
      const textInfo = this.textRenderInfo;
      if (textInfo) {
        const { sdfTexture, blockBounds } = textInfo;
        uniforms.uTroikaSDFTexture.value = sdfTexture;
        uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);
        uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;
        uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;
        uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);
        uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;
        let distanceOffset = 0;
        let blurRadius = 0;
        let strokeWidth = 0;
        let fillOpacity;
        let strokeOpacity;
        let strokeColor;
        let offsetX = 0;
        let offsetY = 0;
        if (isOutline) {
          let { outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity } = this;
          distanceOffset = this._parsePercent(outlineWidth) || 0;
          blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);
          fillOpacity = outlineOpacity;
          offsetX = this._parsePercent(outlineOffsetX) || 0;
          offsetY = this._parsePercent(outlineOffsetY) || 0;
        } else {
          strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);
          if (strokeWidth) {
            strokeColor = this.strokeColor;
            uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);
            strokeOpacity = this.strokeOpacity;
            if (strokeOpacity == null)
              strokeOpacity = 1;
          }
          fillOpacity = this.fillOpacity;
        }
        uniforms.uTroikaDistanceOffset.value = distanceOffset;
        uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);
        uniforms.uTroikaBlurRadius.value = blurRadius;
        uniforms.uTroikaStrokeWidth.value = strokeWidth;
        uniforms.uTroikaStrokeOpacity.value = strokeOpacity;
        uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;
        uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;
        let clipRect = this.clipRect;
        if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {
          uniforms.uTroikaClipRect.value.fromArray(clipRect);
        } else {
          const pad = (this.fontSize || 0.1) * 100;
          uniforms.uTroikaClipRect.value.set(
            blockBounds[0] - pad,
            blockBounds[1] - pad,
            blockBounds[2] + pad,
            blockBounds[3] + pad
          );
        }
        this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);
      }
      uniforms.uTroikaSDFDebug.value = !!this.debugSDF;
      material.polygonOffset = !!this.depthOffset;
      material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;
      const color = isOutline ? this.outlineColor || 0 : this.color;
      if (color == null) {
        delete material.color;
      } else {
        const colorObj = material.hasOwnProperty("color") ? material.color : material.color = new Color();
        if (color !== colorObj._input || typeof color === "object") {
          colorObj.set(colorObj._input = color);
        }
      }
      let orient = this.orientation || defaultOrient;
      if (orient !== material._orientation) {
        let rotMat = uniforms.uTroikaOrient.value;
        orient = orient.replace(/[^-+xyz]/g, "");
        let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);
        if (match) {
          let [, hSign, hAxis, vSign, vAxis] = match;
          tempVec3a.set(0, 0, 0)[hAxis] = hSign === "-" ? 1 : -1;
          tempVec3b.set(0, 0, 0)[vAxis] = vSign === "-" ? -1 : 1;
          tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);
          rotMat.setFromMatrix4(tempMat4);
        } else {
          rotMat.identity();
        }
        material._orientation = orient;
      }
    }
    _parsePercent(value) {
      if (typeof value === "string") {
        let match = value.match(/^(-?[\d.]+)%$/);
        let pct = match ? parseFloat(match[1]) : NaN;
        value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;
      }
      return value;
    }
    /**
     * Translate a point in local space to an x/y in the text plane.
     */
    localPositionToTextCoords(position, target = new Vector2()) {
      target.copy(position);
      const r = this.curveRadius;
      if (r) {
        target.x = Math.atan2(position.x, Math.abs(r) - Math.abs(position.z)) * Math.abs(r);
      }
      return target;
    }
    /**
     * Translate a point in world space to an x/y in the text plane.
     */
    worldPositionToTextCoords(position, target = new Vector2()) {
      tempVec3a.copy(position);
      return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target);
    }
    /**
     * @override Custom raycasting to test against the whole text block's max rectangular bounds
     * TODO is there any reason to make this more granular, like within individual line or glyph rects?
     */
    raycast(raycaster, intersects) {
      const { textRenderInfo, curveRadius } = this;
      if (textRenderInfo) {
        const bounds = textRenderInfo.blockBounds;
        const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();
        const geom = raycastMesh.geometry;
        const { position, uv } = geom.attributes;
        for (let i = 0; i < uv.count; i++) {
          let x2 = bounds[0] + uv.getX(i) * (bounds[2] - bounds[0]);
          const y = bounds[1] + uv.getY(i) * (bounds[3] - bounds[1]);
          let z = 0;
          if (curveRadius) {
            z = curveRadius - Math.cos(x2 / curveRadius) * curveRadius;
            x2 = Math.sin(x2 / curveRadius) * curveRadius;
          }
          position.setXYZ(i, x2, y, z);
        }
        geom.boundingSphere = this.geometry.boundingSphere;
        geom.boundingBox = this.geometry.boundingBox;
        raycastMesh.matrixWorld = this.matrixWorld;
        raycastMesh.material.side = this.material.side;
        tempArray.length = 0;
        raycastMesh.raycast(raycaster, tempArray);
        for (let i = 0; i < tempArray.length; i++) {
          tempArray[i].object = this;
          intersects.push(tempArray[i]);
        }
      }
    }
    copy(source) {
      const geom = this.geometry;
      super.copy(source);
      this.geometry = geom;
      COPYABLE_PROPS.forEach((prop) => {
        this[prop] = source[prop];
      });
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  SYNCABLE_PROPS.forEach((prop) => {
    const privateKey = "_private_" + prop;
    Object.defineProperty(Text2.prototype, prop, {
      get() {
        return this[privateKey];
      },
      set(value) {
        if (value !== this[privateKey]) {
          this[privateKey] = value;
          this._needsSync = true;
        }
      }
    });
  });
  let deprMsgShown = false;
  Object.defineProperty(Text2.prototype, "anchor", {
    get() {
      return this._deprecated_anchor;
    },
    set(val) {
      this._deprecated_anchor = val;
      if (!deprMsgShown) {
        console.warn("TextMesh: `anchor` has been deprecated; use `anchorX` and `anchorY` instead.");
        deprMsgShown = true;
      }
      if (Array.isArray(val)) {
        this.anchorX = `${(+val[0] || 0) * 100}%`;
        this.anchorY = `${(+val[1] || 0) * 100}%`;
      } else {
        this.anchorX = this.anchorY = 0;
      }
    }
  });
  return Text2;
})();

// node_modules/@threlte/extras/dist/components/Text/Text.svelte
var get_default_slot_changes12 = (dirty) => ({ ref: dirty & /*ref*/
1 });
var get_default_slot_context12 = (ctx) => ({ ref: (
  /*ref*/
  ctx[0]
) });
function create_default_slot16(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context12
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        65)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes12
            ),
            get_default_slot_context12
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot16.name,
    type: "slot",
    source: "(18:0) <T is={ref} let:ref {...$$restProps} bind:this={$component}>",
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*ref*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let t_props = {
    $$slots: {
      default: [create_default_slot16, ({ ref }) => ({ 0: ref }), ({ ref }) => ref ? 1 : 0]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[5](t2);
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = dirty & /*ref, $$restProps*/
      9 ? get_spread_update(t_spread_levels, [
        dirty & /*ref*/
        1 && { is: (
          /*ref*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope, ref*/
      65) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[5](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  const omit_props_names = ["ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Text", slots, ["default"]);
  const ref = new Text();
  const { invalidate } = useThrelte();
  const dispatch = createEventDispatcher();
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(1, $component = value));
  const onUpdate = async () => {
    await tick();
    ref.sync(() => {
      invalidate("Text: sync finished");
      dispatch("sync");
    });
  };
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    forwardEventHandlers,
    T,
    useThrelte,
    createEventDispatcher,
    tick,
    Text,
    ref,
    invalidate,
    dispatch,
    component,
    onUpdate,
    $component
  });
  $$self.$$.update = () => {
    $:
      $$restProps && onUpdate();
  };
  return [ref, $component, component, $$restProps, slots, t_binding, $$scope];
}
var Text_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, { ref: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Text_1",
      options,
      id: create_fragment20.name
    });
  }
  get ref() {
    return this.$$.ctx[0];
  }
  set ref(value) {
    throw new Error("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Text_default = Text_1;

// node_modules/@threlte/extras/dist/audio/useThrelteAudio.js
function useThrelteAudio() {
  const audioCtx = {
    audioListeners: /* @__PURE__ */ new Map(),
    addAudioListener: (listener, id) => {
      id = id ?? "default";
      if (audioCtx.audioListeners.has(id)) {
        console.warn(`An AudioListener with the id "${id}" has already been added, aborting.`);
        return;
      }
      audioCtx.audioListeners.set(id, listener);
    },
    removeAudioListener: (id) => {
      id = id ?? "default";
      if (!audioCtx.audioListeners.has(id)) {
        console.warn(`No AudioListener with the id "${id}" found, aborting.`);
        return;
      }
      audioCtx.audioListeners.delete(id);
    },
    getAudioListener: (id) => {
      id = id ?? "default";
      if (!audioCtx.audioListeners.has(id)) {
        console.warn(`No AudioListener with the id "${id}" found, aborting.`);
        return;
      }
      return audioCtx.audioListeners.get(id);
    }
  };
  return useThrelteUserContext("threlte-audio", audioCtx);
}

// node_modules/@threlte/extras/dist/audio/AudioListener/AudioListener.svelte
var get_default_slot_changes13 = (dirty) => ({ ref: dirty & /*ref*/
1 });
var get_default_slot_context13 = (ctx) => ({ ref: (
  /*ref*/
  ctx[0]
) });
function create_default_slot17(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context13
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        1025)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes13
            ),
            get_default_slot_context13
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot17.name,
    type: "slot",
    source: "(20:0) <T is={ref} {...$$restProps} let:ref bind:this={$component}>",
    ctx
  });
  return block;
}
function create_fragment21(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*ref*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let t_props = {
    $$slots: {
      default: [create_default_slot17, ({ ref }) => ({ 0: ref }), ({ ref }) => ref ? 1 : 0]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[9](t2);
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = dirty & /*ref, $$restProps*/
      9 ? get_spread_update(t_spread_levels, [
        dirty & /*ref*/
        1 && { is: (
          /*ref*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope, ref*/
      1025) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[9](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  const omit_props_names = ["id", "masterVolume", "ref", "audioContext", "resumeContext"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AudioListener", slots, ["default"]);
  let { id = void 0 } = $$props;
  let { masterVolume = void 0 } = $$props;
  const ref = new AudioListener();
  const audioContext = ref.context;
  const resumeContext = async () => await ref.context.resume();
  const { addAudioListener, removeAudioListener } = useThrelteAudio();
  addAudioListener(ref, id);
  onDestroy(() => {
    removeAudioListener(id);
  });
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(1, $component = value));
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(4, id = $$new_props.id);
    if ("masterVolume" in $$new_props)
      $$invalidate(5, masterVolume = $$new_props.masterVolume);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    forwardEventHandlers,
    T,
    onDestroy,
    ThreeAudioListener: AudioListener,
    useThrelteAudio,
    id,
    masterVolume,
    ref,
    audioContext,
    resumeContext,
    addAudioListener,
    removeAudioListener,
    component,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props)
      $$invalidate(4, id = $$new_props.id);
    if ("masterVolume" in $$props)
      $$invalidate(5, masterVolume = $$new_props.masterVolume);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*masterVolume*/
    32) {
      $:
        if (masterVolume !== void 0)
          ref.setMasterVolume(masterVolume);
    }
  };
  return [
    ref,
    $component,
    component,
    $$restProps,
    id,
    masterVolume,
    audioContext,
    resumeContext,
    slots,
    t_binding,
    $$scope
  ];
}
var AudioListener2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, {
      id: 4,
      masterVolume: 5,
      ref: 0,
      audioContext: 6,
      resumeContext: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AudioListener",
      options,
      id: create_fragment21.name
    });
  }
  get id() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get masterVolume() {
    throw new Error("<AudioListener>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set masterVolume(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    return this.$$.ctx[0];
  }
  set ref(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get audioContext() {
    return this.$$.ctx[6];
  }
  set audioContext(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resumeContext() {
    return this.$$.ctx[7];
  }
  set resumeContext(value) {
    throw new Error("<AudioListener>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AudioListener_default = AudioListener2;

// node_modules/@threlte/extras/dist/audio/utils/useAudio.js
var useAudio = (audio) => {
  const loaded = currentWritable(false);
  const autoplay = currentWritable(false);
  const shouldPlay = currentWritable(false);
  let audioDestroyed = false;
  const loader = useLoader(AudioLoader);
  const dispatch = createRawEventDispatcher();
  const setSrc = async (source) => {
    var _a;
    loaded.set(false);
    try {
      if (typeof source === "string") {
        const audioBuffer = await loader.load(source, {
          onProgress(event) {
            dispatch("progress", event);
          }
        });
        audio.setBuffer(audioBuffer);
      } else if (source instanceof AudioBuffer) {
        audio.setBuffer(source);
      } else if (source instanceof HTMLMediaElement) {
        audio.setMediaElementSource(source);
      } else if (source instanceof AudioBufferSourceNode) {
        audio.setNodeSource(source);
      } else if (source instanceof MediaStream) {
        audio.setMediaStreamSource(source);
      }
      loaded.set(true);
      ((_a = audio.source) == null ? void 0 : _a.buffer) ? dispatch("load", audio.source.buffer) : dispatch("load");
    } catch (error) {
      dispatch("error", error);
    }
  };
  const setVolume = (volume) => {
    audio.setVolume(volume ?? 1);
  };
  const setPlaybackRate = (playbackRate) => {
    audio.setPlaybackRate(playbackRate ?? 1);
  };
  const play = async (delay) => {
    if (!loaded.current) {
      shouldPlay.set(true);
      return;
    }
    if (audio.context.state !== "running") {
      await audio.context.resume();
      if (audioDestroyed) {
        return;
      }
    }
    return audio.play(delay);
  };
  const pause = () => {
    return audio.pause();
  };
  const stop = () => {
    if (!audio.source)
      return audio;
    return audio.stop();
  };
  const setAutoPlay = (value) => {
    autoplay.set(value ?? false);
  };
  const setDetune = (value) => {
    if (audio.source && audio.source.detune) {
      audio.setDetune(value ?? 0);
    }
  };
  const setLoop = (value) => {
    audio.setLoop(value ?? false);
  };
  watch([loaded, autoplay, shouldPlay], ([loaded2, autoplay2, shouldPlay2]) => {
    if (!loaded2) {
      if (audio.isPlaying)
        stop();
      return;
    }
    if (autoplay2 || shouldPlay2) {
      play();
    }
  });
  onDestroy(() => {
    try {
      audioDestroyed = true;
      stop();
    } catch (error) {
      console.warn("Error while destroying audio", error);
    }
  });
  return {
    setVolume,
    setSrc,
    setPlaybackRate,
    setAutoPlay,
    setDetune,
    setLoop,
    play,
    pause,
    stop
  };
};

// node_modules/@threlte/extras/dist/audio/Audio/Audio.svelte
var { Error: Error_18 } = globals;
var get_default_slot_changes14 = (dirty) => ({ ref: dirty & /*ref*/
1 });
var get_default_slot_context14 = (ctx) => ({ ref: (
  /*ref*/
  ctx[0]
) });
function create_default_slot18(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_default_slot_context14
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        65537)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_default_slot_changes14
            ),
            get_default_slot_context14
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot18.name,
    type: "slot",
    source: "(29:0) <T is={ref} {...$$restProps} let:ref bind:this={$component}>",
    ctx
  });
  return block;
}
function create_fragment22(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*ref*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let t_props = {
    $$slots: {
      default: [create_default_slot18, ({ ref }) => ({ 0: ref }), ({ ref }) => ref ? 1 : 0]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[15](t2);
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = dirty & /*ref, $$restProps*/
      9 ? get_spread_update(t_spread_levels, [
        dirty & /*ref*/
        1 && { is: (
          /*ref*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope, ref*/
      65537) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[15](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "src",
    "id",
    "volume",
    "playbackRate",
    "autoplay",
    "detune",
    "loop",
    "ref",
    "pause",
    "play",
    "stop"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Audio", slots, ["default"]);
  let { src } = $$props;
  let { id = void 0 } = $$props;
  let { volume = void 0 } = $$props;
  let { playbackRate = void 0 } = $$props;
  let { autoplay = void 0 } = $$props;
  let { detune = void 0 } = $$props;
  let { loop = void 0 } = $$props;
  const { getAudioListener } = useThrelteAudio();
  const listener = getAudioListener(id);
  if (!listener) {
    throw new Error(`No Audiolistener with id ${id} found.`);
  }
  const ref = new Audio(listener);
  const { pause, play, stop, setAutoPlay, setDetune, setLoop, setPlaybackRate, setSrc, setVolume } = useAudio(ref);
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(1, $component = value));
  $$self.$$.on_mount.push(function() {
    if (src === void 0 && !("src" in $$props || $$self.$$.bound[$$self.$$.props["src"]])) {
      console.warn("<Audio> was created without expected prop 'src'");
    }
  });
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("src" in $$new_props)
      $$invalidate(4, src = $$new_props.src);
    if ("id" in $$new_props)
      $$invalidate(5, id = $$new_props.id);
    if ("volume" in $$new_props)
      $$invalidate(6, volume = $$new_props.volume);
    if ("playbackRate" in $$new_props)
      $$invalidate(7, playbackRate = $$new_props.playbackRate);
    if ("autoplay" in $$new_props)
      $$invalidate(8, autoplay = $$new_props.autoplay);
    if ("detune" in $$new_props)
      $$invalidate(9, detune = $$new_props.detune);
    if ("loop" in $$new_props)
      $$invalidate(10, loop = $$new_props.loop);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    forwardEventHandlers,
    T,
    ThreeAudio: Audio,
    useAudio,
    useThrelteAudio,
    src,
    id,
    volume,
    playbackRate,
    autoplay,
    detune,
    loop,
    getAudioListener,
    listener,
    ref,
    pause,
    play,
    stop,
    setAutoPlay,
    setDetune,
    setLoop,
    setPlaybackRate,
    setSrc,
    setVolume,
    component,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("src" in $$props)
      $$invalidate(4, src = $$new_props.src);
    if ("id" in $$props)
      $$invalidate(5, id = $$new_props.id);
    if ("volume" in $$props)
      $$invalidate(6, volume = $$new_props.volume);
    if ("playbackRate" in $$props)
      $$invalidate(7, playbackRate = $$new_props.playbackRate);
    if ("autoplay" in $$props)
      $$invalidate(8, autoplay = $$new_props.autoplay);
    if ("detune" in $$props)
      $$invalidate(9, detune = $$new_props.detune);
    if ("loop" in $$props)
      $$invalidate(10, loop = $$new_props.loop);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*autoplay*/
    256) {
      $:
        setAutoPlay(autoplay);
    }
    if ($$self.$$.dirty & /*src*/
    16) {
      $:
        setSrc(src);
    }
    if ($$self.$$.dirty & /*volume*/
    64) {
      $:
        setVolume(volume);
    }
    if ($$self.$$.dirty & /*playbackRate*/
    128) {
      $:
        setPlaybackRate(playbackRate);
    }
    if ($$self.$$.dirty & /*loop*/
    1024) {
      $:
        setLoop(loop);
    }
    if ($$self.$$.dirty & /*detune*/
    512) {
      $:
        setDetune(detune);
    }
  };
  return [
    ref,
    $component,
    component,
    $$restProps,
    src,
    id,
    volume,
    playbackRate,
    autoplay,
    detune,
    loop,
    pause,
    play,
    stop,
    slots,
    t_binding,
    $$scope
  ];
}
var Audio2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, {
      src: 4,
      id: 5,
      volume: 6,
      playbackRate: 7,
      autoplay: 8,
      detune: 9,
      loop: 10,
      ref: 0,
      pause: 11,
      play: 12,
      stop: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Audio",
      options,
      id: create_fragment22.name
    });
  }
  get src() {
    throw new Error_18("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error_18("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error_18("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error_18("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get volume() {
    throw new Error_18("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set volume(value) {
    throw new Error_18("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get playbackRate() {
    throw new Error_18("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set playbackRate(value) {
    throw new Error_18("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoplay() {
    throw new Error_18("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoplay(value) {
    throw new Error_18("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get detune() {
    throw new Error_18("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set detune(value) {
    throw new Error_18("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error_18("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error_18("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    return this.$$.ctx[0];
  }
  set ref(value) {
    throw new Error_18("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pause() {
    return this.$$.ctx[11];
  }
  set pause(value) {
    throw new Error_18("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get play() {
    return this.$$.ctx[12];
  }
  set play(value) {
    throw new Error_18("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stop() {
    return this.$$.ctx[13];
  }
  set stop(value) {
    throw new Error_18("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Audio_default = Audio2;

// node_modules/@threlte/extras/dist/audio/PositionalAudio/PositionalAudio.svelte
var { Error: Error_19 } = globals;
var get_default_slot_changes15 = (dirty) => ({ ref: dirty & /*ref*/
1 });
var get_default_slot_context15 = (ctx) => ({ ref: (
  /*ref*/
  ctx[0]
) });
function create_default_slot19(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    get_default_slot_context15
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, ref*/
        2097153)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              get_default_slot_changes15
            ),
            get_default_slot_context15
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot19.name,
    type: "slot",
    source: "(47:0) <T is={ref} {...$$restProps} let:ref bind:this={$component}>",
    ctx
  });
  return block;
}
function create_fragment23(ctx) {
  let t2;
  let current;
  const t_spread_levels = [
    { is: (
      /*ref*/
      ctx[0]
    ) },
    /*$$restProps*/
    ctx[3]
  ];
  let t_props = {
    $$slots: {
      default: [create_default_slot19, ({ ref }) => ({ 0: ref }), ({ ref }) => ref ? 1 : 0]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < t_spread_levels.length; i += 1) {
    t_props = assign(t_props, t_spread_levels[i]);
  }
  t2 = new T({ props: t_props, $$inline: true });
  ctx[20](t2);
  const block = {
    c: function create() {
      create_component(t2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(t2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(t2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const t_changes = dirty & /*ref, $$restProps*/
      9 ? get_spread_update(t_spread_levels, [
        dirty & /*ref*/
        1 && { is: (
          /*ref*/
          ctx2[0]
        ) },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx2[3]
        )
      ]) : {};
      if (dirty & /*$$scope, ref*/
      2097153) {
        t_changes.$$scope = { dirty, ctx: ctx2 };
      }
      t2.$set(t_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(t2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(t2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[20](null);
      destroy_component(t2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "src",
    "id",
    "volume",
    "playbackRate",
    "autoplay",
    "detune",
    "loop",
    "directionalCone",
    "refDistance",
    "rolloffFactor",
    "distanceModel",
    "maxDistance",
    "ref",
    "pause",
    "play",
    "stop"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $component;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PositionalAudio", slots, ["default"]);
  let { src } = $$props;
  let { id = void 0 } = $$props;
  let { volume = void 0 } = $$props;
  let { playbackRate = void 0 } = $$props;
  let { autoplay = void 0 } = $$props;
  let { detune = void 0 } = $$props;
  let { loop = void 0 } = $$props;
  let { directionalCone = void 0 } = $$props;
  let { refDistance = void 0 } = $$props;
  let { rolloffFactor = void 0 } = $$props;
  let { distanceModel = void 0 } = $$props;
  let { maxDistance = void 0 } = $$props;
  const { getAudioListener } = useThrelteAudio();
  const listener = getAudioListener(id);
  if (!listener) {
    throw new Error(`No Audiolistener with id ${id} found.`);
  }
  const ref = new PositionalAudio(listener);
  const { pause, play, stop, setAutoPlay, setDetune, setLoop, setPlaybackRate, setSrc: setSource, setVolume } = useAudio(ref);
  const component = forwardEventHandlers();
  validate_store(component, "component");
  component_subscribe($$self, component, (value) => $$invalidate(1, $component = value));
  $$self.$$.on_mount.push(function() {
    if (src === void 0 && !("src" in $$props || $$self.$$.bound[$$self.$$.props["src"]])) {
      console.warn("<PositionalAudio> was created without expected prop 'src'");
    }
  });
  function t_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $component = $$value;
      component.set($component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("src" in $$new_props)
      $$invalidate(4, src = $$new_props.src);
    if ("id" in $$new_props)
      $$invalidate(5, id = $$new_props.id);
    if ("volume" in $$new_props)
      $$invalidate(6, volume = $$new_props.volume);
    if ("playbackRate" in $$new_props)
      $$invalidate(7, playbackRate = $$new_props.playbackRate);
    if ("autoplay" in $$new_props)
      $$invalidate(8, autoplay = $$new_props.autoplay);
    if ("detune" in $$new_props)
      $$invalidate(9, detune = $$new_props.detune);
    if ("loop" in $$new_props)
      $$invalidate(10, loop = $$new_props.loop);
    if ("directionalCone" in $$new_props)
      $$invalidate(11, directionalCone = $$new_props.directionalCone);
    if ("refDistance" in $$new_props)
      $$invalidate(12, refDistance = $$new_props.refDistance);
    if ("rolloffFactor" in $$new_props)
      $$invalidate(13, rolloffFactor = $$new_props.rolloffFactor);
    if ("distanceModel" in $$new_props)
      $$invalidate(14, distanceModel = $$new_props.distanceModel);
    if ("maxDistance" in $$new_props)
      $$invalidate(15, maxDistance = $$new_props.maxDistance);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    forwardEventHandlers,
    T,
    ThreePositionalAudio: PositionalAudio,
    useAudio,
    useThrelteAudio,
    src,
    id,
    volume,
    playbackRate,
    autoplay,
    detune,
    loop,
    directionalCone,
    refDistance,
    rolloffFactor,
    distanceModel,
    maxDistance,
    getAudioListener,
    listener,
    ref,
    pause,
    play,
    stop,
    setAutoPlay,
    setDetune,
    setLoop,
    setPlaybackRate,
    setSource,
    setVolume,
    component,
    $component
  });
  $$self.$inject_state = ($$new_props) => {
    if ("src" in $$props)
      $$invalidate(4, src = $$new_props.src);
    if ("id" in $$props)
      $$invalidate(5, id = $$new_props.id);
    if ("volume" in $$props)
      $$invalidate(6, volume = $$new_props.volume);
    if ("playbackRate" in $$props)
      $$invalidate(7, playbackRate = $$new_props.playbackRate);
    if ("autoplay" in $$props)
      $$invalidate(8, autoplay = $$new_props.autoplay);
    if ("detune" in $$props)
      $$invalidate(9, detune = $$new_props.detune);
    if ("loop" in $$props)
      $$invalidate(10, loop = $$new_props.loop);
    if ("directionalCone" in $$props)
      $$invalidate(11, directionalCone = $$new_props.directionalCone);
    if ("refDistance" in $$props)
      $$invalidate(12, refDistance = $$new_props.refDistance);
    if ("rolloffFactor" in $$props)
      $$invalidate(13, rolloffFactor = $$new_props.rolloffFactor);
    if ("distanceModel" in $$props)
      $$invalidate(14, distanceModel = $$new_props.distanceModel);
    if ("maxDistance" in $$props)
      $$invalidate(15, maxDistance = $$new_props.maxDistance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*refDistance, rolloffFactor, distanceModel, maxDistance, directionalCone*/
    63488) {
      $: {
        if (refDistance !== void 0)
          ref.setRefDistance(refDistance);
        if (rolloffFactor !== void 0)
          ref.setRolloffFactor(rolloffFactor);
        if (distanceModel !== void 0)
          ref.setDistanceModel(distanceModel);
        if (maxDistance !== void 0)
          ref.setMaxDistance(maxDistance);
        if (directionalCone !== void 0) {
          ref.setDirectionalCone(directionalCone.coneInnerAngle, directionalCone.coneOuterAngle, directionalCone.coneOuterGain);
        }
      }
    }
    if ($$self.$$.dirty & /*autoplay*/
    256) {
      $:
        setAutoPlay(autoplay);
    }
    if ($$self.$$.dirty & /*src*/
    16) {
      $:
        setSource(src);
    }
    if ($$self.$$.dirty & /*volume*/
    64) {
      $:
        setVolume(volume);
    }
    if ($$self.$$.dirty & /*playbackRate*/
    128) {
      $:
        setPlaybackRate(playbackRate);
    }
    if ($$self.$$.dirty & /*loop*/
    1024) {
      $:
        setLoop(loop);
    }
    if ($$self.$$.dirty & /*detune*/
    512) {
      $:
        setDetune(detune);
    }
  };
  return [
    ref,
    $component,
    component,
    $$restProps,
    src,
    id,
    volume,
    playbackRate,
    autoplay,
    detune,
    loop,
    directionalCone,
    refDistance,
    rolloffFactor,
    distanceModel,
    maxDistance,
    pause,
    play,
    stop,
    slots,
    t_binding,
    $$scope
  ];
}
var PositionalAudio2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, {
      src: 4,
      id: 5,
      volume: 6,
      playbackRate: 7,
      autoplay: 8,
      detune: 9,
      loop: 10,
      directionalCone: 11,
      refDistance: 12,
      rolloffFactor: 13,
      distanceModel: 14,
      maxDistance: 15,
      ref: 0,
      pause: 16,
      play: 17,
      stop: 18
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PositionalAudio",
      options,
      id: create_fragment23.name
    });
  }
  get src() {
    throw new Error_19("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error_19("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error_19("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error_19("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get volume() {
    throw new Error_19("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set volume(value) {
    throw new Error_19("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get playbackRate() {
    throw new Error_19("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set playbackRate(value) {
    throw new Error_19("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoplay() {
    throw new Error_19("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoplay(value) {
    throw new Error_19("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get detune() {
    throw new Error_19("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set detune(value) {
    throw new Error_19("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error_19("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error_19("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get directionalCone() {
    throw new Error_19("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set directionalCone(value) {
    throw new Error_19("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get refDistance() {
    throw new Error_19("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set refDistance(value) {
    throw new Error_19("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rolloffFactor() {
    throw new Error_19("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rolloffFactor(value) {
    throw new Error_19("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get distanceModel() {
    throw new Error_19("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set distanceModel(value) {
    throw new Error_19("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxDistance() {
    throw new Error_19("<PositionalAudio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxDistance(value) {
    throw new Error_19("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    return this.$$.ctx[0];
  }
  set ref(value) {
    throw new Error_19("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pause() {
    return this.$$.ctx[16];
  }
  set pause(value) {
    throw new Error_19("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get play() {
    return this.$$.ctx[17];
  }
  set play(value) {
    throw new Error_19("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stop() {
    return this.$$.ctx[18];
  }
  set stop(value) {
    throw new Error_19("<PositionalAudio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PositionalAudio_default = PositionalAudio2;

// node_modules/@threlte/extras/dist/audio/useAudioListener.js
function useAudioListener(callbackOrId, id) {
  const { getAudioListener } = useThrelteAudio();
  if (callbackOrId && typeof callbackOrId === "string") {
    const listener = getAudioListener(callbackOrId);
    if (!listener)
      throw new Error("No AudioListener found.");
    return {
      listener,
      context: listener.context
    };
  } else if (callbackOrId && typeof callbackOrId === "function") {
    const listener = getAudioListener(id);
    if (!listener)
      throw new Error("No AudioListener found.");
    return callbackOrId({
      listener,
      context: listener.context
    });
  } else {
    const listener = getAudioListener();
    if (!listener)
      throw new Error("No AudioListener found.");
    return {
      listener,
      context: listener.context
    };
  }
}

// node_modules/@threlte/extras/dist/interactivity/defaults.js
var getDefaultComputeFunction = (state) => {
  const camera = memoize(useThrelte().camera);
  let width = 0;
  let height = 0;
  const resizeObserver = new ResizeObserver((entries) => {
    for (const entry of entries) {
      width = entry.contentRect.width;
      height = entry.contentRect.height;
    }
  });
  watch(state.target, (target) => {
    if (target)
      resizeObserver.observe(target);
    return () => {
      if (target)
        resizeObserver.unobserve(target);
    };
  });
  return (event, state2) => {
    state2.pointer.update((pointer) => {
      pointer.set(event.offsetX / width * 2 - 1, -(event.offsetY / height) * 2 + 1);
      return pointer;
    });
    state2.raycaster.setFromCamera(state2.pointer.current, camera.current);
  };
};

// node_modules/@threlte/extras/dist/interactivity/hook.js
var useInteractivity = () => {
  const state = getContext("threlte-interactivity-context");
  const eventDispatcher = createRawEventDispatcher();
  const addInteractiveObject = (object) => {
    if (!state) {
      console.warn("No interactivity context found. Did you forget to implement interactivity()?");
      return;
    }
    object.userData._threlte_interactivity_dispatcher = eventDispatcher;
    if (state.interactiveObjects.find((obj) => obj.uuid === object.uuid))
      return;
    state.interactiveObjects.push(object);
  };
  const removeInteractiveObject = (object) => {
    if (!state) {
      console.warn("No interactivity context found. Did you forget to implement interactivity()?");
      return;
    }
    state.interactiveObjects = state.interactiveObjects.filter((obj) => obj.uuid !== object.uuid);
    delete object.userData._threlte_interactivity_dispatcher;
  };
  return {
    ...state,
    addInteractiveObject,
    removeInteractiveObject
  };
};

// node_modules/@threlte/extras/dist/interactivity/useComponentHasEventHandlers.js
var useComponentHasEventHandlers = (eventNames) => {
  const component = get_current_component();
  const hasEventHandlers = writable(false);
  onMount(() => {
    hasEventHandlers.set(!!Object.keys(component.$$.callbacks).filter((value) => eventNames ? eventNames.includes(value) : true).length);
  });
  return {
    hasEventHandlers
  };
};

// node_modules/@threlte/extras/dist/interactivity/plugin.js
var interactivityEventNames = [
  "click",
  "contextmenu",
  "dblclick",
  "wheel",
  "pointerup",
  "pointerdown",
  "pointerover",
  "pointerout",
  "pointerenter",
  "pointerleave",
  "pointermove",
  "pointermissed"
];
var injectInteractivityPlugin = () => {
  injectPlugin("interactivity", ({ ref }) => {
    if (!(ref instanceof Object3D))
      return;
    const { addInteractiveObject, removeInteractiveObject } = useInteractivity();
    const refStore = writable(ref);
    const { hasEventHandlers } = useComponentHasEventHandlers(interactivityEventNames);
    watch([hasEventHandlers, refStore], ([hasEventHandlers2, ref2]) => {
      if (!hasEventHandlers2)
        return;
      addInteractiveObject(ref2);
      return () => removeInteractiveObject(ref2);
    });
    return {
      onRefChange(ref2) {
        refStore.set(ref2);
      }
    };
  });
};

// node_modules/@threlte/extras/dist/interactivity/setupInteractivity.js
var getRawEventDispatcher = (object) => {
  return object.userData._threlte_interactivity_dispatcher;
};
function getIntersectionId(event) {
  return (event.eventObject || event.object).uuid + "/" + event.index + event.instanceId;
}
var DOM_EVENTS = [
  ["click", false],
  ["contextmenu", false],
  ["dblclick", false],
  ["wheel", false],
  ["pointerdown", true],
  ["pointerup", true],
  ["pointerleave", true],
  ["pointerenter", true],
  ["pointermove", true],
  ["pointercancel", true]
];
var setupInteractivity = (state) => {
  function calculateDistance(event) {
    const dx = event.offsetX - state.initialClick[0];
    const dy = event.offsetY - state.initialClick[1];
    return Math.round(Math.sqrt(dx * dx + dy * dy));
  }
  function cancelPointer(intersections) {
    for (const hoveredObj of state.hovered.values()) {
      if (!intersections.length || !intersections.find((hit) => {
        return hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId;
      })) {
        const eventObject = hoveredObj.eventObject;
        state.hovered.delete(getIntersectionId(hoveredObj));
        const eventDispatcher = getRawEventDispatcher(eventObject);
        if (eventDispatcher) {
          const data = { ...hoveredObj, intersections };
          eventDispatcher("pointerout", data);
          eventDispatcher("pointerleave", data);
        }
      }
    }
  }
  const enabled = memoize(state.enabled);
  const getHits = () => {
    const duplicates = /* @__PURE__ */ new Set();
    const intersections = [];
    let hits = state.interactiveObjects.flatMap((obj) => enabled.current ? state.raycaster.intersectObject(obj, true) : []).sort((a, b) => a.distance - b.distance).filter((item) => {
      const id = getIntersectionId(item);
      if (duplicates.has(id))
        return false;
      duplicates.add(id);
      return true;
    });
    if (state.filter)
      hits = state.filter(hits, state);
    for (const hit of hits) {
      let eventObject = hit.object;
      while (eventObject) {
        if (getRawEventDispatcher(eventObject))
          intersections.push({ ...hit, eventObject });
        eventObject = eventObject.parent;
      }
    }
    return intersections;
  };
  function pointerMissed(event, objects) {
    for (let i = 0; i < objects.length; i++) {
      const eventDispatcher = getRawEventDispatcher(objects[i]);
      if (!eventDispatcher)
        continue;
      eventDispatcher("pointermissed", event);
    }
  }
  const getEventHandler = (name) => {
    if (name === "pointerleave" || name === "pointercancel") {
      return () => {
        state.pointerOverTarget.set(false);
        cancelPointer([]);
      };
    }
    if (name === "pointerenter") {
      return () => {
        state.pointerOverTarget.set(true);
      };
    }
    return (event) => {
      const isPointerMove = name === "pointermove";
      const isClickEvent = name === "click" || name === "contextmenu" || name === "dblclick";
      state.compute(event, state);
      const hits = getHits();
      const delta = isClickEvent ? calculateDistance(event) : 0;
      if (name === "pointerdown") {
        state.initialClick = [event.offsetX, event.offsetY];
        state.initialHits = hits.map((hit) => hit.eventObject);
      }
      if (isClickEvent && !hits.length) {
        if (delta <= 2) {
          pointerMissed(event, state.interactiveObjects);
        }
      }
      if (isPointerMove)
        cancelPointer(hits);
      let stopped = false;
      dispatchEvents:
        for (const hit of hits) {
          const intersectionEvent = {
            stopped,
            ...hit,
            intersections: hits,
            stopPropagation() {
              stopped = true;
              intersectionEvent.stopped = true;
              if (state.hovered.size && Array.from(state.hovered.values()).find((i) => i.eventObject === hit.eventObject)) {
                const higher = hits.slice(0, hits.indexOf(hit));
                cancelPointer([...higher, hit]);
              }
            },
            camera: state.raycaster.camera,
            delta,
            nativeEvent: event,
            pointer: state.pointer.current,
            ray: state.raycaster.ray
          };
          const eventDispatcher = getRawEventDispatcher(hit.eventObject);
          if (!eventDispatcher)
            return;
          if (isPointerMove) {
            if (eventDispatcher.hasEventListener("pointerover") || eventDispatcher.hasEventListener("pointerenter") || eventDispatcher.hasEventListener("pointerout") || eventDispatcher.hasEventListener("pointerleave")) {
              const id = getIntersectionId(intersectionEvent);
              const hoveredItem = state.hovered.get(id);
              if (!hoveredItem) {
                state.hovered.set(id, intersectionEvent);
                eventDispatcher("pointerover", intersectionEvent);
                eventDispatcher("pointerenter", intersectionEvent);
              } else if (hoveredItem.stopped) {
                intersectionEvent.stopPropagation();
              }
            }
            eventDispatcher("pointermove", intersectionEvent);
          } else {
            const hasEventListener = eventDispatcher.hasEventListener(name);
            if (hasEventListener) {
              if (!isClickEvent || state.initialHits.includes(hit.eventObject)) {
                pointerMissed(event, state.interactiveObjects.filter((object) => !state.initialHits.includes(object)));
                eventDispatcher(name, intersectionEvent);
              }
            } else {
              if (isClickEvent && state.initialHits.includes(hit.eventObject)) {
                pointerMissed(event, state.interactiveObjects.filter((object) => !state.initialHits.includes(object)));
              }
            }
          }
          if (stopped)
            break dispatchEvents;
        }
    };
  };
  const disconnect = (target) => {
    DOM_EVENTS.forEach(([eventName]) => {
      target.removeEventListener(eventName, getEventHandler(eventName));
    });
  };
  const connect = (target) => {
    DOM_EVENTS.forEach(([eventName, passive]) => {
      target.addEventListener(eventName, getEventHandler(eventName), { passive });
    });
  };
  watch(state.target, (target) => {
    if (target)
      connect(target);
    return () => {
      if (target)
        disconnect(target);
    };
  });
};

// node_modules/@threlte/extras/dist/interactivity/index.js
var interactivity = (options) => {
  var _a;
  const state = {
    enabled: currentWritable((options == null ? void 0 : options.enabled) ?? true),
    pointer: currentWritable(new Vector2()),
    pointerOverTarget: currentWritable(false),
    lastEvent: void 0,
    raycaster: new Raycaster(),
    initialClick: [0, 0],
    initialHits: [],
    hovered: /* @__PURE__ */ new Map(),
    interactiveObjects: [],
    target: currentWritable((options == null ? void 0 : options.target) ?? ((_a = useThrelte().renderer) == null ? void 0 : _a.domElement)),
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    compute: () => {
    },
    filter: options == null ? void 0 : options.filter
  };
  state.compute = (options == null ? void 0 : options.compute) ?? getDefaultComputeFunction(state);
  setContext("threlte-interactivity-context", state);
  injectInteractivityPlugin();
  setupInteractivity(state);
  return state;
};

// node_modules/@threlte/extras/dist/transitions/transitions-plugin.js
var fragmentFunctions = {
  create: "c",
  claim: "l",
  hydrate: "h",
  mount: "m",
  update: "p",
  measure: "r",
  fix: "f",
  animate: "a",
  intro: "i",
  outro: "o",
  destroy: "d"
};
var appendToFragmentFunction = (component, fragmentFn, append) => {
  const fragment = component.$$.fragment;
  const fragmentFnShorthand = fragmentFunctions[fragmentFn];
  const original = fragment[fragmentFnShorthand];
  fragment[fragmentFnShorthand] = (...args) => {
    append(...args);
    original(...args);
  };
};
var transitions = () => {
  injectPlugin("transitions", ({ ref, props }) => {
    if (!props.in && !props.out && !props.transition)
      return;
    const { invalidate } = useThrelte();
    const dispatch = createRawEventDispatcher();
    let currentRef = ref;
    const el = {
      style: {},
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      dispatchEvent: (...args) => {
        const eventType = args[0].type;
        dispatch(eventType, ...args);
      }
    };
    const comp = get_current_component();
    const convertTransition = (transition) => {
      return (_node, _params, options) => {
        const t2 = transition(currentRef, {
          direction: options.direction
        });
        return {
          ...t2,
          tick(...args) {
            var _a;
            invalidate();
            (_a = t2 == null ? void 0 : t2.tick) == null ? void 0 : _a.call(t2, ...args);
          }
        };
      };
    };
    if (props.transition) {
      let transition;
      onMount(() => {
        add_render_callback(() => {
          if (!transition) {
            if (!props.transition)
              return;
            transition = create_bidirectional_transition(el, convertTransition(props.transition), {}, true);
          }
          transition.run(1);
        });
        appendToFragmentFunction(comp, "intro", () => {
          add_render_callback(() => {
            if (!transition) {
              if (!props.transition)
                return;
              transition = create_bidirectional_transition(el, convertTransition(props.transition), {}, true);
            }
            transition.run(1);
          });
        });
        appendToFragmentFunction(comp, "outro", () => {
          if (!transition) {
            if (!props.transition)
              return;
            transition = create_bidirectional_transition(el, convertTransition(props.transition), {}, false);
          }
          transition.run(0);
        });
        appendToFragmentFunction(comp, "destroy", (...args) => {
          const detaching = args[0];
          if (detaching && transition)
            transition.end();
        });
      });
    } else {
      if (props.in) {
        let intro;
        onMount(() => {
          add_render_callback(() => {
            if (!props.in)
              return;
            intro = create_in_transition(el, convertTransition(props.in), {});
            intro.start();
          });
          appendToFragmentFunction(comp, "outro", (...args) => {
            intro == null ? void 0 : intro.end();
          });
        });
      }
      if (props.out) {
        let outro;
        onMount(() => {
          appendToFragmentFunction(comp, "outro", (...args) => {
            if (!props.out)
              return;
            outro = create_out_transition(el, convertTransition(props.out), {});
          });
          appendToFragmentFunction(comp, "intro", (...args) => {
            outro == null ? void 0 : outro.end(1);
          });
          appendToFragmentFunction(comp, "destroy", (...args) => {
            const detaching = args[0];
            if (detaching && outro)
              outro.end(0);
          });
        });
      }
    }
    return {
      onRefChange(ref2) {
        currentRef = ref2;
      },
      pluginProps: ["in", "out", "transition"]
    };
  });
};

// node_modules/@threlte/extras/dist/transitions/createTransition.js
var createTransition = (transition) => transition;

// node_modules/@threlte/extras/dist/layers/plugin.js
var isObject3D = (ref) => {
  return ref instanceof Object3D;
};
var propIsThrelteLayers = (prop) => {
  return prop === "all" || prop === "none" || Array.isArray(prop) && prop.every((v) => typeof v === "number") || typeof prop === "number" && prop >= 0 && prop <= 31;
};
var injectLayersPlugin = () => {
  injectPlugin("layers", ({ ref, props }) => {
    if (!isObject3D(ref))
      return;
    const local = writable(props.layers && propIsThrelteLayers(props.layers) ? props.layers : void 0);
    const ctx = getContext("threlte-layers-context");
    const merged = derived([local, ctx], ([prop, ctx2]) => prop ?? ctx2);
    setContext("threlte-layers-context", merged);
    const applyLayers = (ref2, layers2) => {
      console.log("applyLayers", layers2, ref2);
      if (layers2 === "all") {
        ref2.layers.enableAll();
      } else if (layers2 === "none") {
        ref2.layers.disableAll();
      } else if (Array.isArray(layers2)) {
        for (let index = 0; index < 32; index += 1) {
          const layerIndex = index;
          const enabled = layers2.includes(layerIndex);
          if (enabled) {
            ref2.layers.enable(index);
          } else {
            ref2.layers.disable(index);
          }
        }
      } else if (layers2 !== void 0) {
        ref2.layers.set(layers2);
      }
    };
    const refStore = writable(ref);
    watch([refStore, merged], ([ref2, layers2]) => {
      applyLayers(ref2, layers2);
    });
    return {
      onRestPropsChange(restProps) {
        local.set(restProps.layers && propIsThrelteLayers(restProps.layers) ? restProps.layers : void 0);
      },
      onRefChange(ref2) {
        if (!isObject3D(ref2))
          return;
        refStore.set(ref2);
      },
      pluginProps: ["layers"]
    };
  });
};

// node_modules/@threlte/extras/dist/layers/index.js
var layers = (options) => {
  const local = writable((options == null ? void 0 : options.defaultLayers) ?? 0);
  setContext("threlte-layers-context", local);
  injectLayersPlugin();
};
export {
  Audio_default as Audio,
  AudioListener_default as AudioListener,
  ContactShadows_default as ContactShadows,
  Disposables_default as Disposables,
  Edges_default as Edges,
  Environment_default as Environment,
  Float_default as Float,
  GLTF_default as GLTF,
  Grid_default as Grid,
  HTML_default as HTML,
  Instance_default as Instance,
  InstancedMesh_default as InstancedMesh,
  InstancedMeshes_default as InstancedMeshes,
  OrbitControls_default as OrbitControls,
  Portal_default as Portal,
  PortalTarget_default as PortalTarget,
  PositionalAudio_default as PositionalAudio,
  Suspense_default as Suspense,
  Text_default as Text,
  TransformControls_default as TransformControls,
  createTransition,
  interactivity,
  layers,
  onReveal,
  onSuspend,
  transitions,
  useAudioListener,
  useCursor,
  useGltf,
  useGltfAnimations,
  useInteractivity,
  useProgress,
  useSuspense,
  useTexture,
  useThrelteAudio
};
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

troika-three-text/dist/troika-three-text.esm.js:
  (*!
  Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
  Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
  *)
  (*!
  Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
  (https://github.com/101arrowz/fflate) for use in Troika text rendering. 
  Original licenses apply: 
  - fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
  - woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
  *)
*/
//# sourceMappingURL=@threlte_extras.js.map
